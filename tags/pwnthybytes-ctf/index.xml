<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pwnthybytes-ctf on Black Bauhinia</title>
    <link>https://b6a.black/tags/pwnthybytes-ctf/</link>
    <description>Recent content in pwnthybytes-ctf on Black Bauhinia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Oct 2019 23:20:00 +0800</lastBuildDate><atom:link href="https://b6a.black/tags/pwnthybytes-ctf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PwnThyBytes CTF 2019 Writeup</title>
      <link>https://b6a.black/posts/2019-10-02-pwnthybytes/</link>
      <pubDate>Wed, 02 Oct 2019 23:20:00 +0800</pubDate>
      
      <guid>https://b6a.black/posts/2019-10-02-pwnthybytes/</guid>
      <description>Pass the Hash (Warmup/Learning; 50 points) Solved by Mystiz.
Challenge Summary We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160. The hash takes two arguments, salt (20 bytes) and password (22 bytes). We are allowed to control the salt, whilst the goal is to find the password within 1024 queries.
Hash construction We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160.</description>
    </item>
    
  </channel>
</rss>
