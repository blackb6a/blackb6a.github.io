<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CryptoCTF 2023 Writeup | Black Bauhinia</title>

<meta name="keywords" content="ctf" />
<meta name="description" content="Welcome!! (23 points, 663 solves) Difficulty: Warm-up
We surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone who participated üíú
 Did it! (33 points, 220 solves) Difficulty: Easy
The parameters $n = 127$ and $\ell = 20$ is fixed. A hidden subset of $\ell$ numbers $S \subseteq \{0, 1, \cdots, n - 1\}$ with $|S| \leq \ell$ is chosen, and we are given $13$ calls to the following oracle: Given a set $T \subseteq {0, 1, \cdots, n - 1}$ also with $|T| \leq \ell$, the server computes $T \setminus S$ and outputs $\{(u^2 &#43; \varepsilon) \pmod{n} : u \in T \setminus S, \varepsilon \in \{0, 1\}\}$.">
<meta name="author" content="grhkm, nhho, TWY">
<link rel="canonical" href="https://b6a.black/posts/2023-08-28-cryptoctf/" />
<link href="/assets/css/stylesheet.min.79c4dfee3993cd3110886e38d36a5106e0d6922344cefa3ff5c0076f246815f0.css" integrity="sha256-ecTf7jmTzTEQiG4402pRBuDWkiNEzvo/9cAHbyRoFfA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b6a.black/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.91.0" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-M67YZZ2MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M67YZZ2MP1');
</script>



<script src="https://kit.fontawesome.com/fbbadced05.js" crossorigin="anonymous"></script>


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Recursive&display=swap" rel="stylesheet"> 


<meta property="og:title" content="CryptoCTF 2023 Writeup" />
<meta property="og:description" content="Welcome!! (23 points, 663 solves) Difficulty: Warm-up
We surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone who participated üíú
 Did it! (33 points, 220 solves) Difficulty: Easy
The parameters $n = 127$ and $\ell = 20$ is fixed. A hidden subset of $\ell$ numbers $S \subseteq \{0, 1, \cdots, n - 1\}$ with $|S| \leq \ell$ is chosen, and we are given $13$ calls to the following oracle: Given a set $T \subseteq {0, 1, \cdots, n - 1}$ also with $|T| \leq \ell$, the server computes $T \setminus S$ and outputs $\{(u^2 &#43; \varepsilon) \pmod{n} : u \in T \setminus S, \varepsilon \in \{0, 1\}\}$." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://b6a.black/posts/2023-08-28-cryptoctf/" />
<meta property="article:published_time" content="2023-08-28T17:56:00+08:00" />
<meta property="article:modified_time" content="2023-08-28T17:56:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CryptoCTF 2023 Writeup"/>
<meta name="twitter:description" content="Welcome!! (23 points, 663 solves) Difficulty: Warm-up
We surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone who participated üíú
 Did it! (33 points, 220 solves) Difficulty: Easy
The parameters $n = 127$ and $\ell = 20$ is fixed. A hidden subset of $\ell$ numbers $S \subseteq \{0, 1, \cdots, n - 1\}$ with $|S| \leq \ell$ is chosen, and we are given $13$ calls to the following oracle: Given a set $T \subseteq {0, 1, \cdots, n - 1}$ also with $|T| \leq \ell$, the server computes $T \setminus S$ and outputs $\{(u^2 &#43; \varepsilon) \pmod{n} : u \in T \setminus S, \varepsilon \in \{0, 1\}\}$."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CryptoCTF 2023 Writeup",
  "name": "CryptoCTF 2023 Writeup",
  "description": "Welcome!! (23 points, 663 solves) Difficulty: Warm-up\nWe surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone ‚Ä¶",
  "keywords": [
    "ctf"
  ],
  "articleBody": "Welcome!! (23 points, 663 solves) Difficulty: Warm-up\nWe surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone who participated üíú\n Did it! (33 points, 220 solves) Difficulty: Easy\nThe parameters $n = 127$ and $\\ell = 20$ is fixed. A hidden subset of $\\ell$ numbers $S \\subseteq \\{0, 1, \\cdots, n - 1\\}$ with $|S| \\leq \\ell$ is chosen, and we are given $13$ calls to the following oracle: Given a set $T \\subseteq {0, 1, \\cdots, n - 1}$ also with $|T| \\leq \\ell$, the server computes $T \\setminus S$ and outputs $\\{(u^2 + \\varepsilon) \\pmod{n} : u \\in T \\setminus S, \\varepsilon \\in \\{0, 1\\}\\}$.\nSolution 1 (TWY): Note that there are only $\\frac{n - 1}{2}$ quadratic residues modulo $n$ and their distribution is pseudorandom. Hence, we can partition them into several sets such that in each set, the quadratic residues are all ‚Äúspaced out‚Äù i.e. differ by $2$ or more. Then, we can uniquely decode the output from the oracle, allowing us to recover $S$.\nSolution 2 (grhkm): We simply throw random oracle calls $T$ at the server and see whether any of the elements from $T$ cannot possibly by in $T \\setminus S$, i.e. neither $u^2 \\pmod{n}$ nor $(u^2 + 1) \\pmod{n}$ is in the server output. Then, those must be in $S$. Repeat this until we recover $S$.\n Blue Office (36 points, 181 solves) Difficulty: Easy\nWe are given a simple stream cipher with a custom seed generation function and a LCG reseeding function. Literally every part of the cipher is weak, but we can focus on lines 9 and 10:\ndef reseed(s): return s * 214013 + 2531011 def encrypt(s, msg): assert s  16) \u0026 0xff)).to_bytes(1, 'big') c += 1 return enc The message is xor‚Äôed with (d  16) \u0026 0xff, which is bit 16 to 23 of d. Since reseed is a LCG, we can just bruteforce all seeds s and compute d also mod 2**24.\n Suction (41 points, 151 solves) Difficulty: Easy\nRSA parameters with $p, q \\sim 2^{128}$ and $e \\sim 2^{16}$ are generated. However, we are only given $N' = \\lfloor pq / 2^8 \\rfloor$ and $e' = \\lfloor e / 2^8 \\rfloor$. This is not a problem to us, as we know that $N \\in [2^8 pq, 2^8 pq + 2^8)$. We used our teammate TWY‚Äôs computer to factor all these numbers. To quote, ‚Äúit took 4 seconds‚Äù. (4 seconds is the time to test $e$ lul)\n(All primes and numbers with any factor less than 10000 have been eliminated before factoring.)\nIn the end, we see that $N = N' + 69$ and $(p, q) = (188473222069998143349386719941755726311, \\cdots)$, and testing the $256$ candidates for $e$ yields the flag.\n Insights (59 points, 88 solves) We are given RSA parameters with several vulnerability, the most critical one being in how the secret generation:\ndef genKey(L, nbit): p, q = [genPrime(L, nbit) for _ in '__'] n = p * q d = next_prime(pow(n, 0.2919)) phi = (p - 1) * (q - 1) e = inverse(d, phi) pubkey, privkey = (n, e), (p, q) return pubkey, privkey Since we know $n$ from the output, we can just compute $d$ and decrypt the message as $m = c^d \\pmod{n}$‚Ä¶\n Resuction (64 points, 78 solves) Similar to the setup of Suction, we are given the masked values $N'$ and $e'$ with the lower $8$ bits masked away. This time, we have another vulnerability:\ndef keygen(nbit, r): while True: p, q = [getPrime(nbit) for _ in '__'] d, n = getPrime(64), p * q phi = (p - 1) * (q - 1) if GCD(d, phi) == 1: e = inverse(d, phi) N = bin(n)[2:-r] E = bin(e)[2:-r] PKEY = N + E pkey = (n, e) return PKEY, pkey Note that $d Derik (68 points, 73 solves) We are given constants $C_0, \\cdots, C_7$ and the following system of equations:\n$$\\begin{cases} C_0 p - C_1 q \u0026\\geq 0 \\\\ C_2 q - C_3 r \u0026\\geq 0 \\\\ C_4 r - C_5 s \u0026\\geq 0 \\\\ C_6 e - C_7 d \u0026= 31337 \\\\ (C_0 p - C_1 q)^e + (C_2 q - C_3 r)^e + (C_4 r - C_5 s)^e \u0026= d(C_0 p - C_1 q)(C_2 q - C_3 r)(C_4 r - C_5 s) \\\\ p, q, r, s, d \\quad \\text{are primes} \\end{cases}$$\nFrom the fourth equation, we can recover possible values of $(e, d) = (3, 73)$. This turns the fifth equation into one of the form $X^3 + Y^3 + Z^3 = 73XYZ$, which is birational equivalent to an elliptic curve. Therefore, we can recover a rational point as follows:\nR = PolynomialRing(QQ, \"x, y, z\") x, y, z = R.gens() C = x**3 + y**3 + z**3 - 73 * x * y * z phi = EllipticCurve_from_cubic(C) E = phi.codomain() X, Y, _ = phi.inverse()(E.gen(0)) Z = lcm(X.denom(), Y.denom()) X, Y = X * Z, Y * Z print(X, Y, Z) # 2848691279889518 1391526622949983 89200900157319 From here, we can make an educated guess that $(C_0p - C_1q, C_2q - C_3r, C_4r - C_5s) = \\sigma(X, Y, Z)$, where $\\sigma$ denotes a permutation. From this, we solve for $p, q, r$ and hence the RSA system.\nThere are many unintended solutions, e.g. searching for integer solutions from this paper, or from guessing parameters from parts of code that we did not cover.   ASIv1 (80 points, 59 solves) Difficulty: Medium\nThe flag is encoded as a base $3$ vector $f$ in $\\mathbb{F}_3^l$ with $\\ell = 110$. Then, $\\ell^2$ random vectors $s_i \\in \\mathbb{F}_3^{\\ell}$ are generated, and we are given $(s_i, f \\cdot s_i)$, the dot product of the vectors.\nSince dot product is linear in each of the vector components, we can write out a system of $\\ell^2$ linear equations in $\\ell$ variables and solve for $f$.\nIt seems that the original solution involves adding error (and probably Arora-Ge), but I guess the challenge author messed up.\n TPSD (82 points, 57 solves) We are given many challenges $(a, b)$, and have to provide a triplet of numbers $(p, q, r)$ such that $p^3 + q^3 + r^3 = 1$, $2^{a - 1} \\leq \\min(|p|, |q|, |r|) \\leq 2^b - 1$ and at least one of them being prime.\nSolution: A set of solutions are parametrised by $(p, q, r) = (9k^4, 3k - 9k^4, 1 - 9k^3)$, so we simply increment $k$ in the range given until we encounter a solution satisfying the conditions.\n Roldy (85 points, 55 solves) The challenge is based on Order-Preserving Encryption (OPE). In short, it is a scheme such that $x Solution: Binary search.\n Blobfish (90 points, 51 solves) We are given a password-protected compressed file (flag.zip) produced by linux zip utility, containing an image file (flag.png) with the AES-encrypted flag in hexadecimal form.\nThe known information is that the AES key used for encryption is a random 8-byte string repeated twice. The IV used is the MD5 digest of the key, and the zip password is the first 10 bytes of the key.\nSince these parameters are all related, we can recover all of them if we can recover the password of the compressed file. We can use an existing known plaintext attack tool, bkcrack to do so.\nTo carry out the attack, we need some known plaintext.\nPNG Format Dissection by corkami: Given the fixed dimension (800x50) of flag.png, all bytes before the CRC32 checksum in the header should be fixed. Therefore we can prepare our known plaintext file as the following:\nplain.txt According to bkcrack tutorial, we can obtain the internal key using the below command:\nbkcrack -C flag.zip -c flag.png -p plain.txt After a while the key 03492be6 b81a5123 24d7b146 will appear.\nWe can then recover the original password using another command:\nbkcrack -k 03492be6 b81a5123 24d7b146 -r 10 ?b After several seconds, a password ad 6e fb 79 2a ea 5a aa ad 6e (as bytes) should show up.\nWe can extract flag.png using this binary password. After that, we can use bytes.fromhex(\"ad 6e fb 79 2a ea 5a aa\") * 2 as the AES key and the MD5 hash of the key as IV to recover the flag.\n Trex (100 points, 45 solves) We are given twenty random challenges $a \\leq 2^{132}$, and we have to provide three distinct nonzero integers $x, y, z$ such that $x^2 - xy + y^2 = az^3$.\nSolution: $(x, y, z) = (24a^2, -24a^2, 12a)$ (More generally, a possible generating formula is $(x, y, z) = (3k^3 a^2, -3k^3 a^2, 3k^2 a)$).\nNote from grhkm: I spent an embarrassingly long time trying to factor $4a^4$ over $\\mathbb{Q}[\\sqrt{-3}]$, since any solution on $(x + y)^2 + 3(x - y)^2 = 4az^3$ where $(x + y, x - y) \\in \\mathbb{Q}$ yields a solution. Thank you to TWY for pointing out the solution above‚Ä¶\n Risk (122 points, 35 solves) We are given a RSA scheme $(n, e) = (pq, rs)$ where $(p, r), (q, s) \\leftarrow \\textrm{getPrime}(m, 2048)$ and $m$ being a hidden integer. Let us inspect getPrime:\ndef genPrime(m, nbit): assert m = 2 while True: a = getRandomNBitInteger(nbit // m) r = getRandomNBitInteger(m ** 2 - m + 2) p = a ** m + r if isPrime(p): return (p, r) Since we have $e = rs$, which is $28$ bits, we can deduce that $m = 4$, and also that $(r, s) = (10728, 14071)$. This means that $n = pq = (a^4 + 10728)(b^4 + 14071)$, where $a, b \\sim 2^{256}$. From this, it is clear that $n \\approx a^4b^4$, and indeed we have $ab = \\lfloor n^{1 / 4} \\rfloor$. Therefore, we can write $b = \\lfloor n^{1 / 4} \\rfloor / a$, substitute into $n = (a^4 + 10728)(b^4 + 14071)$, and recover the factorisation.\n Keymoted (146 points, 28 solves) We are given a complicated scheme, so we will not describe the scheme itself, but rather highlight the key points and how to solve it. Firstly, a RSA modulus $n$ is generated as follows:\nnbit = 256 p = getPrime(nbit) _s = p ^^ ((2 ** (nbit - 1)) + 2 ** (nbit // 2)) q = next_prime(2 * _s + 1) n = p * q Line 2 shows that $s' = p - 2^{b - 1} \\pm 2^{\\lfloor b / 2 \\rfloor}$, meaning that $q \\sim 2(p - 2^{\\lfloor b / 2 \\rfloor})$. Therefore, $n \\sim 2p(p - 2^{\\lfloor b / 2 \\rfloor})$. Therefore, we can solve for an approximation to $p$, then test $p \\in [\\tilde{p} - \\epsilon, \\tilde{p} + \\epsilon]$.\nFrom here, we are presented with the encryption scheme itself. First, random parameters $a, b$ are generated. Then, to encrypt a message $m$, we first increment $m$ until $m^3 + am + b$ is a quadratic residue both modulo $p$ and modulo $q$. Next, we compute $y = \\sqrt{m^3 + am + b} \\pmod{n}$ by CRT. Finally, the encryption is the point $[65537](m, y)$, where $[\\cdot]$ denotes scalar multiplication and $(m, y) \\in E / \\mathbb{Z}_n : y^2 = x^3 + ax + b$.\nTo decrypt this encryption, we simply note that $E / \\mathbb{Z}_n \\cong E / \\mathbb{F}_p \\times E / \\mathbb{F}_q$, so we can decrypt on the elliptic curves modulo $p$ and $q$ respectively, then combine the plaintexts with CRT. Decrypting the message modulo a prime is simple, as we simply compute $[65537^{-1}]P$, where $65537^{-1}$ is computed modulo the order of the curve.\n Barak (150 points, 27 solves) We are given an algebraic object Barak along with operations like on_barak, add_barak and mul_barak. We then have to solve a discrete logarithm problem:\nFLAG = flag.lstrip(b'CCTF{').rstrip(b'}') P = rand_barak(E) m = bytes_to_long(FLAG) assert m Let us first inspect the code of on_barak:\ndef on_barak(P, E): c, d, p = E x, y = P return (x**3 + y**3 + c - d*x*y) % p == 0 ... p = 73997272456239171124655017039956026551127725934222347 d = 68212800478915688445169020404812347140341674954375635 c = 1 E = (c, d, p) From this, we see that the algebraic objects given are indeed points on the curve $E / \\mathbb{F}_p: x^3 + y^3 - dxy + 1 = 0 \\pmod{p}$. Since it contains a rational point, say $(x, y) = (-1, 0)$, we know that it is birational to an elliptic curve. Using Sage, we can compute the equivalent model:\np = 73997272456239171124655017039956026551127725934222347 d = 68212800478915688445169020404812347140341674954375635 c = 1 R.= GF(p)[] C = x^3 + y^3 - d * x * y * z + c * z^3 E = EllipticCurve_from_cubic(C) print(E) # Elliptic Curve defined by y^2 = x^3 + ...*x + ... over Finite Field of size ... Note that we are usually able to compute the explicit morphism map between $C$ and $E$, but here $p$ is too large. Anyways, let us check out the parameters of $E$:\nE.order().factor() # 2^5 * 3^3 * 17 * 2341 * 23497 * 500369 * 5867327 * 33510311 * 13824276503 * 67342255597 We see that $|E / \\mathbb{F}_p|$ is relatively smooth, meaning that we can perform a Pohlig-Hellman attack on the problem.\n Big (169 points, 23 solves) We are presented with a known-plaintext setup on a custom scheme. Firstly, the key generation is as follows:\ndef genkey(nbit): while True: p = getPrime(nbit) if p % 4 == 3: q = int(str(p)[::-1]) if isPrime(q): return p * q, (p, q) This means that $n = pq = p \\cdot \\mathrm{rev}(p)$ where $\\mathrm{rev}$ reverses the (base-$10$) digits. Hence, we can perform a digit-by-digit search on $p$ and $q$, hence recovering the factorisation of $n$.\nOnto the actual scheme, let us write $\\left(\\cdot / \\cdot\\right)$ for the Kronecker symbol, a direct generalisation of Legendre‚Äôs symbol. For each bit of the flag $f_i$, we are given integers $s_i$ where $s_i = t_i - at_i^{-1} \\pmod{n}$, $a$ is a given constant such that $\\left(a / n\\right) = 1$, and $\\left(t_i / n\\right) = 2f_i - 1 \\in \\{-1, 1\\}$.\nTo recover $f_i$, we can first solve for $t_i$ by solving the quadratic equation $t_i^2 - s_it_i + a \\equiv 0 \\pmod{n}$, where the factorisation of $n$ is known from above. Then, we simply evaluate $\\left(t_i / n\\right)$ to get the flag bits.\n Byeween (174 points, 22 solves) We are given an elliptic curve over the rationals $E / \\mathbb{Q}$ and a point $Q \\in E / \\mathbb{Q}$, and we have to provide all the points $P$ such that $2P = Q$.\nOvercomplicated solution by grhkm: It is believed that $E / \\mathbb{Q}$ has rank $0$ or $1$ for asymptotically $100%$ of the time, with the average rank of elliptic curves being $\\frac{1}{2}$. Since we are given a rational point on the curve, it will almost always have rank $1$. Therefore, $Q$ can be written as a multiple of the unique generator $G$ of the group, and we can compute a solution to $2P = Q$. From here, all remaining solutions are given by $P' = P + R$, where $R \\in E[2]$ i.e. $2R = O$. These are given by $R = (x, 0)$ for the model $y^2 = f(x)$.\n Bertrand (180 points, 21 solves) Difficulty: Medium\nWe are given a 256x256 grayscale png. The flag is padded with printable chars to have length $256^2$ and then encypted with an unknown key in $\\mathbb{Z}_{256}^3$ as the pixels of the png.\nIf the relative order of the 3 elements in the unknown key $(k_1, k_2, k_3)$ is fixed, the pixels are in the form of $x_i = flag_{p_i} + c_{i,1} k_1 + c_{i,2} k_2 + c_{i,3} k_3 \\text{ mod } 256$ where $p$ is a permutation. For each of the relative orders of $k_1$, $k_2$ and $k_3$, $p_i$ and $c_{i,j}$ can be found by slightly modifying the encyption script.\nNotice that $(c_{i,1}, c_{i,2}, c_{i,3})$ often equals to one of $(3, 0, 0)$, $(0, 3, 0)$, $(0, 0, 3)$. As $x_i$ is known and $flag_{p_i}$ has a capped range (printable chars), they can be used to eliminate most of the possibities of $k_j$.\nOnly a few possibilites of $(k_1, k_2, k_3)$ left after that, exhausting them will give the flag.\n Shefid (209 points, 17 solves) Difficulty: Hard\nWe are presented with exactly the SIDH scheme.\nSolution: Perform Castryck and Decru‚Äôs attack on SIDH.\n Slowsum (209 points, 17 solves) Difficulty: Tough (?)\nWe are given the following interesting scheme (NB: Slightly modified):\nHash  The hash function $H(f)$, where $f \\in \\mathbb{F}_q[x]$, is defined as $$H(f) = f(1)^{\\left(\\frac{q - 1}{2} - f(1)\\right)} \\pmod{q}$$   Setup  Define $q = 113$ We send parameters $n \\geq 5$ and $d \\geq 3$ such that $nd \\geq q$ Define $R = \\mathbb{F}_q[x_1, \\cdots, x_n]$ We send a polynomial $f_0(x_1, \\cdots, x_n) \\in R$ with $\\deg(f_0) = d$. A checksum $h_0 = \\sum_{\\mathbf{x} \\in \\{0, 1\\}^n} f(\\mathbf{x})$ is computed   Verification  We send a sequence of data $(f_1, h_1), \\cdots, (f_n, h_n)$ such that  Polynomial: $f_i \\in \\mathbb{F}_q[x]$ is a univariate polynomial. Degree: $\\deg(f_i) \\leq d$ Check 1: For $i \\geq 2$, $f_i(0) + f_i(1) = f_{i - 1}(h_{i - 1})$ Check 2: $H(f_i) = h_i$   Final check: $f_0(h_1, \\cdots, h_n) = f_n(h_n)$ If all checks pass and $f_1(0) + f_1(1) = h_0$, the flag is given.    If you are looking at this and wondering what is going on, no worries, so am I. Nevertheless, the solution is pretty simple. We note that $H(f)$ is quite weak. For example, $H(x^k) = 1$ for any $k$. Therefore, the following parameters work:\n$$\\begin{aligned} \u0026 n = 5, d = 25 \\\\ \u0026 f_0 = x_1^{25} \\implies h_0 = 16 \\\\ \u0026 (f_i, h_i) = (x^i, 1) \\end{aligned}$$\nThis works as for the final check, $f_0(1, \\cdots, 1) = 1$ and of course $f_n(h_n) = 1$.\n Vinefruit (194 point, 19 solves) We are presented with a rolling hash $H_i(m) = c_i + \\sum_j m_j p_i^j \\pmod{2^{b_i}}$, where $(c_i, p_i, b_i)$ are one of three parameter sets (2166136261, 16777619, $2^{16}$), (14695981039346656037, 1099511628211, $2^{32}$), (144066263297769815596495629667062367629, 309485009821345068724781371, $2^{64}$). We are then asked to provide message collision pairs $m_1, m_2$ such that $|m_1| = |m_2| = 16$ (or longer, but we can simply add padding).\nTo solve this, we aim to find a vector message (with coefficients in $[32, 126]$), say $v$, such that $H_i(v) = c_i$. If we have such a message, then $H_i(m + v) = c_i + \\sum_j (m_j + v_j) p_i^j = \\left(c_i + \\sum_j m_j p_i^j\\right) + \\left(H_i(v) - c_i\\right) = H_i(m)$. To find such a vector, we expand the definition to get\n$$ H(v) = v_1p + v_2p^2 + \\cdots + v_{16}p^{16} \\pmod{2^b} $$\nWe can solve this by LLL, since the lattice\n$$\\begin{aligned} M = \\left(\\begin{array}{c|c|c} \\begin{matrix} p \\\\ p^2 \\\\ \\vdots \\\\ p^{16} \\end{matrix} \u0026 I_{16} \u0026 O \\\\ \\hline -c_i \u0026 O \u0026 1 \\\\ \\hline 2^b \u0026 O \u0026 O \\end{array}\\right) \\end{aligned}$$\nspans the vector $v = \\{0, v_1, v_2, \\cdots, v_{16}, 1\\}$. We can answer the challenges from here.\n",
  "wordCount" : "3221",
  "inLanguage": "en",
  "datePublished": "2023-08-28T17:56:00+08:00",
  "dateModified": "2023-08-28T17:56:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "grhkm"
  }, {
    "@type": "Person",
    "name": "nhho"
  }, {
    "@type": "Person",
    "name": "TWY"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://b6a.black/posts/2023-08-28-cryptoctf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Black Bauhinia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://b6a.black/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b6a.black/" accesskey="h" title="Black Bauhinia (Alt + H)">Black Bauhinia</a>
            <span class="logo-switches">
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://b6a.black/about-us/" title="About Us">
                    <span>About Us</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      CryptoCTF 2023 Writeup
    </h1>
    <div class="post-meta">

August 28, 2023&nbsp;¬∑&nbsp;grhkm, nhho, TWY

</div>
  </header>
  
  
  <div class="post-content js-toc-content">
<h2 id="welcome-23-points-663-solves">Welcome!! (23 points, 663 solves)<a hidden class="anchor" aria-hidden="true" href="#welcome-23-points-663-solves">#</a></h2>
<p>Difficulty: Warm-up</p>
<p>We surely did get warmed up this CTF, as we came second, even beating the Cryptohackers (merge) team! Well done to everyone who participated üíú</p>
<hr>
<h2 id="did-it-33-points-220-solves">Did it! (33 points, 220 solves)<a hidden class="anchor" aria-hidden="true" href="#did-it-33-points-220-solves">#</a></h2>
<p>Difficulty: Easy</p>
<p>The parameters $n = 127$ and $\ell = 20$ is fixed. A hidden subset of $\ell$ numbers $S \subseteq \{0, 1, \cdots, n - 1\}$ with $|S| \leq \ell$ is chosen, and we are given $13$ calls to the following oracle: Given a set $T \subseteq {0, 1, \cdots, n - 1}$ also with $|T| \leq \ell$, the server computes $T \setminus S$ and outputs $\{(u^2 + \varepsilon) \pmod{n} : u \in T \setminus S, \varepsilon \in \{0, 1\}\}$.</p>
<p>Solution 1 (TWY): Note that there are only $\frac{n - 1}{2}$ quadratic residues modulo $n$ and their distribution is pseudorandom. Hence, we can partition them into several sets such that in each set, the quadratic residues are all &ldquo;spaced out&rdquo; i.e. differ by $2$ or more. Then, we can uniquely decode the output from the oracle, allowing us to recover $S$.</p>
<p>Solution 2 (grhkm): We simply throw random oracle calls $T$ at the server and see whether any of the elements from $T$ <strong>cannot</strong>  possibly by in $T \setminus S$, i.e. neither $u^2 \pmod{n}$ nor $(u^2 + 1) \pmod{n}$ is in the server output. Then, those must be in $S$. Repeat this until we recover $S$.</p>
<hr>
<h2 id="blue-office-36-points-181-solves">Blue Office (36 points, 181 solves)<a hidden class="anchor" aria-hidden="true" href="#blue-office-36-points-181-solves">#</a></h2>
<p>Difficulty: Easy</p>
<p>We are given a simple stream cipher with a custom seed generation function and a LCG reseeding function. Literally every part of the cipher is weak, but we can focus on lines 9 and 10:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def reseed(s):
    return s * 214013 + 2531011

def encrypt(s, msg):
    assert s &lt;= 2**32
    c, d = 0, s
    enc, l = b'', len(msg)
    while c &lt; l:
        d = reseed(d)
        enc += (msg[c] ^ ((d &gt;&gt; 16) &amp; 0xff)).to_bytes(1, 'big') 
        c += 1
    return enc
</code></pre><p>The message is xor&rsquo;ed with <code>(d &gt;&gt; 16) &amp; 0xff</code>, which is bit 16 to 23 of <code>d</code>. Since <code>reseed</code> is a LCG, we can just bruteforce all seeds <code>s &lt;= 2**24</code> and compute <code>d</code> also mod <code>2**24</code>.</p>
<hr>
<h2 id="suction-41-points-151-solves">Suction (41 points, 151 solves)<a hidden class="anchor" aria-hidden="true" href="#suction-41-points-151-solves">#</a></h2>
<p>Difficulty: Easy</p>
<p>RSA parameters with $p, q \sim 2^{128}$ and $e \sim 2^{16}$ are generated. However, we are only given $N' = \lfloor pq / 2^8 \rfloor$ and $e' = \lfloor e / 2^8 \rfloor$. This is not a problem to us, as we know that $N \in [2^8 pq, 2^8 pq + 2^8)$. We used our teammate TWY&rsquo;s computer to factor all these numbers. <del>To quote, &ldquo;it took 4 seconds&rdquo;. (4 seconds is the time to test $e$ lul)</del></p>
<p><img src="/images/2023-08-28-cryptoctf/suction.png" alt="">
(All primes and numbers with any factor less than 10000 have been eliminated before factoring.)</p>
<p>In the end, we see that $N = N' + 69$ and $(p, q) = (188473222069998143349386719941755726311, \cdots)$, and testing the $256$ candidates for $e$ yields the flag.</p>
<hr>
<h2 id="insights-59-points-88-solves">Insights (59 points, 88 solves)<a hidden class="anchor" aria-hidden="true" href="#insights-59-points-88-solves">#</a></h2>
<p>We are given RSA parameters with several vulnerability, the most critical one being in how the secret generation:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def genKey(L, nbit):
    p, q = [genPrime(L, nbit) for _ in '__']
    n = p * q
    d = next_prime(pow(n, 0.2919))
    phi = (p - 1) * (q - 1)
    e = inverse(d, phi)
    pubkey, privkey = (n, e), (p, q)
    return pubkey, privkey
</code></pre><p>Since we know $n$ from the output, we can just compute $d$ and decrypt the message as $m = c^d \pmod{n}$&hellip;</p>
<hr>
<h2 id="resuction-64-points-78-solves">Resuction (64 points, 78 solves)<a hidden class="anchor" aria-hidden="true" href="#resuction-64-points-78-solves">#</a></h2>
<p>Similar to the setup of <a href="#Suction-41-points-151-solves">Suction</a>, we are given the masked values $N'$ and $e'$ with the lower $8$ bits masked away. This time, we have another vulnerability:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def keygen(nbit, r):
    while True:
        p, q = [getPrime(nbit) for _ in '__']
        d, n = getPrime(64), p * q
        phi = (p - 1) * (q - 1)
        if GCD(d, phi) == 1:
            e = inverse(d, phi)
            N = bin(n)[2:-r]
            E = bin(e)[2:-r]
            PKEY = N + E
            pkey = (n, e)
            return PKEY, pkey
</code></pre><p>Note that $d &lt; 2^{64}$ while $n \sim 2^{2048}$, so we can use the Wiener attack to recover $d$.</p>
<hr>
<h2 id="derik-68-points-73-solves">Derik (68 points, 73 solves)<a hidden class="anchor" aria-hidden="true" href="#derik-68-points-73-solves">#</a></h2>
<p>We are given constants $C_0, \cdots, C_7$ and the following system of equations:</p>
<p>$$\begin{cases}
C_0 p - C_1 q &amp;\geq 0 \\
C_2 q - C_3 r &amp;\geq 0 \\
C_4 r - C_5 s &amp;\geq 0 \\
C_6 e - C_7 d &amp;= 31337 \\
(C_0 p - C_1 q)^e + (C_2 q - C_3 r)^e + (C_4 r - C_5 s)^e &amp;= d(C_0 p - C_1 q)(C_2 q - C_3 r)(C_4 r - C_5 s) \\
p, q, r, s, d \quad \text{are primes}
\end{cases}$$</p>
<p>From the fourth equation, we can recover possible values of $(e, d) = (3, 73)$. This turns the fifth equation into one of the form $X^3 + Y^3 + Z^3 = 73XYZ$, which is birational equivalent to an elliptic curve. Therefore, we can recover a rational point as follows:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">R = PolynomialRing(QQ, &quot;x, y, z&quot;)
x, y, z = R.gens()
C = x**3 + y**3 + z**3 - 73 * x * y * z

phi = EllipticCurve_from_cubic(C)
E = phi.codomain()
X, Y, _ = phi.inverse()(E.gen(0))
Z = lcm(X.denom(), Y.denom())
X, Y = X * Z, Y * Z
print(X, Y, Z)
# 2848691279889518 1391526622949983 89200900157319
</code></pre><p>From here, we can make an educated guess that $(C_0p - C_1q, C_2q - C_3r, C_4r - C_5s) = \sigma(X, Y, Z)$, where $\sigma$ denotes a permutation. From this, we solve for $p, q, r$ and hence the RSA system.</p>
<div class="alert info">
  There are many unintended solutions, e.g. searching for integer solutions from <a href="http://matwbn.icm.edu.pl/ksiazki/aa/aa73/aa7331.pdf">this paper</a>, or from guessing parameters from parts of code that we did not cover.
</div>
  
<hr>
<h2 id="asiv1-80-points-59-solves">ASIv1 (80 points, 59 solves)<a hidden class="anchor" aria-hidden="true" href="#asiv1-80-points-59-solves">#</a></h2>
<p>Difficulty: Medium</p>
<p>The flag is encoded as a base $3$ vector $f$ in $\mathbb{F}_3^l$ with $\ell = 110$. Then, $\ell^2$ random vectors $s_i \in \mathbb{F}_3^{\ell}$ are generated, and we are given $(s_i, f \cdot s_i)$, the dot product of the vectors.</p>
<p>Since dot product is linear in each of the vector components, we can write out a system of $\ell^2$ linear equations in $\ell$ variables and solve for $f$.</p>
<p>It seems that the original solution involves adding error (and probably Arora-Ge), but I guess the challenge author messed up.</p>
<hr>
<h2 id="tpsd-82-points-57-solves">TPSD (82 points, 57 solves)<a hidden class="anchor" aria-hidden="true" href="#tpsd-82-points-57-solves">#</a></h2>
<p>We are given many challenges $(a, b)$, and have to provide a triplet of numbers $(p, q, r)$ such that $p^3 + q^3 + r^3 = 1$, $2^{a - 1} \leq \min(|p|, |q|, |r|) \leq 2^b - 1$ and at least one of them being prime.</p>
<p>Solution: A set of solutions are parametrised by $(p, q, r) = (9k^4, 3k - 9k^4, 1 - 9k^3)$, so we simply increment $k$ in the range given until we encounter a solution satisfying the conditions.</p>
<hr>
<h2 id="roldy-85-points-55-solves">Roldy (85 points, 55 solves)<a hidden class="anchor" aria-hidden="true" href="#roldy-85-points-55-solves">#</a></h2>
<p>The challenge is based on <a href="http://www.cc.gatech.edu/~aboldyre/papers/bclo.pdf">Order-Preserving Encryption (OPE)</a>. In short, it is a scheme such that $x &lt; y \iff \mathrm{Enc}(x) &lt; \mathrm{Enc}(y)$. We are given an encrypted flag and an oracle to compute the encryption of a message.</p>
<p>Solution: Binary search.</p>
<hr>
<h2 id="blobfish-90-points-51-solves">Blobfish (90 points, 51 solves)<a hidden class="anchor" aria-hidden="true" href="#blobfish-90-points-51-solves">#</a></h2>
<p>We are given a password-protected compressed file (flag.zip) produced by linux <code>zip</code> utility, containing an image file (flag.png) with the AES-encrypted flag in hexadecimal form.</p>
<p>The known information is that the AES key used for encryption is a random 8-byte string repeated twice. The IV used is the MD5 digest of the key, and the zip password is the first 10 bytes of the key.</p>
<p>Since these parameters are all related, we can recover all of them if we can recover the password of the compressed file. We can use an existing known plaintext attack tool, <a href="https://github.com/kimci86/bkcrack">bkcrack</a> to do so.</p>
<p>To carry out the attack, we need some known plaintext.</p>
<p><em>PNG Format Dissection by <a href="https://github.com/corkami/formats/tree/master">corkami</a>:</em>
<img src="/images/2023-08-28-cryptoctf/blobfish-png-format.png" alt=""></p>
<p>Given the fixed dimension (800x50) of flag.png, all bytes before the CRC32 checksum in the header should be fixed. Therefore we can prepare our known plaintext file as the following:</p>
<p><em>plain.txt</em>
<img src="/images/2023-08-28-cryptoctf/blobfish-plain.png" alt=""></p>
<p>According to <a href="https://github.com/kimci86/bkcrack/blob/master/example/tutorial.md">bkcrack tutorial</a>, we can obtain the internal key using the below command:</p>
<pre tabindex="0"><code>bkcrack -C flag.zip -c flag.png -p plain.txt
</code></pre><p>After a while the key <code>03492be6 b81a5123 24d7b146</code> will appear.</p>
<p>We can then recover the original password using another command:</p>
<pre tabindex="0"><code>bkcrack -k 03492be6 b81a5123 24d7b146 -r 10 ?b
</code></pre><p>After several seconds, a password <code>ad 6e fb 79 2a ea 5a aa ad 6e</code> (as bytes) should show up.</p>
<p>We can extract flag.png using this binary password. After that, we can use <code>bytes.fromhex(&quot;ad 6e fb 79 2a ea 5a aa&quot;) * 2</code> as the AES key and the MD5 hash of the key as IV to recover the flag.</p>
<hr>
<h2 id="trex-100-points-45-solves">Trex (100 points, 45 solves)<a hidden class="anchor" aria-hidden="true" href="#trex-100-points-45-solves">#</a></h2>
<p>We are given twenty random challenges $a \leq 2^{132}$, and we have to provide three distinct nonzero integers $x, y, z$ such that $x^2 - xy + y^2 = az^3$.</p>
<p>Solution: $(x, y, z) = (24a^2, -24a^2, 12a)$
(More generally, a possible generating formula is $(x, y, z) = (3k^3 a^2, -3k^3 a^2, 3k^2 a)$).</p>
<p>Note from grhkm: I spent an embarrassingly long time trying to factor $4a^4$ over $\mathbb{Q}[\sqrt{-3}]$, since any solution on $(x + y)^2 + 3(x - y)^2 = 4az^3$ where $(x + y, x - y) \in \mathbb{Q}$ yields a solution. Thank you to TWY for pointing out the solution above&hellip;</p>
<hr>
<h2 id="risk-122-points-35-solves">Risk (122 points, 35 solves)<a hidden class="anchor" aria-hidden="true" href="#risk-122-points-35-solves">#</a></h2>
<p>We are given a RSA scheme $(n, e) = (pq, rs)$ where $(p, r), (q, s) \leftarrow \textrm{getPrime}(m, 2048)$ and $m$ being a hidden integer. Let us inspect <code>getPrime</code>:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def genPrime(m, nbit):
    assert m &gt;= 2
    while True:
        a = getRandomNBitInteger(nbit // m)
        r = getRandomNBitInteger(m ** 2 - m + 2)
        p = a ** m + r
        if isPrime(p):
            return (p, r)
</code></pre><p>Since we have $e = rs$, which is $28$ bits, we can deduce that $m = 4$, and also that $(r, s) = (10728, 14071)$. This means that $n = pq = (a^4 + 10728)(b^4 + 14071)$, where $a, b \sim 2^{256}$. From this, it is clear that $n \approx a^4b^4$, and indeed we have $ab = \lfloor n^{1 / 4} \rfloor$. Therefore, we can write $b = \lfloor n^{1 / 4} \rfloor / a$, substitute into $n = (a^4 + 10728)(b^4 + 14071)$, and recover the factorisation.</p>
<hr>
<h2 id="keymoted-146-points-28-solves">Keymoted (146 points, 28 solves)<a hidden class="anchor" aria-hidden="true" href="#keymoted-146-points-28-solves">#</a></h2>
<p>We are given a complicated scheme, so we will not describe the scheme itself, but rather highlight the key points and how to solve it. Firstly, a RSA modulus $n$ is generated as follows:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">nbit = 256
p = getPrime(nbit)
_s = p ^^ ((2 ** (nbit - 1)) + 2 ** (nbit // 2))
q = next_prime(2 * _s + 1)
n = p * q
</code></pre><p>Line 2 shows that $s' = p - 2^{b - 1} \pm 2^{\lfloor b / 2 \rfloor}$, meaning that $q \sim 2(p - 2^{\lfloor b / 2 \rfloor})$. Therefore, $n \sim 2p(p - 2^{\lfloor b / 2 \rfloor})$. Therefore, we can solve for an approximation to $p$, then test $p \in [\tilde{p} - \epsilon, \tilde{p} + \epsilon]$.</p>
<p>From here, we are presented with the encryption scheme itself. First, random parameters $a, b$ are generated. Then, to encrypt a message $m$, we first increment $m$ until $m^3 + am + b$ is a quadratic residue both modulo $p$ and modulo $q$. Next, we compute $y = \sqrt{m^3 + am + b} \pmod{n}$ by CRT. Finally, the encryption is the point $[65537](m, y)$, where $[\cdot]$ denotes scalar multiplication and $(m, y) \in E / \mathbb{Z}_n : y^2 = x^3 + ax + b$.</p>
<p>To decrypt this encryption, we simply note that $E / \mathbb{Z}_n \cong E / \mathbb{F}_p \times E / \mathbb{F}_q$, so we can decrypt on the elliptic curves modulo $p$ and $q$ respectively, then combine the plaintexts with CRT. Decrypting the message modulo a prime is simple, as we simply compute $[65537^{-1}]P$, where $65537^{-1}$ is computed modulo the order of the curve.</p>
<hr>
<h2 id="barak-150-points-27-solves">Barak (150 points, 27 solves)<a hidden class="anchor" aria-hidden="true" href="#barak-150-points-27-solves">#</a></h2>
<p>We are given an algebraic object <code>Barak</code> along with operations like <code>on_barak</code>, <code>add_barak</code> and <code>mul_barak</code>. We then have to solve a discrete logarithm problem:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">FLAG = flag.lstrip(b'CCTF{').rstrip(b'}')
P = rand_barak(E)
m = bytes_to_long(FLAG) 
assert m &lt; p
Q = mul_barak(m, P, E)
</code></pre><p>Let us first inspect the code of <code>on_barak</code>:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def on_barak(P, E):
    c, d, p = E
    x, y = P
    return (x**3 + y**3 + c - d*x*y) % p == 0

...

p = 73997272456239171124655017039956026551127725934222347
d = 68212800478915688445169020404812347140341674954375635
c = 1
E = (c, d, p)
</code></pre><p>From this, we see that the algebraic objects given are indeed points on the curve $E / \mathbb{F}_p: x^3 + y^3 - dxy + 1 = 0 \pmod{p}$. Since it contains a rational point, say $(x, y) = (-1, 0)$, we know that it is birational to an elliptic curve. Using Sage, we can compute the equivalent model:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">p = 73997272456239171124655017039956026551127725934222347
d = 68212800478915688445169020404812347140341674954375635
c = 1

R.&lt;x, y, z&gt; = GF(p)[]
C = x^3 + y^3 - d * x * y * z + c * z^3
E = EllipticCurve_from_cubic(C)
print(E) # Elliptic Curve defined by y^2 = x^3 + ...*x + ... over Finite Field of size ...
</code></pre><p>Note that we are usually able to compute the explicit morphism map between $C$ and $E$, but here $p$ is too large. Anyways, let us check out the parameters of $E$:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">E.order().factor()
# 2^5 * 3^3 * 17 * 2341 * 23497 * 500369 * 5867327 * 33510311 * 13824276503 * 67342255597
</code></pre><p>We see that $|E / \mathbb{F}_p|$ is relatively smooth, meaning that we can perform a Pohlig-Hellman attack on the problem.</p>
<hr>
<h2 id="big-169-points-23-solves">Big (169 points, 23 solves)<a hidden class="anchor" aria-hidden="true" href="#big-169-points-23-solves">#</a></h2>
<p>We are presented with a known-plaintext setup on a custom scheme. Firstly, the key generation is as follows:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def genkey(nbit):
    while True:
        p = getPrime(nbit)
        if p % 4 == 3:
            q = int(str(p)[::-1])
            if isPrime(q):
                return p * q, (p, q)
</code></pre><p>This means that $n = pq = p \cdot \mathrm{rev}(p)$ where $\mathrm{rev}$ reverses the (base-$10$) digits. Hence, we can perform a digit-by-digit search on $p$ and $q$, hence recovering the factorisation of $n$.</p>
<p>Onto the actual scheme, let us write $\left(\cdot / \cdot\right)$ for the <a href="https://en.wikipedia.org/wiki/Kronecker_symbol">Kronecker</a> symbol, a direct generalisation of Legendre&rsquo;s symbol. For each bit of the flag $f_i$, we are given integers $s_i$ where $s_i = t_i - at_i^{-1} \pmod{n}$, $a$ is a given constant such that $\left(a / n\right) = 1$, and $\left(t_i / n\right) = 2f_i - 1 \in \{-1, 1\}$.</p>
<p>To recover $f_i$, we can first solve for $t_i$ by solving the quadratic equation $t_i^2 - s_it_i + a \equiv 0 \pmod{n}$, where the factorisation of $n$ is known from above. Then, we simply evaluate $\left(t_i / n\right)$ to get the flag bits.</p>
<hr>
<h2 id="byeween-174-points-22-solves">Byeween (174 points, 22 solves)<a hidden class="anchor" aria-hidden="true" href="#byeween-174-points-22-solves">#</a></h2>
<p>We are given an elliptic curve over the rationals $E / \mathbb{Q}$ and a point $Q \in E / \mathbb{Q}$, and we have to provide all the points $P$ such that $2P = Q$.</p>
<p>Overcomplicated solution by grhkm: It is believed that $E / \mathbb{Q}$ has rank $0$ or $1$ for asymptotically $100%$ of the time, with the average rank of elliptic curves being $\frac{1}{2}$. Since we are given a rational point on the curve, it will almost always have rank $1$. Therefore, $Q$ can be written as a multiple of the unique generator $G$ of the group, and we can compute <em>a</em> solution to $2P = Q$. From here, all remaining solutions are given by $P' = P + R$, where $R \in E[2]$ i.e. $2R = O$. These are given by $R = (x, 0)$ for the model $y^2 = f(x)$.</p>
<hr>
<h2 id="bertrand-180-points-21-solves">Bertrand (180 points, 21 solves)<a hidden class="anchor" aria-hidden="true" href="#bertrand-180-points-21-solves">#</a></h2>
<p>Difficulty: Medium</p>
<p>We are given a 256x256 grayscale png. The flag is padded with printable chars to have length $256^2$ and then encypted with an unknown key in $\mathbb{Z}_{256}^3$ as the pixels of the png.</p>
<p>If the relative order of the 3 elements in the unknown key $(k_1, k_2, k_3)$ is fixed, the pixels are in the form of $x_i = flag_{p_i} + c_{i,1} k_1 + c_{i,2} k_2 + c_{i,3} k_3 \text{ mod } 256$ where $p$ is a permutation. For each of the relative orders of $k_1$, $k_2$ and $k_3$, $p_i$ and $c_{i,j}$ can be found by slightly modifying the encyption script.</p>
<p>Notice that $(c_{i,1}, c_{i,2}, c_{i,3})$ often equals to one of $(3, 0, 0)$, $(0, 3, 0)$, $(0, 0, 3)$. As $x_i$ is known and $flag_{p_i}$ has a capped range (printable chars), they can be used to eliminate most of the possibities of $k_j$.</p>
<p>Only a few possibilites of $(k_1, k_2, k_3)$ left after that, exhausting them will give the flag.</p>
<hr>
<h2 id="shefid-209-points-17-solves">Shefid (209 points, 17 solves)<a hidden class="anchor" aria-hidden="true" href="#shefid-209-points-17-solves">#</a></h2>
<p>Difficulty: Hard</p>
<p>We are presented with exactly the SIDH scheme.</p>
<p>Solution: Perform Castryck and Decru&rsquo;s attack on SIDH.</p>
<hr>
<h2 id="slowsum-209-points-17-solves">Slowsum (209 points, 17 solves)<a hidden class="anchor" aria-hidden="true" href="#slowsum-209-points-17-solves">#</a></h2>
<p>Difficulty: Tough (?)</p>
<p>We are given the following interesting scheme (NB: Slightly modified):</p>
<ol start="0">
<li>Hash
<ul>
<li>The hash function $H(f)$, where $f \in \mathbb{F}_q[x]$, is defined as $$H(f) = f(1)^{\left(\frac{q - 1}{2} - f(1)\right)} \pmod{q}$$</li>
</ul>
</li>
<li>Setup
<ul>
<li>Define $q = 113$</li>
<li>We send parameters $n \geq 5$ and $d \geq 3$ such that $nd \geq q$</li>
<li>Define $R = \mathbb{F}_q[x_1, \cdots, x_n]$</li>
<li>We send a polynomial $f_0(x_1, \cdots, x_n) \in R$ with $\deg(f_0) = d$.</li>
<li>A checksum $h_0 = \sum_{\mathbf{x} \in \{0, 1\}^n} f(\mathbf{x})$ is computed</li>
</ul>
</li>
<li>Verification
<ul>
<li>We send a sequence of data $(f_1, h_1), \cdots, (f_n, h_n)$ such that
<ul>
<li>Polynomial: $f_i \in \mathbb{F}_q[x]$ is a <em>univariate</em> polynomial.</li>
<li>Degree: $\deg(f_i) \leq d$</li>
<li>Check 1: For $i \geq 2$, $f_i(0) + f_i(1) = f_{i - 1}(h_{i - 1})$</li>
<li>Check 2: $H(f_i) = h_i$</li>
</ul>
</li>
<li>Final check: $f_0(h_1, \cdots, h_n) = f_n(h_n)$</li>
<li>If all checks pass and $f_1(0) + f_1(1) = h_0$, the flag is given.</li>
</ul>
</li>
</ol>
<p>If you are looking at this and wondering what is going on, no worries, so am I. Nevertheless, the solution is pretty simple. We note that $H(f)$ is quite weak. For example, $H(x^k) = 1$ for any $k$. Therefore, the following parameters work:</p>
<p>$$\begin{aligned}
&amp; n = 5, d = 25 \\
&amp; f_0 = x_1^{25} \implies h_0 = 16 \\
&amp; (f_i, h_i) = (x^i, 1)
\end{aligned}$$</p>
<p>This works as for the final check, $f_0(1, \cdots, 1) = 1$ and of course $f_n(h_n) = 1$.</p>
<hr>
<h2 id="vinefruit-194-point-19-solves">Vinefruit (194 point, 19 solves)<a hidden class="anchor" aria-hidden="true" href="#vinefruit-194-point-19-solves">#</a></h2>
<p>We are presented with a rolling hash $H_i(m) = c_i + \sum_j m_j p_i^j \pmod{2^{b_i}}$, where $(c_i, p_i, b_i)$ are one of three parameter sets (2166136261, 16777619, $2^{16}$), (14695981039346656037, 1099511628211, $2^{32}$), (144066263297769815596495629667062367629, 309485009821345068724781371, $2^{64}$). We are then asked to provide message collision pairs $m_1, m_2$ such that $|m_1| = |m_2| = 16$ (or longer, but we can simply add padding).</p>
<p>To solve this, we aim to find a vector message (with coefficients in $[32, 126]$), say $v$, such that $H_i(v) = c_i$. If we have such a message, then $H_i(m + v) = c_i + \sum_j (m_j + v_j) p_i^j = \left(c_i + \sum_j m_j p_i^j\right) + \left(H_i(v) - c_i\right) = H_i(m)$. To find such a vector, we expand the definition to get</p>
<p>$$
H(v) = v_1p + v_2p^2 + \cdots + v_{16}p^{16} \pmod{2^b}
$$</p>
<p>We can solve this by LLL, since the lattice</p>
<p>$$\begin{aligned}
M = \left(\begin{array}{c|c|c}
\begin{matrix} p \\ p^2 \\ \vdots \\ p^{16} \end{matrix} &amp; I_{16} &amp; O \\
\hline
-c_i &amp; O &amp; 1 \\
\hline
2^b &amp; O &amp; O
\end{array}\right)
\end{aligned}$$</p>
<p>spans the vector $v = \{0, v_1, v_2, \cdots, v_{16}, 1\}$. We can answer the challenges from here.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://b6a.black/tags/ctf/">ctf</a></li>
      <li><a href="https://b6a.black/tags/crypto-ctf/">crypto-ctf</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://b6a.black/posts/2024-03-10-b6actf-image-factory/">
        <span class="title">¬´ Prev Page</span>
        <br>
        <span>Bauhinia CTF 2023: Image Factory</span>
      </a>
      <a class="next" href="https://b6a.black/posts/2023-04-05-hkcert-ctf-2022-minecraft/">
        <span class="title">Next Page ¬ª</span>
        <br>
        <span>HKCERT CTF 2022 Making-of: Minecraft Geoguessr</span>
      </a>
    </nav>
  </footer>
</article>
<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    CryptoCTF 2023 Writeup
  </a>
  <div class="js-toc"></div>
</aside>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
    headingSelector: 'h1, h2, h3, h4',
    orderedList: false,
    headingLabelCallback: s => s.substr(0, s.length-1),
    collapseDepth: 2
  });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"> </script>
<script type="text/javascript">
  (function () {
    const vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
      let engine;
      x.getAttribute("class").split(" ").forEach(function (cls) {
        if (cls.startsWith(vizPrefix)) {
          engine = cls.substr(vizPrefix.length);
        }
      });
      const image = new DOMParser().parseFromString(Viz(x.innerText, { format: "svg", engine: engine }), "image/svg+xml");
      x.parentNode.insertBefore(image.documentElement, x);
      x.style.display = 'none'
      x.parentNode.style.backgroundColor = "white"
    });
  })();
</script>
    </main><footer class="footer">
    <span>&copy; 2024 <a href="https://b6a.black/">Black Bauhinia</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }]})"></script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: true,
    htmlLabels: true,
    securityLevel: "loose",
    theme: 'base',
    themeVariables: {
        background: '#22222c',
        primaryColor: '#33333c',
        primaryTextColor: '#ffe4e1',
    }
});
</script>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
