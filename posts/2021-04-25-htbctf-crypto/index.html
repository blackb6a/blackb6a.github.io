<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cyber Apocalypse 2021: Wii Phit &amp; Hyper Metroid | Black Bauhinia</title>

<meta name="keywords" content="ctf, cyber-apocalypse-ctf, crypto" />
<meta name="description" content="We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I&#39;ll include the challenges Wii Phit and Hyper Metroid in this writeup.">
<meta name="author" content="hoifanrd">
<link rel="canonical" href="https://b6a.black/posts/2021-04-25-htbctf-crypto/" />
<link href="/assets/css/stylesheet.min.79c4dfee3993cd3110886e38d36a5106e0d6922344cefa3ff5c0076f246815f0.css" integrity="sha256-ecTf7jmTzTEQiG4402pRBuDWkiNEzvo/9cAHbyRoFfA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b6a.black/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.91.0" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-M67YZZ2MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M67YZZ2MP1');
</script>



<script src="https://kit.fontawesome.com/fbbadced05.js" crossorigin="anonymous"></script>


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Recursive&display=swap" rel="stylesheet"> 


<meta property="og:title" content="Cyber Apocalypse 2021: Wii Phit &amp; Hyper Metroid" />
<meta property="og:description" content="We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I&#39;ll include the challenges Wii Phit and Hyper Metroid in this writeup." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://b6a.black/posts/2021-04-25-htbctf-crypto/" />
<meta property="article:published_time" content="2021-04-25T23:53:00+08:00" />
<meta property="article:modified_time" content="2021-04-25T23:53:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cyber Apocalypse 2021: Wii Phit &amp; Hyper Metroid"/>
<meta name="twitter:description" content="We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I&#39;ll include the challenges Wii Phit and Hyper Metroid in this writeup."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cyber Apocalypse 2021: Wii Phit \u0026 Hyper Metroid",
  "name": "Cyber Apocalypse 2021: Wii Phit \u0026 Hyper Metroid",
  "description": "We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I\u0026#39;ll include the challenges Wii Phit and Hyper Metroid in this writeup.",
  "keywords": [
    "ctf", "cyber-apocalypse-ctf", "crypto"
  ],
  "articleBody": "We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I'll include the challenges Wii Phit and Hyper Metroid in this writeup.\nWii Phit  The aliens have encrypted our save file from Wii Phit and we’re about to lose our 4,869 day streak!! They’re even taunting us with a hint. I think the alien’s are getting a bit over-confident if you ask me.\n CHALLENGE from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f'Flag: {hex(c)}') # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Challenge Analysis Well... The code is pretty simple. It is just importing the number $p$ and $q$, and perform RSA encryption on the flag. Although the public key $N \\neq pq$ as textbook RSA, it won’t be a big problem as we could still find it’s totient function $\\varphi$ easily and calculate it’s private key $d$ if we could find $p$ and $q$.\nSo here’s the question, how could we find $p$ and $q$? Let’s see the hint.\nFinding $p$ and $q$ We could see that the hint gives us four variables, $w$, $x$, $y$ and $z$, where all of them are either in terms of $p$, $q$ and some constant. The program then asserts that:\n\\[w(xz + yz - xy) = 4xyz\\]\nSo lets expand it and make it become a multivariable equation in terms of $p$ and $q$ (and constant $w$):\n\\[ \\begin{aligned} f(p, q) = \u0026-4p^2q - (w-4)p^2 + (2w-10628)pq\\\\ \u0026\\quad-(2659w-10628)p + (2657w-7059648)q - (1767569w-7059648)\\\\ =\u0026\\ 0 \\end{aligned} \\]\nWell it seems so complicated... To be honest, I had no idea what I should do next when I expanded the equation like this. I had tried various methods such as making it into modular equations. But of course as expected, it didn’t work.\nWhen I was struggling with this equation, I suddenly noticed that there are only 2 positive terms in this equation, while the remaining 4 terms are negative terms. More importantly, by observing the degree of each terms, it seems that it's always likely that $f(p, q)$ will be negative no matter what $p$ and $q$ are. Therefore, I suspect that the maximum value of $f(p, q)$ would be 0 actually.\nSo lets assume $f(p_0, q_0)$ be the maximum point of $f(p, q)$. Then we can do partial differentiation on $f(p, q)$ to find out $p_0$ and $q_0$.\n\\[ \\begin{gathered} \\tfrac{\\partial f}{\\partial p} =-8pq - (2w-8)p + (2w-10628)q-(2659w-10628)\\\\ \\tfrac{\\partial f}{\\partial q} =-4p^2 + (2w-10628)p + (2657w-7059648) \\end{gathered} \\]\nFor maximum point, $f_p = 0$ and $f_q = 0$. It's difficult to solve $f_p$ as it's still having 2 variables. However, $f_q$ now remains $p$ as the only term as a quadratic equation! So we are able to solve for $p_0$!\nDoes the quadratic equation has real positive integer root? Yes! Here's the value of $p_0$:\np_0 = 12982730442374884692175714427854159342672585005900410914505931459344379272923599916417142168935973617313528952765371978277344412909738758472305039316830099 So let's plug the value of $p_0$ to $f_p = 0$, then we can solve for $q_0$:\nq_0 = 4376511920801673769046982367789644084746600661635151104602579081967083768976309788885633491753761209012042953502416064276555378570438196809829053232168930363213412874907199642703512833211163084612185095343783021125928854760406110492494016250237689683218940269389627326164130063600050024089561671913076715913062539181517022517918888557966172136200366952844819842691032260278270002343732370611629511112677638724984890716752906711541254394792207074699964511035503381 Finally, we use the value of $p_0$ and $q_0$ to check whether $w(xz + yz - xy) = 4xyz$ and it fits the equation! So the maximum point of $f(p, q)$ is really 0 and we have successfully retrive $p$ and $q$.\nThen the rest is easy. For textbook RSA, the totient function $\\varphi(pq) = (p-1)(q-1)$. In this case, the public key is not $pq$ but $p^3q$, so the totient function would be\n\\[\\varphi(p^3q) = p^2(p-1)(q-1).\\]\nThen we can get the private key $d$ like textbook RSA. Using the private key $d$, we could decrypt the flag. Flag: CHTB{Erdos-Straus-Conjecture}\nMe: Erdos-Straus-Conjecture? What is that?\nHyper Metroid  Dropping a morph ball bomb, Samus cracked open the floor and dropped down into the guts of Phaaze. At the end of the tunnel is a locked chest containing the hyper beam upgrade. Samus found the encrypted key preserved in a ball of glowing biomass, but can’t decode it. Help Samus capture the flag so she can eradicate the alien invasion once and for all.\n CHALLENGE from secrets import flag def alien_prime(a): p = (a^5 - 1) // (a - 1) assert is_prime(p) return p def encrypt_flag(): e = 2873198723981729878912739 Px = int.from_bytes(flag, 'big') P = C.lift_x(Px) JP = J(P) return e * JP def transmit_point(P): mumford_x = P[0].list() mumford_y = P[1].list() return (mumford_x, mumford_y) a = 1152921504606846997 alpha = 1532495540865888942099710761600010701873734514703868973 p = alien_prime(a) FF = FiniteField(p) R.x = PolynomialRing(FF) h = 1 f = alpha*x^5 C = HyperellipticCurve(f,h,'u,v') J = C.jacobian() J = J(J.base_ring()) enc_flag = encrypt_flag() print(f'Encrypted flag: {transmit_point(enc_flag)}') #Encrypted flag: ([1276176453394706789434191960452761709509855370032312388696448886635083641, 989985690717445420998028698274140944147124715646744049560278470410306181, 1], [617662980003970124116899302233508481684830798429115930236899695789143420, 429111447857534151381555500502858912072308212835753316491912322925110307]) The missing piece In the challenge, we are given a hyperelliptic curve $\\mathcal{C}$, a constant $e$ and a point $Q$ (the encrypted flag). The objective is to find the point $P$ such that $Q = eP$. Similar to elliptic curves and modular exponentation, we are able to compute the inverse of $e$ to compute $P$ once we have the order of the field.\nThe missing piece of this puzzle is the order of the Jacobian, $\\#J(\\mathcal{C})$ and there is no efficient algorithm to calculate it generally. That means, this hyperelliptic curve $\\mathcal{C}$ must be some special case so that we could caluclate its $\\#J(\\mathcal{C})$ easily.\nUsing my superior OSINT skills, I was able to find this special case in section 4.3.1 in A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 21.\nAs the same case mentioned in the paper, the prime $p$ generated in this challenge is a generalised Mersenne Prime (in a form of $\\frac{a^5-1}{a-1}$) and $\\alpha$ is also chosen such that\n\\[\\alpha^{(p-1)/5} \\equiv a\\ (\\text{mod}\\ p).\\]\nThis is exactly what we want and we could find out $\\#J(\\mathcal{C})$ in this challenge if we follow the paper!\nBut wait... multiplicative map?... automorphism?... What is $\\zeta$? Oh, it's roots of unity, ...what is that?\nI don't have much knowledge on mathematics that I totally can't understand what's the paper saying. Therefore, I found Mystiz in order to help but it seems that he can't understand the exact steps too... We then stucked there for about one and a half day just because we don't understand the mathematics in the paper.\nCryptosint In the paper, the author gave an example of the Mersenne Prime method and calculated the $\\#J(\\mathcal{C})$ in that example. However, it doesn't show the steps in the example. By skimming the paper, I suddenly noticed that at the end of the paper, the author stated that all code used for the paper is available at the website2. Unfortunately, the paper is published in 2004 and the webpage has disappeared already.\nUsing my superior OSINT skills again. As I think that the website is an university website, it's having a high probability that it's being archived on the Internet. Therefore, I used Wayback Machine and I successfully found that webpage3 and I could even download the source code!\nI then open the C source code on calculating the Mersenne Prime method and changed it to sage.\ndef calculateJacobiSum(a, genus, n): kth_root = 0 index = 0 temp_array = [None] * n jacobi = [None] * n \"\"\" Evaluate the +/- \\sigma^k part of the Jacobi sum This is only for genus 2 and 3 curves Maybe replace this by a formula later \"\"\" modu = a % n if genus == 2: if modu == 0: kth_root = -1 elif modu == 2: kth_root = -4 elif modu == 3: kth_root = 2 elif modu == 4: kth_root = 3 else: kth_root = 0 else: if modu == 0: kth_root = 4 elif modu == 2: kth_root = -3 elif modu == 3: kth_root = -5 elif modu == 4: kth_root = 1 elif modu == 5: kth_root = -6 elif modu == 6: kth_root = 2 else: kth_root = 0 #Calculate rest of jacobi sum if genus == 2: temp_array[0] = a*a temp_array[1] = -a temp_array[2] = 0 temp_array[3] = -a temp_array[4] = 1 else: temp_array[0] = a*a*a temp_array[1] = -a*a temp_array[2] = a temp_array[3] = -1 temp_array[4] = -a*a temp_array[5] = a - (a*a) temp_array[6] = a #Now multiply by kth_root for i in range(n): index = (abs(kth_root) + i) % n jacobi[index] = temp_array[i] if kth_root  0: jacobi[index] *= -1 return jacobi def evaluateOrderTwists(jacobi, i, j, n): twist = 0 order = [None] * (n - 1) roots_unity = [None] * n #Calculate roots of unity that are needed roots_unity[0] = 1 for k in range(1, n): real_part = cos((2*k*pi)/n) imag_part = sin((2*k*pi)/n) roots_unity[k] = real_part + imag_part*I #Add in the \"twist\" to the jacobi sum twist = pow(-1, i) jacobi[j] = jacobi[j] + twist; print(\"twist: \" + str(twist)) order[0] = 0 #Evaluate first iteration for k in range(n): order[0] += (jacobi[k] * roots_unity[k]) #Evaluate norm of jacobi sum (and twist) for k in range(2, n): jac2 = [None] * n index = 0 jac2[0] = jacobi[0] #Bump all the roots of unity up by the \"k-th\" power for l in range(1, n): index = (l * k) % n jac2[index] = jacobi[l] order[k-1] = 0 #Evaluate k-th iteration for l in range(n): order[k-1] += (jac2[l] * roots_unity[l]) #Find the total order of the jacobian total_order = order[0] * order[1] * order[2] * order[3] return total_order.real() You ask me that is the i and j in evaluateOrderTwists? I don't know either. Maybe let's just follow the input of the example in the webpage.\nTherefore, by running the code above in sage, I've successfully found the order of the jacobian.\n#J(C) = 3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880 Then the remaining thing is lift the encrypted flag point onto the jacobian, and multiply it by the inverse to get back the original flag point. Then we could get the flag.\nHere's the solve script:\ndef alien_prime(a): p = (a^5 - 1) // (a - 1) assert is_prime(p) return p def calculateJacobiSum(a, genus, n): kth_root = 0 index = 0 temp_array = [None] * n jacobi = [None] * n \"\"\" Evaluate the +/- \\sigma^k part of the Jacobi sum This is only for genus 2 and 3 curves Maybe replace this by a formula later \"\"\" modu = a % n if genus == 2: if modu == 0: kth_root = -1 elif modu == 2: kth_root = -4 elif modu == 3: kth_root = 2 elif modu == 4: kth_root = 3 else: kth_root = 0 else: if modu == 0: kth_root = 4 elif modu == 2: kth_root = -3 elif modu == 3: kth_root = -5 elif modu == 4: kth_root = 1 elif modu == 5: kth_root = -6 elif modu == 6: kth_root = 2 else: kth_root = 0 #Calculate rest of jacobi sum if genus == 2: temp_array[0] = a*a temp_array[1] = -a temp_array[2] = 0 temp_array[3] = -a temp_array[4] = 1 else: temp_array[0] = a*a*a temp_array[1] = -a*a temp_array[2] = a temp_array[3] = -1 temp_array[4] = -a*a temp_array[5] = a - (a*a) temp_array[6] = a #Now multiply by kth_root for i in range(n): index = (abs(kth_root) + i) % n jacobi[index] = temp_array[i] if kth_root  0: jacobi[index] *= -1 return jacobi def evaluateOrderTwists(jacobi, i, j, n): twist = 0 order = [None] * (n - 1) roots_unity = [None] * n #Calculate roots of unity that are needed roots_unity[0] = 1 for k in range(1, n): real_part = cos((2*k*pi)/n) imag_part = sin((2*k*pi)/n) roots_unity[k] = real_part + imag_part*I #Add in the \"twist\" to the jacobi sum twist = pow(-1, i) jacobi[j] = jacobi[j] + twist; print(\"twist: \" + str(twist)) order[0] = 0 #Evaluate first iteration for k in range(n): order[0] += (jacobi[k] * roots_unity[k]) #Evaluate norm of jacobi sum (and twist) for k in range(2, n): jac2 = [None] * n index = 0 jac2[0] = jacobi[0] #Bump all the roots of unity up by the \"k-th\" power for l in range(1, n): index = (l * k) % n jac2[index] = jacobi[l] order[k-1] = 0 #Evaluate k-th iteration for l in range(n): order[k-1] += (jac2[l] * roots_unity[l]) #Find the total order of the jacobian total_order = order[0] * order[1] * order[2] * order[3] return total_order.real() def data_to_jacobian(data): u, v = data[0], data[1] u = sum([u[i] * x^i for i in range(3)]) v = sum([v[i] * x^i for i in range(2)]) return J((u, v)) a = 1152921504606846997 g = 2 n = 5 e = 2873198723981729878912739 jacobi = calculateJacobiSum(a, g, n) #order = evaluateOrderTwists(jacobi, 0, 1, n).n(digits=200) order = 3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880 alpha = 1532495540865888942099710761600010701873734514703868973 p = alien_prime(a) FF = FiniteField(p) R.x = PolynomialRing(FF) C = HyperellipticCurve(alpha*x^5,1,'u,v') J = C.jacobian() J = J(J.base_ring()) enc_flag = ([1276176453394706789434191960452761709509855370032312388696448886635083641, 989985690717445420998028698274140944147124715646744049560278470410306181, 1], [617662980003970124116899302233508481684830798429115930236899695789143420, 429111447857534151381555500502858912072308212835753316491912322925110307]) inv = inverse_mod(e, order) J_point = data_to_jacobian(enc_flag) flag_point = inv*J_point flag_int = flag_point[0].coefficients()[0] print(-flag_int % p) Flag: CHTB{hyp3r_sp33d_c0unting!!}\nWho need maths if you can OSINT?\n  Colm Ó hÉigeartaigh (2004) \"A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 2\"\nhttps://eprint.iacr.org/2004/241.pdf [return] Colm Ó hÉigeartaigh (2004) \"Hyperelliptic Curve Cryptographic Software\" (Invalid)\nhttp://www.computing.dcu.ie/~coheigeartaigh/crypto.html [return] Colm Ó hÉigeartaigh (2004) \"Hyperelliptic Curve Cryptographic Software\"\nhttps://web.archive.org/web/20050924125637/http://www.computing.dcu.ie/~coheigeartaigh/crypto.html [return]   ",
  "wordCount" : "2183",
  "inLanguage": "en",
  "datePublished": "2021-04-25T23:53:00+08:00",
  "dateModified": "2021-04-25T23:53:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "hoifanrd"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://b6a.black/posts/2021-04-25-htbctf-crypto/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Black Bauhinia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://b6a.black/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b6a.black/" accesskey="h" title="Black Bauhinia (Alt + H)">Black Bauhinia</a>
            <span class="logo-switches">
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://b6a.black/about-us/" title="About Us">
                    <span>About Us</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Cyber Apocalypse 2021: Wii Phit &amp; Hyper Metroid
    </h1>
    <div class="post-meta">

April 25, 2021&nbsp;·&nbsp;hoifanrd

</div>
  </header>
  
  
  <div class="post-content js-toc-content">
<p>We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I'll include the challenges Wii Phit and Hyper Metroid in this writeup.</p>

<h2 id="wii-phit">Wii Phit<a hidden class="anchor" aria-hidden="true" href="#wii-phit">#</a></h2>

<blockquote>
<p>The aliens have encrypted our save file from Wii Phit and we’re about to lose our 4,869 day streak!! They’re even taunting us with a hint. I think the alien’s are getting a bit over-confident if you ask me.</p>
</blockquote>

<h5 id="challenge">CHALLENGE<a hidden class="anchor" aria-hidden="true" href="#challenge">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> bytes_to_long
<span style="color:#f92672">from</span> secrets <span style="color:#f92672">import</span> FLAG,p,q

N <span style="color:#f92672">=</span> p<span style="color:#f92672">**</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> q
e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10001</span>
c <span style="color:#f92672">=</span> pow(bytes_to_long(FLAG),e,N)

print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Flag: </span><span style="color:#e6db74">{</span>hex(c)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)

<span style="color:#75715e"># Hint</span>

w <span style="color:#f92672">=</span> <span style="color:#ae81ff">25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855</span>
x <span style="color:#f92672">=</span> p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1328</span>
y <span style="color:#f92672">=</span> p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1329</span>
z <span style="color:#f92672">=</span> q <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

<span style="color:#66d9ef">assert</span> w<span style="color:#f92672">*</span>(x<span style="color:#f92672">*</span>z <span style="color:#f92672">+</span> y<span style="color:#f92672">*</span>z <span style="color:#f92672">-</span> x<span style="color:#f92672">*</span>y) <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">*</span>x<span style="color:#f92672">*</span>y<span style="color:#f92672">*</span>z</code></pre></div>
<h3 id="challenge-analysis">Challenge Analysis<a hidden class="anchor" aria-hidden="true" href="#challenge-analysis">#</a></h3>

<p>Well... The code is pretty simple. It is just importing the number $p$ and $q$, and perform RSA encryption on the flag. Although the public key $N \neq pq$ as textbook RSA, it won’t be a big problem as we could still find it’s totient function $\varphi$ easily and calculate it’s private key $d$ if we could find $p$ and $q$.</p>

<p>So here’s the question, how could we find $p$ and $q$? Let’s see the hint.</p>

<h3 id="finding-p-and-q">Finding $p$ and $q$<a hidden class="anchor" aria-hidden="true" href="#finding-p-and-q">#</a></h3>

<p>We could see that the hint gives us four variables, $w$, $x$, $y$ and $z$, where all of them are either in terms of $p$, $q$ and some constant. The program then asserts that:</p>

<p><span  class="math">\[w(xz + yz - xy) = 4xyz\]</span></p>

<p>So lets expand it and make it become a multivariable equation in terms of $p$ and $q$ (and constant $w$):</p>

<p><span  class="math">\[
\begin{aligned}
f(p, q) = &-4p^2q - (w-4)p^2 + (2w-10628)pq\\
&\quad-(2659w-10628)p + (2657w-7059648)q - (1767569w-7059648)\\
=&\ 0
\end{aligned}
\]</span></p>

<p>Well it seems so complicated... To be honest, I had no idea what I should do next when I expanded the equation like this. I had tried various methods such as making it into modular equations. But of course as expected, it didn’t work.</p>

<p>When I was struggling with this equation, I suddenly noticed that there are only 2 positive terms in this equation, while the remaining 4 terms are negative terms. More importantly, by observing the degree of each terms, it seems that it's always likely that $f(p, q)$ will be negative no matter what $p$ and $q$ are. Therefore, I suspect that the maximum value of $f(p, q)$ would be 0 actually.</p>

<p>So lets assume $f(p_0, q_0)$ be the maximum point of $f(p, q)$. Then we can do partial differentiation on $f(p, q)$ to find out $p_0$ and $q_0$.</p>

<p><span  class="math">\[
\begin{gathered}
\tfrac{\partial f}{\partial p} =-8pq - (2w-8)p + (2w-10628)q-(2659w-10628)\\
\tfrac{\partial f}{\partial q} =-4p^2 + (2w-10628)p + (2657w-7059648)
\end{gathered}
\]</span></p>

<p>For maximum point, $f_p = 0$ and $f_q = 0$. It's difficult to solve $f_p$ as it's still having 2 variables. However, $f_q$ now remains $p$ as the only term as a quadratic equation! So we are able to solve for $p_0$!</p>

<p>Does the quadratic equation has real positive integer root? Yes! Here's the value of $p_0$:</p>
<pre tabindex="0"><code>p_0 = 12982730442374884692175714427854159342672585005900410914505931459344379272923599916417142168935973617313528952765371978277344412909738758472305039316830099</code></pre>
<p>So let's plug the value of $p_0$ to $f_p = 0$, then we can solve for $q_0$:</p>
<pre tabindex="0"><code>q_0 = 4376511920801673769046982367789644084746600661635151104602579081967083768976309788885633491753761209012042953502416064276555378570438196809829053232168930363213412874907199642703512833211163084612185095343783021125928854760406110492494016250237689683218940269389627326164130063600050024089561671913076715913062539181517022517918888557966172136200366952844819842691032260278270002343732370611629511112677638724984890716752906711541254394792207074699964511035503381</code></pre>
<p>Finally, we use the value of $p_0$ and $q_0$ to check whether $w(xz + yz - xy) = 4xyz$ and it fits the equation! So the maximum point of $f(p, q)$ is really 0 and we have successfully retrive $p$ and $q$.</p>

<p>Then the rest is easy. For textbook RSA, the totient function $\varphi(pq) = (p-1)(q-1)$. In this case, the public key is not $pq$ but $p^3q$, so the totient function would be</p>

<p><span  class="math">\[\varphi(p^3q) = p^2(p-1)(q-1).\]</span></p>

<p>Then we can get the private key $d$ like textbook RSA. Using the private key $d$, we could decrypt the flag. Flag: <code>CHTB{Erdos-Straus-Conjecture}</code></p>

<p><del>Me: Erdos-Straus-Conjecture? What is that?</del></p>

<h2 id="hyper-metroid">Hyper Metroid<a hidden class="anchor" aria-hidden="true" href="#hyper-metroid">#</a></h2>

<blockquote>
<p>Dropping a morph ball bomb, Samus cracked open the floor and dropped down into the guts of Phaaze. At the end of the tunnel is a locked chest containing the hyper beam upgrade. Samus found the encrypted key preserved in a ball of glowing biomass, but can’t decode it. Help Samus capture the flag so she can eradicate the alien invasion once and for all.</p>
</blockquote>

<h5 id="challenge-1">CHALLENGE<a hidden class="anchor" aria-hidden="true" href="#challenge-1">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> secrets <span style="color:#f92672">import</span> flag

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">alien_prime</span>(a):
    p <span style="color:#f92672">=</span> (a<span style="color:#f92672">^</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> (a <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">assert</span> is_prime(p)
    <span style="color:#66d9ef">return</span> p


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt_flag</span>():
    e <span style="color:#f92672">=</span> <span style="color:#ae81ff">2873198723981729878912739</span>
    Px <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(flag, <span style="color:#e6db74">&#39;big&#39;</span>)
    P <span style="color:#f92672">=</span> C<span style="color:#f92672">.</span>lift_x(Px)
    JP <span style="color:#f92672">=</span> J(P)
    <span style="color:#66d9ef">return</span> e <span style="color:#f92672">*</span> JP


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">transmit_point</span>(P):
    mumford_x <span style="color:#f92672">=</span> P[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>list()
    mumford_y <span style="color:#f92672">=</span> P[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>list()
    <span style="color:#66d9ef">return</span> (mumford_x, mumford_y)


a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1152921504606846997</span>
alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">1532495540865888942099710761600010701873734514703868973</span>
p <span style="color:#f92672">=</span> alien_prime(a)

FF <span style="color:#f92672">=</span> FiniteField(p)
R<span style="color:#f92672">.&lt;</span>x<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> PolynomialRing(FF)

h <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
f <span style="color:#f92672">=</span> alpha<span style="color:#f92672">*</span>x<span style="color:#f92672">^</span><span style="color:#ae81ff">5</span>

C <span style="color:#f92672">=</span> HyperellipticCurve(f,h,<span style="color:#e6db74">&#39;u,v&#39;</span>)
J <span style="color:#f92672">=</span> C<span style="color:#f92672">.</span>jacobian()
J <span style="color:#f92672">=</span> J(J<span style="color:#f92672">.</span>base_ring())

enc_flag <span style="color:#f92672">=</span> encrypt_flag()

print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Encrypted flag: </span><span style="color:#e6db74">{</span>transmit_point(enc_flag)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)

<span style="color:#75715e">#Encrypted flag: ([1276176453394706789434191960452761709509855370032312388696448886635083641, 989985690717445420998028698274140944147124715646744049560278470410306181, 1], [617662980003970124116899302233508481684830798429115930236899695789143420, 429111447857534151381555500502858912072308212835753316491912322925110307])</span></code></pre></div>
<h3 id="the-missing-piece">The missing piece<a hidden class="anchor" aria-hidden="true" href="#the-missing-piece">#</a></h3>

<p>In the challenge, we are given a hyperelliptic curve $\mathcal{C}$, a constant $e$ and a point $Q$ (the encrypted flag). The objective is to find the point $P$ such that $Q = eP$. Similar to elliptic curves and modular exponentation, we are able to compute the inverse of $e$ to compute $P$ once we have the order of the field.</p>

<p>The missing piece of this puzzle is the order of the Jacobian, $\#J(\mathcal{C})$ and there is no efficient algorithm to calculate it generally. That means, this hyperelliptic curve $\mathcal{C}$ must be some special case so that we could caluclate its $\#J(\mathcal{C})$ easily.</p>

<p>Using my <del>superior</del> OSINT skills, I was able to find this special case in section 4.3.1 in A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 2<sup class="footnote-ref" id="fnref:iacr-2004-241"><a class="footnote" href="#fn:iacr-2004-241">1</a></sup>.</p>

<p>As the same case mentioned in the paper, the prime $p$ generated in this challenge is a generalised Mersenne Prime (in a form of $\frac{a^5-1}{a-1}$) and $\alpha$ is also chosen such that</p>

<p><span  class="math">\[\alpha^{(p-1)/5} \equiv a\ (\text{mod}\ p).\]</span></p>

<p>This is exactly what we want and we could find out $\#J(\mathcal{C})$ in this challenge if we follow the paper!</p>

<p>But wait... multiplicative map?... automorphism?... What is $\zeta$? Oh, it's roots of unity, ...what is that?</p>

<p>I don't have much knowledge on mathematics that I totally can't understand what's the paper saying. Therefore, I found Mystiz in order to help but it seems that he can't understand the exact steps too... We then stucked there for about one and a half day just because we don't understand the mathematics in the paper.</p>

<h3 id="cryptosint"><del>Cryptosint</del><a hidden class="anchor" aria-hidden="true" href="#cryptosint">#</a></h3>

<p>In the paper, the author gave an example of the Mersenne Prime method and calculated the $\#J(\mathcal{C})$ in that example. However, it doesn't show the steps in the example. By skimming the paper, I suddenly noticed that at the end of the paper, the author stated that all code used for the paper is available at the website<sup class="footnote-ref" id="fnref:coheigeartaigh-crypto-1"><a class="footnote" href="#fn:coheigeartaigh-crypto-1">2</a></sup>. Unfortunately, the paper is published in 2004 and the webpage has disappeared already.</p>

<p>Using my <del>superior</del> OSINT skills again. As I think that the website is an university website, it's having a high probability that it's being archived on the Internet. Therefore, I used <a href="https://archive.org/web/">Wayback Machine</a> and I successfully found that webpage<sup class="footnote-ref" id="fnref:coheigeartaigh-crypto-2"><a class="footnote" href="#fn:coheigeartaigh-crypto-2">3</a></sup> and I could even download the source code!</p>

<p>I then open the C source code on calculating the Mersenne Prime method and changed it to sage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calculateJacobiSum</span>(a, genus, n):
    kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    temp_array <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    jacobi <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Evaluate the +/- \sigma^k part of the Jacobi sum
</span><span style="color:#e6db74">    This is only for genus 2 and 3 curves
</span><span style="color:#e6db74">    Maybe replace this by a formula later
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    modu <span style="color:#f92672">=</span> a <span style="color:#f92672">%</span> n
    <span style="color:#66d9ef">if</span> genus <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
        <span style="color:#66d9ef">if</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">else</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">if</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    
    <span style="color:#75715e">#Calculate rest of jacobi sum</span>
    <span style="color:#66d9ef">if</span> genus <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
        temp_array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a
        temp_array[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        temp_array[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a
        temp_array[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">else</span>:
        temp_array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> a
        temp_array[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        temp_array[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> a <span style="color:#f92672">-</span> (a<span style="color:#f92672">*</span>a)
        temp_array[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> a
    
    <span style="color:#75715e">#Now multiply by kth_root</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        index <span style="color:#f92672">=</span> (abs(kth_root) <span style="color:#f92672">+</span> i) <span style="color:#f92672">%</span> n
        jacobi[index] <span style="color:#f92672">=</span> temp_array[i]
        <span style="color:#66d9ef">if</span> kth_root <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            jacobi[index] <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    
    <span style="color:#66d9ef">return</span> jacobi

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">evaluateOrderTwists</span>(jacobi, i, j, n):
    twist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    
    order <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
    roots_unity <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    
    <span style="color:#75715e">#Calculate roots of unity that are needed</span>
    roots_unity[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
        real_part <span style="color:#f92672">=</span> cos((<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>k<span style="color:#f92672">*</span>pi)<span style="color:#f92672">/</span>n)
        imag_part <span style="color:#f92672">=</span> sin((<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>k<span style="color:#f92672">*</span>pi)<span style="color:#f92672">/</span>n)
        roots_unity[k] <span style="color:#f92672">=</span> real_part <span style="color:#f92672">+</span> imag_part<span style="color:#f92672">*</span>I
    
    <span style="color:#75715e">#Add in the &#34;twist&#34; to the jacobi sum</span>
    twist <span style="color:#f92672">=</span> pow(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i)
    jacobi[j] <span style="color:#f92672">=</span> jacobi[j] <span style="color:#f92672">+</span> twist;
    
    print(<span style="color:#e6db74">&#34;twist: &#34;</span> <span style="color:#f92672">+</span> str(twist))
    
    order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#75715e">#Evaluate first iteration</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(n):
        order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> (jacobi[k] <span style="color:#f92672">*</span> roots_unity[k])
    
    <span style="color:#75715e">#Evaluate norm of jacobi sum (and twist)</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
        jac2 <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
        index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        jac2[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> jacobi[<span style="color:#ae81ff">0</span>]
        
        <span style="color:#75715e">#Bump all the roots of unity up by the &#34;k-th&#34; power</span>
        <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
            index <span style="color:#f92672">=</span> (l <span style="color:#f92672">*</span> k) <span style="color:#f92672">%</span> n
            jac2[index] <span style="color:#f92672">=</span> jacobi[l]

        order[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#75715e">#Evaluate k-th iteration</span>
        <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(n):
            order[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> (jac2[l] <span style="color:#f92672">*</span> roots_unity[l])
    
    <span style="color:#75715e">#Find the total order of the jacobian</span>
    total_order <span style="color:#f92672">=</span> order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">3</span>]

    <span style="color:#66d9ef">return</span> total_order<span style="color:#f92672">.</span>real()</code></pre></div>
<p>You ask me that is the <code>i</code> and <code>j</code> in <code>evaluateOrderTwists</code>? I don't know either. Maybe let's just follow the input of the example in the webpage.</p>

<p>Therefore, by running the code above in sage, I've successfully found the order of the jacobian.</p>
<pre tabindex="0"><code>#J(C) = 3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880</code></pre>
<p>Then the remaining thing is lift the encrypted flag point onto the jacobian, and multiply it by the inverse to get back the original flag point. Then we could get the flag.</p>

<p>Here's the solve script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">alien_prime</span>(a):
	p <span style="color:#f92672">=</span> (a<span style="color:#f92672">^</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> (a <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">assert</span> is_prime(p)
	<span style="color:#66d9ef">return</span> p

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calculateJacobiSum</span>(a, genus, n):
    kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    temp_array <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    jacobi <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Evaluate the +/- \sigma^k part of the Jacobi sum
</span><span style="color:#e6db74">    This is only for genus 2 and 3 curves
</span><span style="color:#e6db74">    Maybe replace this by a formula later
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    modu <span style="color:#f92672">=</span> a <span style="color:#f92672">%</span> n
    <span style="color:#66d9ef">if</span> genus <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
        <span style="color:#66d9ef">if</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">else</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">if</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>
        <span style="color:#66d9ef">elif</span> modu <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span>: kth_root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    
    <span style="color:#75715e">#Calculate rest of jacobi sum</span>
    <span style="color:#66d9ef">if</span> genus <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
        temp_array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a
        temp_array[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        temp_array[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a
        temp_array[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">else</span>:
        temp_array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> a
        temp_array[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        temp_array[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>a<span style="color:#f92672">*</span>a
        temp_array[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> a <span style="color:#f92672">-</span> (a<span style="color:#f92672">*</span>a)
        temp_array[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> a
    
    <span style="color:#75715e">#Now multiply by kth_root</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        index <span style="color:#f92672">=</span> (abs(kth_root) <span style="color:#f92672">+</span> i) <span style="color:#f92672">%</span> n
        jacobi[index] <span style="color:#f92672">=</span> temp_array[i]
        <span style="color:#66d9ef">if</span> kth_root <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            jacobi[index] <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    
    <span style="color:#66d9ef">return</span> jacobi

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">evaluateOrderTwists</span>(jacobi, i, j, n):
    twist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    
    order <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
    roots_unity <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
    
    <span style="color:#75715e">#Calculate roots of unity that are needed</span>
    roots_unity[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
        real_part <span style="color:#f92672">=</span> cos((<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>k<span style="color:#f92672">*</span>pi)<span style="color:#f92672">/</span>n)
        imag_part <span style="color:#f92672">=</span> sin((<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>k<span style="color:#f92672">*</span>pi)<span style="color:#f92672">/</span>n)
        roots_unity[k] <span style="color:#f92672">=</span> real_part <span style="color:#f92672">+</span> imag_part<span style="color:#f92672">*</span>I
    
    <span style="color:#75715e">#Add in the &#34;twist&#34; to the jacobi sum</span>
    twist <span style="color:#f92672">=</span> pow(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i)
    jacobi[j] <span style="color:#f92672">=</span> jacobi[j] <span style="color:#f92672">+</span> twist;
    
    print(<span style="color:#e6db74">&#34;twist: &#34;</span> <span style="color:#f92672">+</span> str(twist))
    
    order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#75715e">#Evaluate first iteration</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(n):
        order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> (jacobi[k] <span style="color:#f92672">*</span> roots_unity[k])
    
    <span style="color:#75715e">#Evaluate norm of jacobi sum (and twist)</span>
    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
        jac2 <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
        index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        jac2[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> jacobi[<span style="color:#ae81ff">0</span>]
        
        <span style="color:#75715e">#Bump all the roots of unity up by the &#34;k-th&#34; power</span>
        <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
            index <span style="color:#f92672">=</span> (l <span style="color:#f92672">*</span> k) <span style="color:#f92672">%</span> n
            jac2[index] <span style="color:#f92672">=</span> jacobi[l]

        order[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#75715e">#Evaluate k-th iteration</span>
        <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(n):
            order[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> (jac2[l] <span style="color:#f92672">*</span> roots_unity[l])
    
    <span style="color:#75715e">#Find the total order of the jacobian</span>
    total_order <span style="color:#f92672">=</span> order[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> order[<span style="color:#ae81ff">3</span>]

    <span style="color:#66d9ef">return</span> total_order<span style="color:#f92672">.</span>real()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">data_to_jacobian</span>(data):
    u, v <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>], data[<span style="color:#ae81ff">1</span>]
    u <span style="color:#f92672">=</span> sum([u[i] <span style="color:#f92672">*</span> x<span style="color:#f92672">^</span>i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>)])
    v <span style="color:#f92672">=</span> sum([v[i] <span style="color:#f92672">*</span> x<span style="color:#f92672">^</span>i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>)])

    <span style="color:#66d9ef">return</span> J((u, v))

a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1152921504606846997</span>
g <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
e <span style="color:#f92672">=</span> <span style="color:#ae81ff">2873198723981729878912739</span>

jacobi <span style="color:#f92672">=</span> calculateJacobiSum(a, g, n)

<span style="color:#75715e">#order = evaluateOrderTwists(jacobi, 0, 1, n).n(digits=200)</span>
order <span style="color:#f92672">=</span> <span style="color:#ae81ff">3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880</span>

alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">1532495540865888942099710761600010701873734514703868973</span>
p <span style="color:#f92672">=</span> alien_prime(a)

FF <span style="color:#f92672">=</span> FiniteField(p)
R<span style="color:#f92672">.&lt;</span>x<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> PolynomialRing(FF)

C <span style="color:#f92672">=</span> HyperellipticCurve(alpha<span style="color:#f92672">*</span>x<span style="color:#f92672">^</span><span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;u,v&#39;</span>)
J <span style="color:#f92672">=</span> C<span style="color:#f92672">.</span>jacobian()
J <span style="color:#f92672">=</span> J(J<span style="color:#f92672">.</span>base_ring())

enc_flag <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1276176453394706789434191960452761709509855370032312388696448886635083641</span>, <span style="color:#ae81ff">989985690717445420998028698274140944147124715646744049560278470410306181</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">617662980003970124116899302233508481684830798429115930236899695789143420</span>, <span style="color:#ae81ff">429111447857534151381555500502858912072308212835753316491912322925110307</span>])

inv <span style="color:#f92672">=</span> inverse_mod(e, order)
J_point <span style="color:#f92672">=</span> data_to_jacobian(enc_flag)
flag_point <span style="color:#f92672">=</span> inv<span style="color:#f92672">*</span>J_point
flag_int <span style="color:#f92672">=</span> flag_point[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>coefficients()[<span style="color:#ae81ff">0</span>]

print(<span style="color:#f92672">-</span>flag_int <span style="color:#f92672">%</span> p)</code></pre></div>
<p>Flag: <code>CHTB{hyp3r_sp33d_c0unting!!}</code></p>

<p><del>Who need maths if you can OSINT?</del></p>
<div class="footnotes">

<hr>

<ol>
<li id="fn:iacr-2004-241">Colm Ó hÉigeartaigh (2004) &quot;A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 2&quot;<br><a href="https://eprint.iacr.org/2004/241.pdf">https://eprint.iacr.org/2004/241.pdf</a>
 <a class="footnote-return" href="#fnref:iacr-2004-241"><sup>[return]</sup></a></li>
<li id="fn:coheigeartaigh-crypto-1">Colm Ó hÉigeartaigh (2004) &quot;Hyperelliptic Curve Cryptographic Software&quot; (Invalid)<br><a href="http://www.computing.dcu.ie/~coheigeartaigh/crypto.html">http://www.computing.dcu.ie/~coheigeartaigh/crypto.html</a>
 <a class="footnote-return" href="#fnref:coheigeartaigh-crypto-1"><sup>[return]</sup></a></li>
<li id="fn:coheigeartaigh-crypto-2">Colm Ó hÉigeartaigh (2004) &quot;Hyperelliptic Curve Cryptographic Software&quot;<br><a href="https://web.archive.org/web/20050924125637/http://www.computing.dcu.ie/~coheigeartaigh/crypto.html">https://web.archive.org/web/20050924125637/http://www.computing.dcu.ie/~coheigeartaigh/crypto.html</a>
 <a class="footnote-return" href="#fnref:coheigeartaigh-crypto-2"><sup>[return]</sup></a></li>
</ol>
</div>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://b6a.black/tags/ctf/">ctf</a></li>
      <li><a href="https://b6a.black/tags/cyber-apocalypse-ctf/">cyber-apocalypse-ctf</a></li>
      <li><a href="https://b6a.black/tags/crypto/">crypto</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://b6a.black/posts/2021-05-22-3kctf/">
        <span class="title">« Prev Page</span>
        <br>
        <span>3kCTF-2021 Writeup</span>
      </a>
      <a class="next" href="https://b6a.black/posts/2021-02-09-dicectf-liye/">
        <span class="title">Next Page »</span>
        <br>
        <span>DiceCTF 2021: Lost in your Eyes</span>
      </a>
    </nav>
  </footer>
</article>
<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    Cyber Apocalypse 2021: Wii Phit &amp; Hyper Metroid
  </a>
  <div class="js-toc"></div>
</aside>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
    headingSelector: 'h1, h2, h3, h4',
    orderedList: false,
    headingLabelCallback: s => s.substr(0, s.length-1),
    collapseDepth: 2
  });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"> </script>
<script type="text/javascript">
  (function () {
    const vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
      let engine;
      x.getAttribute("class").split(" ").forEach(function (cls) {
        if (cls.startsWith(vizPrefix)) {
          engine = cls.substr(vizPrefix.length);
        }
      });
      const image = new DOMParser().parseFromString(Viz(x.innerText, { format: "svg", engine: engine }), "image/svg+xml");
      x.parentNode.insertBefore(image.documentElement, x);
      x.style.display = 'none'
      x.parentNode.style.backgroundColor = "white"
    });
  })();
</script>
    </main><footer class="footer">
    <span>&copy; 2023 <a href="https://b6a.black/">Black Bauhinia</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }]})"></script>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
